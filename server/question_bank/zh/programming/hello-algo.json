{
  "question_type": "short",
  "designated_role": "examiner",
  "icon": "mdi-math-integral-box",
  "description": "由 Krahets 老师制作的开源算法学习书籍",
  "link": "https://www.hello-algo.com/",
  "total_question_count": 900,
  "files": [
    {
      "file_name": "character_encoding.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 字符编码 *\n\n在计算机中，所有数据都是以二进制数的形式存储的，字符 `char` 也不例外。为了表示字符，我们需要建立一套“字符集”，规定每个字符和二进制数之间的一一对应关系。有了字符集之后，计算机就可以通过查表完成二进制数到字符的转换。\n\n## ASCII 字符集\n\n「ASCII 码」是最早出现的字符集，全称为“美国标准信息交换代码”。它使用 7 位二进制数（即一个字节的低 7 位）表示一个字符，最多能够表示 128 个不同的字符。如下图所示，ASCII 码包括英文字母的大小写、数字 0 ~ 9、一些标点符号，以及一些控制字符（如换行符和制表符）。\n\n![ASCII 码](character_encoding.assets/ascii_table.png)\n\n然而，**ASCII 码仅能够表示英文**。随着计算机的全球化，诞生了一种能够表示更多语言的字符集「EASCII」。它在 ASCII 的 7 位基础上扩展到 8 位，能够表示 256 个不同的字符。\n\n在世界范围内，陆续出现了一批适用于不同地区的 EASCII 字符集。这些字符集的前 128 个字符统一为 ASCII 码，后 128 个字符定义不同，以适应不同语言的需求。\n\n## GBK 字符集\n\n后来人们发现，**EASCII 码仍然无法满足许多语言的字符数量要求**。比如汉字大约有近十万个，光日常使用的就有几千个。中国国家标准总局于 1980 年发布了「GB2312」字符集，其收录了 6763 个汉字，基本满足了汉字的计算机处理需要。\n\n然而，GB2312 无法处理部分的罕见字和繁体字。「GBK」字符集是在 GB2312 的基础上扩展得到的，它共收录了 21886 个汉字。在 GBK 的编码方案中，ASCII 字符使用一个字节表示，汉字使用两个字节表示。\n\n## Unicode 字符集\n\n随着计算机的蓬勃发展，字符集与编码标准百花齐放，而这带来了许多问题。一方面，这些字符集一般只定义了特定语言的字符，无法在多语言环境下正常工作。另一方面，同一种语言也存在多种字符集标准，如果两台电脑安装的是不同的编码标准，则在信息传递时就会出现乱码。\n\n那个时代的研究人员就在想：**如果推出一个足够完整的字符集，将世界范围内的所有语言和符号都收录其中，不就可以解决跨语言环境和乱码问题了吗**？在这种想法的驱动下，一个大而全的字符集 Unicode 应运而生。\n\n「Unicode」的全称为“统一字符编码”，理论上能容纳一百多万个字符。它致力于将全球范围内的字符纳入到统一的字符集之中，提供一种通用的字符集来处理和显示各种语言文字，减少因为编码标准不同而产生的乱码问题。\n\n自 1991 年发布以来，Unicode 不断扩充新的语言与字符。截止 2022 年 9 月，Unicode 已经包含 149186 个字符，包括各种语言的字符、符号、甚至是表情符号等。在庞大的 Unicode 字符集中，常用的字符占用 2 字节，有些生僻的字符占 3 字节甚至 4 字节。\n\nUnicode 是一种字符集标准，本质上是给每个字符分配一个编号（称为“码点”），**但它并没有规定在计算机中如何存储这些字符码点**。我们不禁会问：当多种长度的 Unicode 码点同时出现在同一个文本中时，系统如何解析字符？例如给定一个长度为 2 字节的编码，系统如何确认它是一个 2 字节的字符还是两个 1 字节的字符？\n\n对于以上问题，**一种直接的解决方案是将所有字符存储为等长的编码**。如下图所示，“Hello”中的每个字符占用 1 字节，“算法”中的每个字符占用 2 字节。我们可以通过高位填 0 ，将“Hello 算法”中的所有字符都编码为 2 字节长度。这样系统就可以每隔 2 字节解析一个字符，恢复出这个短语的内容了。\n\n![Unicode 编码示例](character_encoding.assets/unicode_hello_algo.png)\n\n然而 ASCII 码已经向我们证明，编码英文只需要 1 字节。若采用上述方案，英文文本占用空间的大小将会是 ASCII 编码下大小的两倍，非常浪费内存空间。因此，我们需要一种更加高效的 Unicode 编码方法。\n\n## UTF-8 编码\n\n目前，UTF-8 已成为国际上使用最广泛的 Unicode 编码方法。**它是一种可变长的编码**，使用 1 到 4 个字节来表示一个字符，根据字符的复杂性而变。ASCII 字符只需要 1 个字节，拉丁字母和希腊字母需要 2 个字节，常用的中文字符需要 3 个字节，其他的一些生僻字符需要 4 个字节。\n\nUTF-8 的编码规则并不复杂，分为以下两种情况。\n\n- 对于长度为 1 字节的字符，将最高位设置为 $0$、其余 7 位设置为 Unicode 码点。值得注意的是，ASCII 字符在 Unicode 字符集中占据了前 128 个码点。也就是说，**UTF-8 编码可以向下兼容 ASCII 码**。这意味着我们可以使用 UTF-8 来解析年代久远的 ASCII 码文本。\n- 对于长度为 $n$ 字节的字符（其中 $n > 1$），将首个字节的高 $n$ 位都设置为 $1$、第 $n + 1$ 位设置为 $0$ ；从第二个字节开始，将每个字节的高 2 位都设置为 $10$ ；其余所有位用于填充字符的 Unicode 码点。\n\n下图展示了“Hello算法”对应的 UTF-8 编码。观察发现，由于最高 $n$ 位都被设置为 $1$ ，因此系统可以通过读取最高位 $1$ 的个数来解析出字符的长度为 $n$ 。\n\n但为什么要将其余所有字节的高 2 位都设置为 $10$ 呢？实际上，这个 $10$ 能够起到校验符的作用。假设系统从一个错误的字节开始解析文本，字节头部的 $10$ 能够帮助系统快速的判断出异常。\n\n之所以将 $10$ 当作校验符，是因为在 UTF-8 编码规则下，不可能有字符的最高两位是 $10$ 。这个结论可以用反证法来证明：假设一个字符的最高两位是 $10$ ，说明该字符的长度为 $1$ ，对应 ASCII 码。而 ASCII 码的最高位应该是 $0$ ，与假设矛盾。\n\n![UTF-8 编码示例](character_encoding.assets/utf-8_hello_algo.png)\n\n除了 UTF-8 之外，常见的编码方式还包括以下两种。\n\n- **UTF-16 编码**：使用 2 或 4 个字节来表示一个字符。所有的 ASCII 字符和常用的非英文字符，都用 2 个字节表示；少数字符需要用到 4 个字节表示。对于 2 字节的字符，UTF-16 编码与 Unicode 码点相等。\n- **UTF-32 编码**：每个字符都使用 4 个字节。这意味着 UTF-32 会比 UTF-8 和 UTF-16 更占用空间，特别是对于 ASCII 字符占比较高的文本。\n\n从存储空间的角度看，使用 UTF-8 表示英文字符非常高效，因为它仅需 1 个字节；使用 UTF-16 编码某些非英文字符（例如中文）会更加高效，因为它只需要 2 个字节，而 UTF-8 可能需要 3 个字节。\n\n从兼容性的角度看，UTF-8 的通用性最佳，许多工具和库都优先支持 UTF-8 。",
          "questions": [
            "什么是字符编码？",
            "ASCII 码能够表示哪些字符？有多少个字符？",
            "什么是 EASCII 码？相比 ASCII 码有什么扩展？",
            "GB2312 字符集能够处理多少个汉字？GBK 字符集相比 GB2312 有什么扩展？",
            "Unicode 是什么？它的作用是什么？",
            "Unicode 字符集中包含多少个字符？",
            "UTF-8 编码是什么？它的编码规则是什么？",
            "UTF-8 编码中，长度为 1 字节的字符如何编码？长度为 n 字节的字符如何编码？",
            "为什么在 UTF-8 编码中，其余所有字节的高 2 位都要设置为 10？",
            "UTF-16 编码和 UTF-32 编码分别使用多少个字节来表示一个字符？它们与 UTF-8 编码相比有什么优劣之处？"
          ]
        },
        {
          "content": "## 编程语言的字符编码\n\n对于以往的大多数编程语言，程序运行中的字符串都采用 UTF-16 或 UTF-32 这类等长的编码。在等长编码下，我们可以将字符串看作数组来处理，这种做法具有以下优点。\n\n- **随机访问**: UTF-16 编码的字符串可以很容易地进行随机访问。UTF-8 是一种变长编码，要找到第 $i$ 个字符，我们需要从字符串的开始处遍历到第 $i$ 个字符，这需要 $O(n)$ 的时间。\n- **字符计数**: 与随机访问类似，计算 UTF-16 字符串的长度也是 $O(1)$ 的操作。但是，计算 UTF-8 编码的字符串的长度需要遍历整个字符串。\n- **字符串操作**: 在 UTF-16 编码的字符串中，很多字符串操作（如分割、连接、插入、删除等）都更容易进行。在 UTF-8 编码的字符串上进行这些操作通常需要额外的计算，以确保不会产生无效的 UTF-8 编码。\n\n实际上，编程语言的字符编码方案设计是一个很有趣的话题，其涉及到许多因素。\n\n- Java 的 `String` 类型使用 UTF-16 编码，每个字符占用 2 字节。这是因为 Java 语言设计之初，人们认为 16 位足以表示所有可能的字符。然而，这是一个不正确的判断。后来 Unicode 规范扩展到了超过 16 位，所以 Java 中的字符现在可能由一对 16 位的值（称为“代理对”）表示。\n- JavaScript 和 TypeScript 的字符串使用 UTF-16 编码的原因与 Java 类似。当 JavaScript 语言在 1995 年被 Netscape 公司首次引入时，Unicode 还处于相对早期的阶段，那时候使用 16 位的编码就足够表示所有的 Unicode 字符了。\n- C# 使用 UTF-16 编码，主要因为 .NET 平台是由 Microsoft 设计的，而 Microsoft 的很多技术，包括 Windows 操作系统，都广泛地使用 UTF-16 编码。\n\n由于以上编程语言对字符数量的低估，它们不得不采取“代理对”的方式来表示超过 16 位长度的 Unicode 字符。这是一个不得已为之的无奈之举。一方面，包含代理对的字符串中，一个字符可能占用 2 字节或 4 字节，从而丧失了等长编码的优势。另一方面，处理代理对需要增加额外代码，这增加了编程的复杂性和 Debug 难度。\n\n出于以上原因，部分编程语言提出了一些不同的编码方案。\n\n- Python 中的 `str` 使用 Unicode 编码，并采用一种灵活的字符串表示，存储的字符长度取决于字符串中最大的 Unicode 码点。若字符串中全部是 ASCII 字符，则每个字符占用 1 个字节；如果有字符超出了 ASCII 范围，但全部在基本多语言平面（BMP）内，则每个字符占用 2 个字节；如果有超出 BMP 的字符，则每个字符占用 4 个字节。\n- Go 语言的 `string` 类型在内部使用 UTF-8 编码。Go 语言还提供了 `rune` 类型，它用于表示单个 Unicode 码点。\n- Rust 语言的 str 和 String 类型在内部使用 UTF-8 编码。Rust 也提供了 `char` 类型，用于表示单个 Unicode 码点。\n\n需要注意的是，以上讨论的都是字符串在编程语言中的存储方式，**这和字符串如何在文件中存储或在网络中传输是两个不同的问题**。在文件存储或网络传输中，我们通常会将字符串编码为 UTF-8 格式，以达到最优的兼容性和空间效率。",
          "questions": [
            "什么是等长编码？有哪些编程语言采用等长编码？",
            "为什么在 UTF-8 编码的字符串上进行字符串操作需要额外的计算？",
            "Java 中的 `String` 类型为什么使用 UTF-16 编码？它可能由一对什么值表示？",
            "JavaScript 和 TypeScript 的字符串为什么使用 UTF-16 编码？",
            "C# 为什么使用 UTF-16 编码？",
            "Python 中的 `str` 类型采用什么编码方式？它的存储方式与 ASCII 字符、BMP 字符和超出 BMP 的字符有什么不同？",
            "Go 语言的 `string` 类型采用什么编码方式？它提供了哪种类型用于表示单个 Unicode 码点？",
            "Rust 语言的 `str` 和 `String` 类型采用什么编码方式？它提供了哪种类型用于表示单个 Unicode 码点？",
            "字符串在编程语言中的存储方式和字符串在文件存储或网络传输中的编码方式有什么不同？",
            "在文件存储或网络传输中，为什么通常会将字符串编码为 UTF-8 格式？"
          ]
        }
      ]
    },
    {
      "file_name": "counting_sort.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 计数排序\n\n「计数排序 counting sort」通过统计元素数量来实现排序，通常应用于整数数组。\n\n## 简单实现\n\n先来看一个简单的例子。给定一个长度为 $n$ 的数组 `nums` ，其中的元素都是“非负整数”，计数排序的整体流程如下图所示。\n\n1. 遍历数组，找出数组中的最大数字，记为 $m$ ，然后创建一个长度为 $m + 1$ 的辅助数组 `counter` 。\n2. **借助 `counter` 统计 `nums` 中各数字的出现次数**，其中 `counter[num]` 对应数字 `num` 的出现次数。统计方法很简单，只需遍历 `nums`（设当前数字为 `num`），每轮将 `counter[num]` 增加 $1$ 即可。\n3. **由于 `counter` 的各个索引天然有序，因此相当于所有数字已经被排序好了**。接下来，我们遍历 `counter` ，根据各数字的出现次数，将它们按从小到大的顺序填入 `nums` 即可。\n\n![计数排序流程](counting_sort.assets/counting_sort_overview.png)\n\n```src\n[file]{counting_sort}-[class]{}-[func]{counting_sort_naive}\n```\n\n!!! note \"计数排序与桶排序的联系\"\n\n    从桶排序的角度看，我们可以将计数排序中的计数数组 `counter` 的每个索引视为一个桶，将统计数量的过程看作是将各个元素分配到对应的桶中。本质上，计数排序是桶排序在整型数据下的一个特例。\n\n## 完整实现\n\n细心的同学可能发现，**如果输入数据是对象，上述步骤 `3.` 就失效了**。假设输入数据是商品对象，我们想要按照商品价格（类的成员变量）对商品进行排序，而上述算法只能给出价格的排序结果。\n\n那么如何才能得到原数据的排序结果呢？我们首先计算 `counter` 的“前缀和”。顾名思义，索引 `i` 处的前缀和 `prefix[i]` 等于数组前 `i` 个元素之和：\n\n$$\n\\text{prefix}[i] = \\sum_{j=0}^i \\text{counter[j]}\n$$\n\n**前缀和具有明确的意义，`prefix[num] - 1` 代表元素 `num` 在结果数组 `res` 中最后一次出现的索引**。这个信息非常关键，因为它告诉我们各个元素应该出现在结果数组的哪个位置。接下来，我们倒序遍历原数组 `nums` 的每个元素 `num` ，在每轮迭代中执行以下两步。\n\n1. 将 `num` 填入数组 `res` 的索引 `prefix[num] - 1` 处。\n2. 令前缀和 `prefix[num]` 减小 $1$ ，从而得到下次放置 `num` 的索引。\n\n遍历完成后，数组 `res` 中就是排序好的结果，最后使用 `res` 覆盖原数组 `nums` 即可。下图展示了完整的计数排序流程。\n\n=== \"<1>\"\n    ![计数排序步骤](counting_sort.assets/counting_sort_step1.png)\n\n=== \"<2>\"\n    ![counting_sort_step2](counting_sort.assets/counting_sort_step2.png)\n\n=== \"<3>\"\n    ![counting_sort_step3](counting_sort.assets/counting_sort_step3.png)\n\n=== \"<4>\"\n    ![counting_sort_step4](counting_sort.assets/counting_sort_step4.png)\n\n=== \"<5>\"\n    ![counting_sort_step5](counting_sort.assets/counting_sort_step5.png)\n\n=== \"<6>\"\n    ![counting_sort_step6](counting_sort.assets/counting_sort_step6.png)\n\n=== \"<7>\"\n    ![counting_sort_step7](counting_sort.assets/counting_sort_step7.png)\n\n=== \"<8>\"\n    ![counting_sort_step8](counting_sort.assets/counting_sort_step8.png)\n\n计数排序的实现代码如下所示。\n\n```src\n[file]{counting_sort}-[class]{}-[func]{counting_sort}\n```\n\n## 算法特性\n\n- **时间复杂度 $O(n + m)$** ：涉及遍历 `nums` 和遍历 `counter` ，都使用线性时间。一般情况下 $n \\gg m$ ，时间复杂度趋于 $O(n)$ 。\n- **空间复杂度 $O(n + m)$、非原地排序**：借助了长度分别为 $n$ 和 $m$ 的数组 `res` 和 `counter` 。\n- **稳定排序**：由于向 `res` 中填充元素的顺序是“从右向左”的，因此倒序遍历 `nums` 可以避免改变相等元素之间的相对位置，从而实现稳定排序。实际上，正序遍历 `nums` 也可以得到正确的排序结果，但结果是非稳定的。\n\n## 局限性\n\n看到这里，你也许会觉得计数排序非常巧妙，仅通过统计数量就可以实现高效的排序工作。然而，使用计数排序的前置条件相对较为严格。\n\n**计数排序只适用于非负整数**。若想要将其用于其他类型的数据，需要确保这些数据可以被转换为非负整数，并且在转换过程中不能改变各个元素之间的相对大小关系。例如，对于包含负数的整数数组，可以先给所有数字加上一个常数，将全部数字转化为正数，排序完成后再转换回去即可。\n\n**计数排序适用于数据量大但数据范围较小的情况**。比如，在上述示例中 $m$ 不能太大，否则会占用过多空间。而当 $n \\ll m$ 时，计数排序使用 $O(m)$ 时间，可能比 $O(n \\log n)$ 的排序算法还要慢。",
          "questions": [
            "计数排序只适用于非负整数，如何将其用于包含负数的整数数组？",
            "计数排序的时间复杂度是多少？为什么？",
            "计数排序的空间复杂度是多少？为什么？",
            "计数排序是稳定排序还是非稳定排序？为什么？",
            "计数排序适用于数据量大但数据范围较小的情况，为什么？",
            "计数排序的前置条件是什么？",
            "计数排序的流程是怎样的？",
            "计数排序与桶排序有什么联系？",
            "计数排序的完整实现中，如何得到原数据的排序结果？",
            "计数排序的简单实现中，如何统计nums中各数字的出现次数？"
          ]
        }
      ]
    },
    {
      "file_name": "time_complexity.md",
      "question_count": 60,
      "documents": [
        {
          "content": "# 时间复杂度\n\n运行时间可以直观且准确地反映算法的效率。如果我们想要准确预估一段代码的运行时间，应该如何操作呢？\n\n1. **确定运行平台**，包括硬件配置、编程语言、系统环境等，这些因素都会影响代码的运行效率。\n2. **评估各种计算操作所需的运行时间**，例如加法操作 `+` 需要 1 ns ，乘法操作 `*` 需要 10 ns ，打印操作 `print()` 需要 5 ns 等。\n3. **统计代码中所有的计算操作**，并将所有操作的执行时间求和，从而得到运行时间。\n\n例如在以下代码中，输入数据大小为 $n$ ：\n\n=== \"Python\"\n\n    ```python title=\"\"\n    # 在某运行平台下\n    def algorithm(n: int):\n        a = 2      # 1 ns\n        a = a + 1  # 1 ns\n        a = a * 2  # 10 ns\n        # 循环 n 次\n        for _ in range(n):  # 1 ns\n            print(0)        # 5 ns\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"\"\n    // 在某运行平台下\n    void algorithm(int n) {\n        int a = 2;  // 1 ns\n        a = a + 1;  // 1 ns\n        a = a * 2;  // 10 ns\n        // 循环 n 次\n        for (int i = 0; i < n; i++) {  // 1 ns ，每轮都要执行 i++\n            cout << 0 << endl;         // 5 ns\n        }\n    }\n    ```\n\n=== \"Java\"\n\n    ```java title=\"\"\n    // 在某运行平台下\n    void algorithm(int n) {\n        int a = 2;  // 1 ns\n        a = a + 1;  // 1 ns\n        a = a * 2;  // 10 ns\n        // 循环 n 次\n        for (int i = 0; i < n; i++) {  // 1 ns ，每轮都要执行 i++\n            System.out.println(0);     // 5 ns\n        }\n    }\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"\"\n    // 在某运行平台下\n    void Algorithm(int n) {\n        int a = 2;  // 1 ns\n        a = a + 1;  // 1 ns\n        a = a * 2;  // 10 ns\n        // 循环 n 次\n        for (int i = 0; i < n; i++) {  // 1 ns ，每轮都要执行 i++\n            Console.WriteLine(0);      // 5 ns\n        }\n    }\n    ```\n\n=== \"Go\"\n\n    ```go title=\"\"\n    // 在某运行平台下\n    func algorithm(n int) {\n        a := 2     // 1 ns\n        a = a + 1  // 1 ns\n        a = a * 2  // 10 ns\n        // 循环 n 次\n        for i := 0; i < n; i++ {  // 1 ns\n            fmt.Println(a)        // 5 ns\n        }\n    }\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"\"\n    // 在某运行平台下\n    func algorithm(n: Int) {\n        var a = 2 // 1 ns\n        a = a + 1 // 1 ns\n        a = a * 2 // 10 ns\n        // 循环 n 次\n        for _ in 0 ..< n { // 1 ns\n            print(0) // 5 ns\n        }\n    }\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"\"\n    // 在某运行平台下\n    function algorithm(n) {\n        var a = 2; // 1 ns\n        a = a + 1; // 1 ns\n        a = a * 2; // 10 ns\n        // 循环 n 次\n        for(let i = 0; i < n; i++) { // 1 ns ，每轮都要执行 i++\n            console.log(0); // 5 ns\n        }\n    }\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"\"\n    // 在某运行平台下\n    function algorithm(n: number): void {\n        var a: number = 2; // 1 ns\n        a = a + 1; // 1 ns\n        a = a * 2; // 10 ns\n        // 循环 n 次\n        for(let i = 0; i < n; i++) { // 1 ns ，每轮都要执行 i++\n            console.log(0); // 5 ns\n        }\n    }\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"\"\n    // 在某运行平台下\n    void algorithm(int n) {\n      int a = 2; // 1 ns\n      a = a + 1; // 1 ns\n      a = a * 2; // 10 ns\n      // 循环 n 次\n      for (int i = 0; i < n; i++) { // 1 ns ，每轮都要执行 i++\n        print(0); // 5 ns\n      }\n    }\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"\"\n    // 在某运行平台下\n    fn algorithm(n: i32) {\n        let mut a = 2;      // 1 ns\n        a = a + 1;          // 1 ns\n        a = a * 2;          // 10 ns\n        // 循环 n 次\n        for _ in 0..n {     // 1 ns ，每轮都要执行 i++\n            println!(\"{}\", 0);  // 5 ns\n        }\n    }\n    ```\n\n=== \"C\"\n\n    ```c title=\"\"\n    // 在某运行平台下\n    void algorithm(int n) {\n        int a = 2;  // 1 ns\n        a = a + 1;  // 1 ns\n        a = a * 2;  // 10 ns\n        // 循环 n 次\n        for (int i = 0; i < n; i++) {   // 1 ns ，每轮都要执行 i++\n            printf(\"%d\", 0);            // 5 ns\n        }\n    }\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"\"\n\n    ```\n\n根据以上方法，可以得到算法运行时间为 $6n + 12$ ns ：\n\n$$\n1 + 1 + 10 + (1 + 5) \\times n = 6n + 12\n$$\n\n但实际上，**统计算法的运行时间既不合理也不现实**。首先，我们不希望将预估时间和运行平台绑定，因为算法需要在各种不同的平台上运行。其次，我们很难获知每种操作的运行时间，这给预估过程带来了极大的难度。",
          "questions": [
            "如何确定算法的运行时间？",
            "运行平台对算法的运行效率有哪些影响？",
            "如何评估各种计算操作所需的运行时间？",
            "如何统计代码中所有的计算操作的执行时间？",
            "为什么统计算法的运行时间既不合理也不现实？",
            "为什么不希望将预估时间和运行平台绑定？",
            "为什么很难获知每种操作的运行时间？",
            "在代码中，哪些操作需要计算执行时间？",
            "在不同编程语言中，如何计算相同操作的执行时间？",
            "为什么需要预估算法的运行时间？"
          ]
        },
        {
          "content": "## 统计时间增长趋势\n\n时间复杂度分析统计的不是算法运行时间，**而是算法运行时间随着数据量变大时的增长趋势**。\n\n“时间增长趋势”这个概念比较抽象，我们通过一个例子来加以理解。假设输入数据大小为 $n$ ，给定三个算法函数 `A`、`B` 和 `C` ：\n\n=== \"Python\"\n\n    ```python title=\"\"\n    # 算法 A 的时间复杂度：常数阶\n    def algorithm_A(n: int):\n        print(0)\n    # 算法 B 的时间复杂度：线性阶\n    def algorithm_B(n: int):\n        for _ in range(n):\n            print(0)\n    # 算法 C 的时间复杂度：常数阶\n    def algorithm_C(n: int):\n        for _ in range(1000000):\n            print(0)\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"\"\n    // 算法 A 的时间复杂度：常数阶\n    void algorithm_A(int n) {\n        cout << 0 << endl;\n    }\n    // 算法 B 的时间复杂度：线性阶\n    void algorithm_B(int n) {\n        for (int i = 0; i < n; i++) {\n            cout << 0 << endl;\n        }\n    }\n    // 算法 C 的时间复杂度：常数阶\n    void algorithm_C(int n) {\n        for (int i = 0; i < 1000000; i++) {\n            cout << 0 << endl;\n        }\n    }\n    ```\n\n=== \"Java\"\n\n    ```java title=\"\"\n    // 算法 A 的时间复杂度：常数阶\n    void algorithm_A(int n) {\n        System.out.println(0);\n    }\n    // 算法 B 的时间复杂度：线性阶\n    void algorithm_B(int n) {\n        for (int i = 0; i < n; i++) {\n            System.out.println(0);\n        }\n    }\n    // 算法 C 的时间复杂度：常数阶\n    void algorithm_C(int n) {\n        for (int i = 0; i < 1000000; i++) {\n            System.out.println(0);\n        }\n    }\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"\"\n    // 算法 A 的时间复杂度：常数阶\n    void AlgorithmA(int n) {\n        Console.WriteLine(0);\n    }\n    // 算法 B 的时间复杂度：线性阶\n    void AlgorithmB(int n) {\n        for (int i = 0; i < n; i++) {\n            Console.WriteLine(0);\n        }\n    }\n    // 算法 C 的时间复杂度：常数阶\n    void AlgorithmC(int n) {\n        for (int i = 0; i < 1000000; i++) {\n            Console.WriteLine(0);\n        }\n    }\n    ```\n\n=== \"Go\"\n\n    ```go title=\"\"\n    // 算法 A 的时间复杂度：常数阶\n    func algorithm_A(n int) {\n        fmt.Println(0)\n    }\n    // 算法 B 的时间复杂度：线性阶\n    func algorithm_B(n int) {\n        for i := 0; i < n; i++ {\n            fmt.Println(0)\n        }\n    }\n    // 算法 C 的时间复杂度：常数阶\n    func algorithm_C(n int) {\n        for i := 0; i < 1000000; i++ {\n            fmt.Println(0)\n        }\n    }\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"\"\n    // 算法 A 的时间复杂度：常数阶\n    func algorithmA(n: Int) {\n        print(0)\n    }\n\n    // 算法 B 的时间复杂度：线性阶\n    func algorithmB(n: Int) {\n        for _ in 0 ..< n {\n            print(0)\n        }\n    }\n\n    // 算法 C 的时间复杂度：常数阶\n    func algorithmC(n: Int) {\n        for _ in 0 ..< 1000000 {\n            print(0)\n        }\n    }\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"\"\n    // 算法 A 的时间复杂度：常数阶\n    function algorithm_A(n) {\n        console.log(0);\n    }\n    // 算法 B 的时间复杂度：线性阶\n    function algorithm_B(n) {\n        for (let i = 0; i < n; i++) {\n            console.log(0);\n        }\n    }\n    // 算法 C 的时间复杂度：常数阶\n    function algorithm_C(n) {\n        for (let i = 0; i < 1000000; i++) {\n            console.log(0);\n        }\n    }\n\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"\"\n    // 算法 A 的时间复杂度：常数阶\n    function algorithm_A(n: number): void {\n        console.log(0);\n    }\n    // 算法 B 的时间复杂度：线性阶\n    function algorithm_B(n: number): void {\n        for (let i = 0; i < n; i++) {\n            console.log(0);\n        }\n    }\n    // 算法 C 的时间复杂度：常数阶\n    function algorithm_C(n: number): void {\n        for (let i = 0; i < 1000000; i++) {\n            console.log(0);\n        }\n    }\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"\"\n    // 算法 A 的时间复杂度：常数阶\n    void algorithmA(int n) {\n      print(0);\n    }\n    // 算法 B 的时间复杂度：线性阶\n    void algorithmB(int n) {\n      for (int i = 0; i < n; i++) {\n        print(0);\n      }\n    }\n    // 算法 C 的时间复杂度：常数阶\n    void algorithmC(int n) {\n      for (int i = 0; i < 1000000; i++) {\n        print(0);\n      }\n    }\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"\"\n    // 算法 A 的时间复杂度：常数阶\n    fn algorithm_A(n: i32) {\n        println!(\"{}\", 0);\n    }\n    // 算法 B 的时间复杂度：线性阶\n    fn algorithm_B(n: i32) {\n        for _ in 0..n {\n            println!(\"{}\", 0);\n        }\n    }\n    // 算法 C 的时间复杂度：常数阶\n    fn algorithm_C(n: i32) {\n        for _ in 0..1000000 {\n            println!(\"{}\", 0);\n        }\n    }\n    ```\n\n=== \"C\"\n\n    ```c title=\"\"\n    // 算法 A 的时间复杂度：常数阶\n    void algorithm_A(int n) {\n        printf(\"%d\", 0);\n    }\n    // 算法 B 的时间复杂度：线性阶\n    void algorithm_B(int n) {\n        for (int i = 0; i < n; i++) {\n            printf(\"%d\", 0);\n        }\n    }\n    // 算法 C 的时间复杂度：常数阶\n    void algorithm_C(int n) {\n        for (int i = 0; i < 1000000; i++) {\n            printf(\"%d\", 0);\n        }\n    }\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"\"\n\n    ```\n\n下图展示了以上三个算法函数的时间复杂度。\n\n- 算法 `A` 只有 $1$ 个打印操作，算法运行时间不随着 $n$ 增大而增长。我们称此算法的时间复杂度为“常数阶”。\n- 算法 `B` 中的打印操作需要循环 $n$ 次，算法运行时间随着 $n$ 增大呈线性增长。此算法的时间复杂度被称为“线性阶”。\n- 算法 `C` 中的打印操作需要循环 $1000000$ 次，虽然运行时间很长，但它与输入数据大小 $n$ 无关。因此 `C` 的时间复杂度和 `A` 相同，仍为“常数阶”。\n\n![算法 A、B 和 C 的时间增长趋势](time_complexity.assets/time_complexity_simple_example.png)\n\n相较于直接统计算法运行时间，时间复杂度分析有哪些特点呢？\n\n- **时间复杂度能够有效评估算法效率**。例如，算法 `B` 的运行时间呈线性增长，在 $n > 1$ 时比算法 `A` 更慢，在 $n > 1000000$ 时比算法 `C` 更慢。事实上，只要输入数据大小 $n$ 足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法，这正是时间增长趋势所表达的含义。\n- **时间复杂度的推算方法更简便**。显然，运行平台和计算操作类型都与算法运行时间的增长趋势无关。因此在时间复杂度分析中，我们可以简单地将所有计算操作的执行时间视为相同的“单位时间”，从而将“计算操作的运行时间的统计”简化为“计算操作的数量的统计”，这样一来估算难度就大大降低了。\n- **时间复杂度也存在一定的局限性**。例如，尽管算法 `A` 和 `C` 的时间复杂度相同，但实际运行时间差别很大。同样，尽管算法 `B` 的时间复杂度比 `C` 高，但在输入数据大小 $n$ 较小时，算法 `B` 明显优于算法 `C` 。在这些情况下，我们很难仅凭时间复杂度判断算法效率的高低。当然，尽管存在上述问题，复杂度分析仍然是评判算法效率最有效且常用的方法。",
          "questions": [
            "时间复杂度分析统计的是什么？",
            "什么是时间增长趋势？",
            "通过什么来加以理解时间增长趋势？",
            "什么是常数阶？",
            "什么是线性阶？",
            "为什么时间复杂度能够有效评估算法效率？",
            "时间复杂度的推算方法有什么优点？",
            "时间复杂度存在哪些局限性？",
            "为什么在时间复杂度分析中，我们可以将所有计算操作的执行时间视为相同的“单位时间”？",
            "在什么情况下，我们很难仅凭时间复杂度判断算法效率的高低？"
          ]
        },
        {
          "content": "## 函数渐近上界\n\n给定一个输入大小为 $n$ 的函数：\n\n=== \"Python\"\n\n    ```python title=\"\"\n    def algorithm(n: int):\n        a = 1      # +1\n        a = a + 1  # +1\n        a = a * 2  # +1\n        # 循环 n 次\n        for i in range(n):  # +1\n            print(0)        # +1\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"\"\n    void algorithm(int n) {\n        int a = 1;  // +1\n        a = a + 1;  // +1\n        a = a * 2;  // +1\n        // 循环 n 次\n        for (int i = 0; i < n; i++) { // +1（每轮都执行 i ++）\n            cout << 0 << endl;    // +1\n        }\n    }\n    ```\n\n=== \"Java\"\n\n    ```java title=\"\"\n    void algorithm(int n) {\n        int a = 1;  // +1\n        a = a + 1;  // +1\n        a = a * 2;  // +1\n        // 循环 n 次\n        for (int i = 0; i < n; i++) { // +1（每轮都执行 i ++）\n            System.out.println(0);    // +1\n        }\n    }\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"\"\n    void Algorithm(int n) {\n        int a = 1;  // +1\n        a = a + 1;  // +1\n        a = a * 2;  // +1\n        // 循环 n 次\n        for (int i = 0; i < n; i++) {   // +1（每轮都执行 i ++）\n            Console.WriteLine(0);   // +1\n        }\n    }\n    ```\n\n=== \"Go\"\n\n    ```go title=\"\"\n    func algorithm(n int) {\n        a := 1      // +1\n        a = a + 1   // +1\n        a = a * 2   // +1\n        // 循环 n 次\n        for i := 0; i < n; i++ {   // +1\n            fmt.Println(a)         // +1\n        }\n    }\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"\"\n    func algorithm(n: Int) {\n        var a = 1 // +1\n        a = a + 1 // +1\n        a = a * 2 // +1\n        // 循环 n 次\n        for _ in 0 ..< n { // +1\n            print(0) // +1\n        }\n    }\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"\"\n    function algorithm(n) {\n        var a = 1; // +1\n        a += 1; // +1\n        a *= 2; // +1\n        // 循环 n 次\n        for(let i = 0; i < n; i++){ // +1（每轮都执行 i ++）\n            console.log(0); // +1\n        }\n    }\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"\"\n    function algorithm(n: number): void{\n        var a: number = 1; // +1\n        a += 1; // +1\n        a *= 2; // +1\n        // 循环 n 次\n        for(let i = 0; i < n; i++){ // +1（每轮都执行 i ++）\n            console.log(0); // +1\n        }\n    }\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"\"\n    void algorithm(int n) {\n      int a = 1; // +1\n      a = a + 1; // +1\n      a = a * 2; // +1\n      // 循环 n 次\n      for (int i = 0; i < n; i++) { // +1（每轮都执行 i ++）\n        print(0); // +1\n      }\n    }\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"\"\n    fn algorithm(n: i32) {\n        let mut a = 1;   // +1\n        a = a + 1;      // +1\n        a = a * 2;      // +1\n\n        // 循环 n 次\n        for _ in 0..n { // +1（每轮都执行 i ++）\n            println!(\"{}\", 0); // +1\n        }\n    }\n    ```\n\n=== \"C\"\n\n    ```c title=\"\"\n    void algorithm(int n) {\n        int a = 1;  // +1\n        a = a + 1;  // +1\n        a = a * 2;  // +1\n        // 循环 n 次\n        for (int i = 0; i < n; i++) {   // +1（每轮都执行 i ++）\n            printf(\"%d\", 0);            // +1\n        }\n    }  \n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"\"\n\n    ```\n\n设算法的操作数量是一个关于输入数据大小 $n$ 的函数，记为 $T(n)$ ，则以上函数的的操作数量为：\n\n$$\nT(n) = 3 + 2n\n$$\n\n$T(n)$ 是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶。\n\n我们将线性阶的时间复杂度记为 $O(n)$ ，这个数学符号称为「大 $O$ 记号 big-$O$ notation」，表示函数 $T(n)$ 的「渐近上界 asymptotic upper bound」。\n\n时间复杂度分析本质上是计算“操作数量函数 $T(n)$”的渐近上界，其具有明确的数学定义。\n\n!!! abstract \"函数渐近上界\"\n\n    若存在正实数 $c$ 和实数 $n_0$ ，使得对于所有的 $n > n_0$ ，均有 $T(n) \\leq c \\cdot f(n)$ ，则可认为 $f(n)$ 给出了 $T(n)$ 的一个渐近上界，记为 $T(n) = O(f(n))$ 。\n\n如下图所示，计算渐近上界就是寻找一个函数 $f(n)$ ，使得当 $n$ 趋向于无穷大时，$T(n)$ 和 $f(n)$ 处于相同的增长级别，仅相差一个常数项 $c$ 的倍数。\n\n![函数的渐近上界](time_complexity.assets/asymptotic_upper_bound.png)\n\n## 推算方法\n\n渐近上界的数学味儿有点重，如果你感觉没有完全理解，也无须担心。因为在实际使用中，我们只需要掌握推算方法，数学意义就可以逐渐领悟。\n\n根据定义，确定 $f(n)$ 之后，我们便可得到时间复杂度 $O(f(n))$ 。那么如何确定渐近上界 $f(n)$ 呢？总体分为两步：首先统计操作数量，然后判断渐近上界。",
          "questions": [
            "什么是渐近上界？",
            "如何计算一个算法的操作数量？",
            "什么是时间复杂度？",
            "什么是大 O 记号？",
            "如何判断一个函数的渐近上界？",
            "以上给出的函数的时间复杂度是什么？",
            "为什么以上函数的时间复杂度是线性阶？",
            "什么是渐近上界的数学定义？",
            "如何确定一个算法的渐近上界？",
            "渐近上界和时间复杂度有什么关系？"
          ]
        },
        {
          "content": "### 第一步：统计操作数量\n\n针对代码，逐行从上到下计算即可。然而，由于上述 $c \\cdot f(n)$ 中的常数项 $c$ 可以取任意大小，**因此操作数量 $T(n)$ 中的各种系数、常数项都可以被忽略**。根据此原则，可以总结出以下计数简化技巧。\n\n1. **忽略 $T(n)$ 中的常数项**。因为它们都与 $n$ 无关，所以对时间复杂度不产生影响。\n2. **省略所有系数**。例如，循环 $2n$ 次、$5n + 1$ 次等，都可以简化记为 $n$ 次，因为 $n$ 前面的系数对时间复杂度没有影响。\n3. **循环嵌套时使用乘法**。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用第 `1.` 点和第 `2.` 点的技巧。\n\n给定一个函数，我们可以用上述技巧来统计操作数量。\n\n=== \"Python\"\n\n    ```python title=\"\"\n    def algorithm(n: int):\n        a = 1      # +0（技巧 1）\n        a = a + n  # +0（技巧 1）\n        # +n（技巧 2）\n        for i in range(5 * n + 1):\n            print(0)\n        # +n*n（技巧 3）\n        for i in range(2 * n):\n            for j in range(n + 1):\n                print(0)\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"\"\n    void algorithm(int n) {\n        int a = 1;  // +0（技巧 1）\n        a = a + n;  // +0（技巧 1）\n        // +n（技巧 2）\n        for (int i = 0; i < 5 * n + 1; i++) {\n            cout << 0 << endl;\n        }\n        // +n*n（技巧 3）\n        for (int i = 0; i < 2 * n; i++) {\n            for (int j = 0; j < n + 1; j++) {\n                cout << 0 << endl;\n            }\n        }\n    }\n    ```\n\n=== \"Java\"\n\n    ```java title=\"\"\n    void algorithm(int n) {\n        int a = 1;  // +0（技巧 1）\n        a = a + n;  // +0（技巧 1）\n        // +n（技巧 2）\n        for (int i = 0; i < 5 * n + 1; i++) {\n            System.out.println(0);\n        }\n        // +n*n（技巧 3）\n        for (int i = 0; i < 2 * n; i++) {\n            for (int j = 0; j < n + 1; j++) {\n                System.out.println(0);\n            }\n        }\n    }\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"\"\n    void Algorithm(int n) {\n        int a = 1;  // +0（技巧 1）\n        a = a + n;  // +0（技巧 1）\n        // +n（技巧 2）\n        for (int i = 0; i < 5 * n + 1; i++) {\n            Console.WriteLine(0);\n        }\n        // +n*n（技巧 3）\n        for (int i = 0; i < 2 * n; i++) {\n            for (int j = 0; j < n + 1; j++) {\n                Console.WriteLine(0);\n            }\n        }\n    }\n    ```\n\n=== \"Go\"\n\n    ```go title=\"\"\n    func algorithm(n int) {\n        a := 1     // +0（技巧 1）\n        a = a + n  // +0（技巧 1）\n        // +n（技巧 2）\n        for i := 0; i < 5 * n + 1; i++ {\n            fmt.Println(0)\n        }\n        // +n*n（技巧 3）\n        for i := 0; i < 2 * n; i++ {\n            for j := 0; j < n + 1; j++ {\n                fmt.Println(0)\n            }\n        }\n    }\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"\"\n    func algorithm(n: Int) {\n        var a = 1 // +0（技巧 1）\n        a = a + n // +0（技巧 1）\n        // +n（技巧 2）\n        for _ in 0 ..< (5 * n + 1) {\n            print(0)\n        }\n        // +n*n（技巧 3）\n        for _ in 0 ..< (2 * n) {\n            for _ in 0 ..< (n + 1) {\n                print(0)\n            }\n        }\n    }\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"\"\n    function algorithm(n) {\n        let a = 1;  // +0（技巧 1）\n        a = a + n;  // +0（技巧 1）\n        // +n（技巧 2）\n        for (let i = 0; i < 5 * n + 1; i++) {\n            console.log(0);\n        }\n        // +n*n（技巧 3）\n        for (let i = 0; i < 2 * n; i++) {\n            for (let j = 0; j < n + 1; j++) {\n                console.log(0);\n            }\n        }\n    }\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"\"\n    function algorithm(n: number): void {\n        let a = 1;  // +0（技巧 1）\n        a = a + n;  // +0（技巧 1）\n        // +n（技巧 2）\n        for (let i = 0; i < 5 * n + 1; i++) {\n            console.log(0);\n        }\n        // +n*n（技巧 3）\n        for (let i = 0; i < 2 * n; i++) {\n            for (let j = 0; j < n + 1; j++) {\n                console.log(0);\n            }\n        }\n    }\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"\"\n    void algorithm(int n) {\n      int a = 1; // +0（技巧 1）\n      a = a + n; // +0（技巧 1）\n      // +n（技巧 2）\n      for (int i = 0; i < 5 * n + 1; i++) {\n        print(0);\n      }\n      // +n*n（技巧 3）\n      for (int i = 0; i < 2 * n; i++) {\n        for (int j = 0; j < n + 1; j++) {\n          print(0);\n        }\n      }\n    }\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"\"\n    fn algorithm(n: i32) {\n        let mut a = 1;     // +0（技巧 1）\n        a = a + n;        // +0（技巧 1）\n\n        // +n（技巧 2）\n        for i in 0..(5 * n + 1) {\n            println!(\"{}\", 0);\n        }\n\n        // +n*n（技巧 3）\n        for i in 0..(2 * n) {\n            for j in 0..(n + 1) {\n                println!(\"{}\", 0);\n            }\n        }\n    }\n    ```\n\n=== \"C\"\n\n    ```c title=\"\"\n    void algorithm(int n) {\n        int a = 1;  // +0（技巧 1）\n        a = a + n;  // +0（技巧 1）\n        // +n（技巧 2）\n        for (int i = 0; i < 5 * n + 1; i++) {\n            printf(\"%d\", 0);\n        }\n        // +n*n（技巧 3）\n        for (int i = 0; i < 2 * n; i++) {\n            for (int j = 0; j < n + 1; j++) {\n                printf(\"%d\", 0);\n            }\n        }\n    }\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"\"\n\n    ```\n\n以下公式展示了使用上述技巧前后的统计结果，两者推出的时间复杂度都为 $O(n^2)$ 。\n\n$$\n\\begin{aligned}\nT(n) & = 2n(n + 1) + (5n + 1) + 2 & \\text{完整统计 (-.-|||)} \\newline\n& = 2n^2 + 7n + 3 \\newline\nT(n) & = n^2 + n & \\text{偷懒统计 (o.O)}\n\\end{aligned}\n$$\n\n### 第二步：判断渐近上界\n\n**时间复杂度由多项式 $T(n)$ 中最高阶的项来决定**。这是因为在 $n$ 趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以被忽略。\n\n下表展示了一些例子，其中一些夸张的值是为了强调“系数无法撼动阶数”这一结论。当 $n$ 趋于无穷大时，这些常数变得无足轻重。\n\n<p align=\"center\"> 表 <id> &nbsp; 不同操作数量对应的时间复杂度 </p>\n\n| 操作数量 $T(n)$        | 时间复杂度 $O(f(n))$ |\n| ---------------------- | -------------------- |\n| $100000$               | $O(1)$               |\n| $3n + 2$               | $O(n)$               |\n| $2n^2 + 3n + 2$        | $O(n^2)$             |\n| $n^3 + 10000n^2$       | $O(n^3)$             |\n| $2^n + 10000n^{10000}$ | $O(2^n)$             |\n\n## 常见类型\n\n设输入数据大小为 $n$ ，常见的时间复杂度类型如下图所示（按照从低到高的顺序排列）。\n\n$$\n\\begin{aligned}\nO(1) < O(\\log n) < O(n) < O(n \\log n) < O(n^2) < O(2^n) < O(n!) \\newline\n\\text{常数阶} < \\text{对数阶} < \\text{线性阶} < \\text{线性对数阶} < \\text{平方阶} < \\text{指数阶} < \\text{阶乘阶}\n\\end{aligned}\n$$\n\n![常见的时间复杂度类型](time_complexity.assets/time_complexity_common_types.png)",
          "questions": [
            "什么是时间复杂度？",
            "时间复杂度的计算方法有哪些？",
            "在计算时间复杂度时，可以忽略哪些因素？",
            "什么是常数项？在计算时间复杂度时，常数项可以忽略吗？",
            "什么是系数？在计算时间复杂度时，系数可以忽略吗？",
            "循环嵌套时，如何计算时间复杂度？",
            "时间复杂度的大小与什么有关？",
            "时间复杂度的大小与输入数据的大小有什么关系？",
            "常见的时间复杂度类型有哪些？它们的大小关系是怎样的？",
            "如何判断一个算法的时间复杂度是否优秀？"
          ]
        },
        {
          "content": "### 常数阶 $O(1)$\n\n常数阶的操作数量与输入数据大小 $n$ 无关，即不随着 $n$ 的变化而变化。\n\n在以下函数中，尽管操作数量 `size` 可能很大，但由于其与输入数据大小 $n$ 无关，因此时间复杂度仍为 $O(1)$ ：\n\n```src\n[file]{time_complexity}-[class]{}-[func]{constant}\n```\n\n### 线性阶 $O(n)$\n\n线性阶的操作数量相对于输入数据大小 $n$ 以线性级别增长。线性阶通常出现在单层循环中：\n\n```src\n[file]{time_complexity}-[class]{}-[func]{linear}\n```\n\n遍历数组和遍历链表等操作的时间复杂度均为 $O(n)$ ，其中 $n$ 为数组或链表的长度：\n\n```src\n[file]{time_complexity}-[class]{}-[func]{array_traversal}\n```\n\n值得注意的是，**输入数据大小 $n$ 需根据输入数据的类型来具体确定**。比如在第一个示例中，变量 $n$ 为输入数据大小；在第二个示例中，数组长度 $n$ 为数据大小。\n\n### 平方阶 $O(n^2)$\n\n平方阶的操作数量相对于输入数据大小 $n$ 以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层循环都为 $O(n)$ ，因此总体为 $O(n^2)$ ：\n\n```src\n[file]{time_complexity}-[class]{}-[func]{quadratic}\n```\n\n下图对比了常数阶、线性阶和平方阶三种时间复杂度。\n\n![常数阶、线性阶和平方阶的时间复杂度](time_complexity.assets/time_complexity_constant_linear_quadratic.png)\n\n以冒泡排序为例，外层循环执行 $n - 1$ 次，内层循环执行 $n-1$、$n-2$、$\\dots$、$2$、$1$ 次，平均为 $n / 2$ 次，因此时间复杂度为 $O((n - 1) n / 2) = O(n^2)$ 。\n\n```src\n[file]{time_complexity}-[class]{}-[func]{bubble_sort}\n```\n\n### 指数阶 $O(2^n)$\n\n生物学的“细胞分裂”是指数阶增长的典型例子：初始状态为 $1$ 个细胞，分裂一轮后变为 $2$ 个，分裂两轮后变为 $4$ 个，以此类推，分裂 $n$ 轮后有 $2^n$ 个细胞。\n\n下图和以下代码模拟了细胞分裂的过程，时间复杂度为 $O(2^n)$ 。\n\n```src\n[file]{time_complexity}-[class]{}-[func]{exponential}\n```\n\n![指数阶的时间复杂度](time_complexity.assets/time_complexity_exponential.png)\n\n在实际算法中，指数阶常出现于递归函数中。例如在以下代码中，其递归地一分为二，经过 $n$ 次分裂后停止：\n\n```src\n[file]{time_complexity}-[class]{}-[func]{exp_recur}\n```\n\n指数阶增长非常迅速，在穷举法（暴力搜索、回溯等）中比较常见。对于数据规模较大的问题，指数阶是不可接受的，通常需要使用动态规划或贪心等算法来解决。\n\n### 对数阶 $O(\\log n)$\n\n与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。设输入数据大小为 $n$ ，由于每轮缩减到一半，因此循环次数是 $\\log_2 n$ ，即 $2^n$ 的反函数。\n\n下图和以下代码模拟了“每轮缩减到一半”的过程，时间复杂度为 $O(\\log_2 n)$ ，简记为 $O(\\log n)$ 。\n\n```src\n[file]{time_complexity}-[class]{}-[func]{logarithmic}\n```\n\n![对数阶的时间复杂度](time_complexity.assets/time_complexity_logarithmic.png)\n\n与指数阶类似，对数阶也常出现于递归函数中。以下代码形成了一个高度为 $\\log_2 n$ 的递归树：\n\n```src\n[file]{time_complexity}-[class]{}-[func]{log_recur}\n```\n\n对数阶常出现于基于分治策略的算法中，体现了“一分为多”和“化繁为简”的算法思想。它增长缓慢，是仅次于常数阶的理想的时间复杂度。\n\n!!! tip \"$O(\\log n)$ 的底数是多少？\"\n\n    准确来说，“一分为 $m$”对应的时间复杂度是 $O(\\log_m n)$ 。而通过对数换底公式，我们可以得到具有不同底数的、相等的时间复杂度：\n\n    $$\n    O(\\log_m n) = O(\\log_k n / \\log_k m) = O(\\log_k n)\n    $$\n\n    也就是说，底数 $m$ 可以在不影响复杂度的前提下转换。因此我们通常会省略底数 $m$ ，将对数阶直接记为 $O(\\log n)$ 。\n\n### 线性对数阶 $O(n \\log n)$\n\n线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 $O(\\log n)$ 和 $O(n)$ 。相关代码如下：\n\n```src\n[file]{time_complexity}-[class]{}-[func]{linear_log_recur}\n```\n\n下图展示了线性对数阶的生成方式。二叉树的每一层的操作总数都为 $n$ ，树共有 $\\log_2 n + 1$ 层，因此时间复杂度为 $O(n \\log n)$ 。\n\n![线性对数阶的时间复杂度](time_complexity.assets/time_complexity_logarithmic_linear.png)\n\n主流排序算法的时间复杂度通常为 $O(n \\log n)$ ，例如快速排序、归并排序、堆排序等。\n\n### 阶乘阶 $O(n!)$\n\n阶乘阶对应数学上的“全排列”问题。给定 $n$ 个互不重复的元素，求其所有可能的排列方案，方案数量为：\n\n$$\nn! = n \\times (n - 1) \\times (n - 2) \\times \\dots \\times 2 \\times 1\n$$\n\n阶乘通常使用递归实现。如下图和以下代码所示，第一层分裂出 $n$ 个，第二层分裂出 $n - 1$ 个，以此类推，直至第 $n$ 层时停止分裂：\n\n```src\n[file]{time_complexity}-[class]{}-[func]{factorial_recur}\n```\n\n![阶乘阶的时间复杂度](time_complexity.assets/time_complexity_factorial.png)\n\n请注意，因为当 $n \\geq 4$ 时恒有 $n! > 2^n$ ，所以阶乘阶比指数阶增长得更快，在 $n$ 较大时也是不可接受的。",
          "questions": [
            "常数阶的操作数量与输入数据大小有什么关系？",
            "在什么情况下，尽管操作数量很大，时间复杂度仍为O(1)？",
            "线性阶的操作数量相对于输入数据大小以什么级别增长？",
            "遍历数组和遍历链表等操作的时间复杂度均为什么？",
            "平方阶的操作数量相对于输入数据大小以什么级别增长？",
            "平方阶通常出现在什么样的循环中？",
            "冒泡排序的时间复杂度是多少？",
            "指数阶的操作数量相对于输入数据大小以什么级别增长？",
            "指数阶常出现于什么样的算法中？",
            "对数阶的操作数量相对于输入数据大小以什么级别增长？"
          ]
        },
        {
          "content": "## 最差、最佳、平均时间复杂度\n\n**算法的时间效率往往不是固定的，而是与输入数据的分布有关**。假设输入一个长度为 $n$ 的数组 `nums` ，其中 `nums` 由从 $1$ 至 $n$ 的数字组成，每个数字只出现一次；但元素顺序是随机打乱的，任务目标是返回元素 $1$ 的索引。我们可以得出以下结论。\n\n- 当 `nums = [?, ?, ..., 1]` ，即当末尾元素是 $1$ 时，需要完整遍历数组，**达到最差时间复杂度 $O(n)$** 。\n- 当 `nums = [1, ?, ?, ...]` ，即当首个元素为 $1$ 时，无论数组多长都不需要继续遍历，**达到最佳时间复杂度 $\\Omega(1)$** 。\n\n“最差时间复杂度”对应函数渐近上界，使用大 $O$ 记号表示。相应地，“最佳时间复杂度”对应函数渐近下界，用 $\\Omega$ 记号表示：\n\n```src\n[file]{worst_best_time_complexity}-[class]{}-[func]{find_one}\n```\n\n值得说明的是，我们在实际中很少使用最佳时间复杂度，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。**而最差时间复杂度更为实用，因为它给出了一个效率安全值**，让我们可以放心地使用算法。\n\n从上述示例可以看出，最差或最佳时间复杂度只出现于“特殊的数据分布”，这些情况的出现概率可能很小，并不能真实地反映算法运行效率。相比之下，**平均时间复杂度可以体现算法在随机输入数据下的运行效率**，用 $\\Theta$ 记号来表示。\n\n对于部分算法，我们可以简单地推算出随机数据分布下的平均情况。比如上述示例，由于输入数组是被打乱的，因此元素 $1$ 出现在任意索引的概率都是相等的，那么算法的平均循环次数就是数组长度的一半 $n / 2$ ，平均时间复杂度为 $\\Theta(n / 2) = \\Theta(n)$ 。\n\n但对于较为复杂的算法，计算平均时间复杂度往往是比较困难的，因为很难分析出在数据分布下的整体数学期望。在这种情况下，我们通常使用最差时间复杂度作为算法效率的评判标准。\n\n!!! question \"为什么很少看到 $\\Theta$ 符号？\"\n\n    可能由于 $O$ 符号过于朗朗上口，我们常常使用它来表示平均时间复杂度。但从严格意义上看，这种做法并不规范。在本书和其他资料中，若遇到类似“平均时间复杂度 $O(n)$”的表述，请将其直接理解为 $\\Theta(n)$ 。",
          "questions": [
            "什么是算法的时间效率？",
            "输入数据的分布如何影响算法的时间效率？",
            "什么是最差时间复杂度？如何用大O记号表示？",
            "什么是最佳时间复杂度？如何用大Omega记号表示？",
            "最佳时间复杂度在实际中的使用场景是什么？",
            "什么是平均时间复杂度？如何用Theta记号表示？",
            "如何计算随机数据分布下的平均时间复杂度？",
            "为什么对于较为复杂的算法，计算平均时间复杂度往往是比较困难的？",
            "在什么情况下，我们通常使用最差时间复杂度作为算法效率的评判标准？",
            "为什么很少看到Theta符号？"
          ]
        }
      ]
    },
    {
      "file_name": "heap_sort.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 堆排序\n\n!!! tip\n\n    阅读本节前，请确保已学完“堆“章节。\n\n「堆排序 heap sort」是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序。\n\n1. 输入数组并建立小顶堆，此时最小元素位于堆顶。\n2. 不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列。\n\n以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式。\n\n## 算法流程\n\n设数组的长度为 $n$ ，堆排序的流程如下图所示。\n\n1. 输入数组并建立大顶堆。完成后，最大元素位于堆顶。\n2. 将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 $1$ ，已排序元素数量加 $1$ 。\n3. 从堆顶元素开始，从顶到底执行堆化操作（Sift Down）。完成堆化后，堆的性质得到修复。\n4. 循环执行第 `2.` 和 `3.` 步。循环 $n - 1$ 轮后，即可完成数组排序。\n\n!!! tip\n\n    实际上，元素出堆操作中也包含第 `2.` 和 `3.` 步，只是多了一个弹出元素的步骤。\n\n=== \"<1>\"\n    ![堆排序步骤](heap_sort.assets/heap_sort_step1.png)\n\n=== \"<2>\"\n    ![heap_sort_step2](heap_sort.assets/heap_sort_step2.png)\n\n=== \"<3>\"\n    ![heap_sort_step3](heap_sort.assets/heap_sort_step3.png)\n\n=== \"<4>\"\n    ![heap_sort_step4](heap_sort.assets/heap_sort_step4.png)\n\n=== \"<5>\"\n    ![heap_sort_step5](heap_sort.assets/heap_sort_step5.png)\n\n=== \"<6>\"\n    ![heap_sort_step6](heap_sort.assets/heap_sort_step6.png)\n\n=== \"<7>\"\n    ![heap_sort_step7](heap_sort.assets/heap_sort_step7.png)\n\n=== \"<8>\"\n    ![heap_sort_step8](heap_sort.assets/heap_sort_step8.png)\n\n=== \"<9>\"\n    ![heap_sort_step9](heap_sort.assets/heap_sort_step9.png)\n\n=== \"<10>\"\n    ![heap_sort_step10](heap_sort.assets/heap_sort_step10.png)\n\n=== \"<11>\"\n    ![heap_sort_step11](heap_sort.assets/heap_sort_step11.png)\n\n=== \"<12>\"\n    ![heap_sort_step12](heap_sort.assets/heap_sort_step12.png)\n\n在代码实现中，我们使用了与堆章节相同的从顶至底堆化 `sift_down()` 函数。值得注意的是，由于堆的长度会随着提取最大元素而减小，因此我们需要给 `sift_down()` 函数添加一个长度参数 $n$ ，用于指定堆的当前有效长度。\n\n```src\n[file]{heap_sort}-[class]{}-[func]{heap_sort}\n```\n\n## 算法特性\n\n- **时间复杂度 $O(n \\log n)$、非自适应排序**：建堆操作使用 $O(n)$ 时间。从堆中提取最大元素的时间复杂度为 $O(\\log n)$ ，共循环 $n - 1$ 轮。\n- **空间复杂度 $O(1)$、原地排序**：几个指针变量使用 $O(1)$ 空间。元素交换和堆化操作都是在原数组上进行的。\n- **非稳定排序**：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。",
          "questions": [
            "堆排序是基于哪种数据结构实现的？",
            "堆排序的时间复杂度是多少？为什么？",
            "堆排序的空间复杂度是多少？为什么？",
            "堆排序是稳定排序还是非稳定排序？为什么？",
            "堆排序的算法流程是怎样的？",
            "在堆排序中，为什么要先建立大顶堆？",
            "在堆排序中，为什么要从堆顶元素开始执行堆化操作？",
            "在堆排序中，为什么要循环执行第2和第3步，循环n-1轮后即可完成数组排序？",
            "在堆排序中，元素出堆操作中包含哪些步骤？",
            "在堆排序中，如何实现从顶至底堆化操作？"
          ]
        }
      ]
    },
    {
      "file_name": "fractional_knapsack_problem.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 分数背包问题\n\n!!! question\n\n    给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i-1]$、价值为 $val[i-1]$ ，和一个容量为 $cap$ 的背包。每个物品只能选择一次，**但可以选择物品的一部分，价值根据选择的重量比例计算**，问在不超过背包容量下背包中物品的最大价值。\n\n![分数背包问题的示例数据](fractional_knapsack_problem.assets/fractional_knapsack_example.png)\n\n分数背包和 0-1 背包整体上非常相似，状态包含当前物品 $i$ 和容量 $c$ ，目标是求不超过背包容量下的最大价值。\n\n不同点在于，本题允许只选择物品的一部分。如下图所示，**我们可以对物品任意地进行切分，并按照重量比例来计算物品价值**。\n\n1. 对于物品 $i$ ，它在单位重量下的价值为 $val[i-1] / wgt[i-1]$ ，简称为单位价值。\n2. 假设放入一部分物品 $i$ ，重量为 $w$ ，则背包增加的价值为 $w \\times val[i-1] / wgt[i-1]$ 。\n\n![物品在单位重量下的价值](fractional_knapsack_problem.assets/fractional_knapsack_unit_value.png)\n\n### 贪心策略确定\n\n最大化背包内物品总价值，**本质上是要最大化单位重量下的物品价值**。由此便可推出下图所示的贪心策略。\n\n1. 将物品按照单位价值从高到低进行排序。\n2. 遍历所有物品，**每轮贪心地选择单位价值最高的物品**。\n3. 若剩余背包容量不足，则使用当前物品的一部分填满背包即可。\n\n![分数背包的贪心策略](fractional_knapsack_problem.assets/fractional_knapsack_greedy_strategy.png)\n\n### 代码实现\n\n我们建立了一个物品类 `Item` ，以便将物品按照单位价值进行排序。循环进行贪心选择，当背包已满时跳出并返回解。\n\n```src\n[file]{fractional_knapsack}-[class]{}-[func]{fractional_knapsack}\n```\n\n最差情况下，需要遍历整个物品列表，**因此时间复杂度为 $O(n)$** ，其中 $n$ 为物品数量。\n\n由于初始化了一个 `Item` 对象列表，**因此空间复杂度为 $O(n)$** 。\n\n### 正确性证明\n\n采用反证法。假设物品 $x$ 是单位价值最高的物品，使用某算法求得最大价值为 `res` ，但该解中不包含物品 $x$ 。\n\n现在从背包中拿出单位重量的任意物品，并替换为单位重量的物品 $x$ 。由于物品 $x$ 的单位价值最高，因此替换后的总价值一定大于 `res` 。**这与 `res` 是最优解矛盾，说明最优解中必须包含物品 $x$** 。\n\n对于该解中的其他物品，我们也可以构建出上述矛盾。总而言之，**单位价值更大的物品总是更优选择**，这说明贪心策略是有效的。\n\n如下图所示，如果将物品重量和物品单位价值分别看作一个 2D 图表的横轴和纵轴，则分数背包问题可被转化为“求在有限横轴区间下的最大围成面积”。这个类比可以帮助我们从几何角度理解贪心策略的有效性。\n\n![分数背包问题的几何表示](fractional_knapsack_problem.assets/fractional_knapsack_area_chart.png)",
          "questions": [
            "什么是分数背包问题？",
            "分数背包问题和0-1背包问题有什么不同？",
            "如何计算物品的单位价值？",
            "分数背包问题的贪心策略是什么？",
            "为什么贪心策略是有效的？",
            "分数背包问题的时间复杂度是多少？",
            "分数背包问题的空间复杂度是多少？",
            "如何证明贪心策略的正确性？",
            "如何将分数背包问题转化为几何问题？",
            "分数背包问题的解法是否唯一？"
          ]
        }
      ]
    },
    {
      "file_name": "divide_and_conquer.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 分治算法\n\n「分治 divide and conquer」，全称分而治之，是一种非常重要且常见的算法策略。分治通常基于递归实现，包括“分”和“治”两个步骤。\n\n1. **分（划分阶段）**：递归地将原问题分解为两个或多个子问题，直至到达最小子问题时终止。\n2. **治（合并阶段）**：从已知解的最小子问题开始，从底至顶地将子问题的解进行合并，从而构建出原问题的解。\n\n如下图所示，“归并排序”是分治策略的典型应用之一。\n\n1. **分**：递归地将原数组（原问题）划分为两个子数组（子问题），直到子数组只剩一个元素（最小子问题）。\n2. **治**：从底至顶地将有序的子数组（子问题的解）进行合并，从而得到有序的原数组（原问题的解）。\n\n![归并排序的分治策略](divide_and_conquer.assets/divide_and_conquer_merge_sort.png)\n\n## 如何判断分治问题\n\n一个问题是否适合使用分治解决，通常可以参考以下几个判断依据。\n\n1. **问题可以被分解**：原问题可以被分解成规模更小、类似的子问题，以及能够以相同方式递归地进行划分。\n2. **子问题是独立的**：子问题之间是没有重叠的，互相没有依赖，可以被独立解决。\n3. **子问题的解可以被合并**：原问题的解通过合并子问题的解得来。\n\n显然，归并排序是满足以上三条判断依据的。\n\n1. **问题可以被分解**：递归地将数组（原问题）划分为两个子数组（子问题）。\n2. **子问题是独立的**：每个子数组都可以独立地进行排序（子问题可以独立进行求解）。\n3. **子问题的解可以被合并**：两个有序子数组（子问题的解）可以被合并为一个有序数组（原问题的解）。\n\n## 通过分治提升效率\n\n分治不仅可以有效地解决算法问题，**往往还可以带来算法效率的提升**。在排序算法中，快速排序、归并排序、堆排序相较于选择、冒泡、插入排序更快，就是因为它们应用了分治策略。\n\n那么，我们不禁发问：**为什么分治可以提升算法效率，其底层逻辑是什么**？换句话说，将大问题分解为多个子问题、解决子问题、将子问题的解合并为原问题的解，这几步的效率为什么比直接解决原问题的效率更高？这个问题可以从操作数量和并行计算两方面来讨论。\n\n### 操作数量优化\n\n以“冒泡排序”为例，其处理一个长度为 $n$ 的数组需要 $O(n^2)$ 时间。假设我们按照下图所示的方式，将数组从中点分为两个子数组，则划分需要 $O(n)$ 时间，排序每个子数组需要 $O((n / 2)^2)$ 时间，合并两个子数组需要 $O(n)$ 时间，总体时间复杂度为：\n\n$$\nO(n + (\\frac{n}{2})^2 \\times 2 + n) = O(\\frac{n^2}{2} + 2n)\n$$\n\n![划分数组前后的冒泡排序](divide_and_conquer.assets/divide_and_conquer_bubble_sort.png)\n\n接下来，我们计算以下不等式，其左边和右边分别为划分前和划分后的操作总数：\n\n$$\n\\begin{aligned}\nn^2 & > \\frac{n^2}{2} + 2n \\newline\nn^2 - \\frac{n^2}{2} - 2n & > 0 \\newline\nn(n - 4) & > 0\n\\end{aligned}\n$$\n\n**这意味着当 $n > 4$ 时，划分后的操作数量更少，排序效率应该更高**。请注意，划分后的时间复杂度仍然是平方阶 $O(n^2)$ ，只是复杂度中的常数项变小了。\n\n进一步想，**如果我们把子数组不断地再从中点划分为两个子数组**，直至子数组只剩一个元素时停止划分呢？这种思路实际上就是“归并排序”，时间复杂度为 $O(n \\log n)$ 。\n\n再思考，**如果我们多设置几个划分点**，将原数组平均划分为 $k$ 个子数组呢？这种情况与“桶排序”非常类似，它非常适合排序海量数据，理论上时间复杂度可以达到 $O(n + k)$ 。\n\n### 并行计算优化\n\n我们知道，分治生成的子问题是相互独立的，**因此通常可以并行解决**。也就是说，分治不仅可以降低算法的时间复杂度，**还有利于操作系统的并行优化**。\n\n并行优化在多核或多处理器的环境中尤其有效，因为系统可以同时处理多个子问题，更加充分地利用计算资源，从而显著减少总体的运行时间。\n\n比如在下图所示的“桶排序”中，我们将海量的数据平均分配到各个桶中，则可所有桶的排序任务分散到各个计算单元，完成后再进行结果合并。\n\n![桶排序的并行计算](divide_and_conquer.assets/divide_and_conquer_parallel_computing.png)\n\n## 分治常见应用\n\n一方面，分治可以用来解决许多经典算法问题。\n\n- **寻找最近点对**：该算法首先将点集分成两部分，然后分别找出两部分中的最近点对，最后再找出跨越两部分的最近点对。\n- **大整数乘法**：例如 Karatsuba 算法，它是将大整数乘法分解为几个较小的整数的乘法和加法。\n- **矩阵乘法**：例如 Strassen 算法，它是将大矩阵乘法分解为多个小矩阵的乘法和加法。\n- **汉诺塔问题**：汉诺塔问题可以视为典型的分治策略，通过递归解决。\n- **求解逆序对**：在一个序列中，如果前面的数字大于后面的数字，那么这两个数字构成一个逆序对。求解逆序对问题可以通过分治的思想，借助归并排序进行求解。\n\n另一方面，分治在算法和数据结构的设计中应用非常广泛。\n\n- **二分查找**：二分查找是将有序数组从中点索引分为两部分，然后根据目标值与中间元素值比较结果，决定排除哪一半区间，然后在剩余区间执行相同的二分操作。\n- **归并排序**：文章开头已介绍，不再赘述。\n- **快速排序**：快速排序是选取一个基准值，然后把数组分为两个子数组，一个子数组的元素比基准值小，另一子数组的元素比基准值大，然后再对这两部分进行相同的划分操作，直至子数组只剩下一个元素。\n- **桶排序**：桶排序的基本思想是将数据分散到多个桶，然后对每个桶内的元素进行排序，最后将各个桶的元素依次取出，从而得到一个有序数组。\n- **树**：例如二叉搜索树、AVL 树、红黑树、B 树、B+ 树等，它们的查找、插入和删除等操作都可以视为分治的应用。\n- **堆**：堆是一种特殊的完全二叉树，其各种操作，如插入、删除和堆化，实际上都隐含了分治的思想。\n- **哈希表**：虽然哈希表来并不直接应用分治，但某些哈希冲突解决策略间接应用了分治策略，例如，链式地址中的长链表会被转化为红黑树，以提升查询效率。\n\n可以看出，**分治是一种“润物细无声”的算法思想**，隐含在各种算法与数据结构之中。",
          "questions": [
            "分治算法的基本步骤是什么？",
            "如何判断一个问题是否适合使用分治算法解决？",
            "分治算法如何提升算法效率？",
            "分治算法如何进行并行计算优化？",
            "分治算法在哪些经典算法问题中得到了应用？",
            "分治算法在哪些算法和数据结构中得到了应用？",
            "二分查找是如何应用分治思想的？",
            "快速排序是如何应用分治思想的？",
            "堆是如何应用分治思想的？",
            "哈希表中的某些冲突解决策略是如何应用分治思想的？"
          ]
        }
      ]
    },
    {
      "file_name": "knapsack_problem.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 0-1 背包问题\n\n背包问题是一个非常好的动态规划入门题目，是动态规划中最常见的问题形式。其具有很多变种，例如 0-1 背包问题、完全背包问题、多重背包问题等。\n\n在本节中，我们先来求解最常见的 0-1 背包问题。\n\n!!! question\n\n    给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i-1]$、价值为 $val[i-1]$ ，和一个容量为 $cap$ 的背包。每个物品只能选择一次，问在不超过背包容量下能放入物品的最大价值。\n\n观察下图，由于物品编号 $i$ 从 $1$ 开始计数，数组索引从 $0$ 开始计数，因此物品 $i$ 对应重量 $wgt[i-1]$ 和价值 $val[i-1]$ 。\n\n![0-1 背包的示例数据](knapsack_problem.assets/knapsack_example.png)\n\n我们可以将 0-1 背包问题看作是一个由 $n$ 轮决策组成的过程，每个物体都有不放入和放入两种决策，因此该问题是满足决策树模型的。\n\n该问题的目标是求解“在限定背包容量下的最大价值”，因此较大概率是个动态规划问题。\n\n**第一步：思考每轮的决策，定义状态，从而得到 $dp$ 表**\n\n对于每个物品来说，不放入背包，背包容量不变；放入背包，背包容量减小。由此可得状态定义：当前物品编号 $i$ 和剩余背包容量 $c$ ，记为 $[i, c]$ 。\n\n状态 $[i, c]$ 对应的子问题为：**前 $i$ 个物品在剩余容量为 $c$ 的背包中的最大价值**，记为 $dp[i, c]$ 。\n\n待求解的是 $dp[n, cap]$ ，因此需要一个尺寸为 $(n+1) \\times (cap+1)$ 的二维 $dp$ 表。\n\n**第二步：找出最优子结构，进而推导出状态转移方程**\n\n当我们做出物品 $i$ 的决策后，剩余的是前 $i-1$ 个物品的决策，可分为以下两种情况。\n\n- **不放入物品 $i$** ：背包容量不变，状态变化为 $[i-1, c]$ 。\n- **放入物品 $i$** ：背包容量减小 $wgt[i-1]$ ，价值增加 $val[i-1]$ ，状态变化为 $[i-1, c-wgt[i-1]]$ 。\n\n上述分析向我们揭示了本题的最优子结构：**最大价值 $dp[i, c]$ 等于不放入物品 $i$ 和放入物品 $i$ 两种方案中的价值更大的那一个**。由此可推出状态转移方程：\n\n$$\ndp[i, c] = \\max(dp[i-1, c], dp[i-1, c - wgt[i-1]] + val[i-1])\n$$\n\n需要注意的是，若当前物品重量 $wgt[i - 1]$ 超出剩余背包容量 $c$ ，则只能选择不放入背包。\n\n**第三步：确定边界条件和状态转移顺序**\n\n当无物品或无剩余背包容量时最大价值为 $0$ ，即首列 $dp[i, 0]$ 和首行 $dp[0, c]$ 都等于 $0$ 。\n\n当前状态 $[i, c]$ 从上方的状态 $[i-1, c]$ 和左上方的状态 $[i-1, c-wgt[i-1]]$ 转移而来，因此通过两层循环正序遍历整个 $dp$ 表即可。\n\n根据以上分析，我们接下来按顺序实现暴力搜索、记忆化搜索、动态规划解法。\n\n### 方法一：暴力搜索\n\n搜索代码包含以下要素。\n\n- **递归参数**：状态 $[i, c]$ 。\n- **返回值**：子问题的解 $dp[i, c]$ 。\n- **终止条件**：当物品编号越界 $i = 0$ 或背包剩余容量为 $0$ 时，终止递归并返回价值 $0$ 。\n- **剪枝**：若当前物品重量超出背包剩余容量，则只能不放入背包。\n\n```src\n[file]{knapsack}-[class]{}-[func]{knapsack_dfs}\n```\n\n如下图所示，由于每个物品都会产生不选和选两条搜索分支，因此时间复杂度为 $O(2^n)$ 。\n\n观察递归树，容易发现其中存在重叠子问题，例如 $dp[1, 10]$ 等。而当物品较多、背包容量较大，尤其是相同重量的物品较多时，重叠子问题的数量将会大幅增多。\n\n![0-1 背包的暴力搜索递归树](knapsack_problem.assets/knapsack_dfs.png)\n\n### 方法二：记忆化搜索\n\n为了保证重叠子问题只被计算一次，我们借助记忆列表 `mem` 来记录子问题的解，其中 `mem[i][c]` 对应 $dp[i, c]$ 。\n\n引入记忆化之后，**时间复杂度取决于子问题数量**，也就是 $O(n \\times cap)$ 。\n\n```src\n[file]{knapsack}-[class]{}-[func]{knapsack_dfs_mem}\n```\n\n下图展示了在记忆化递归中被剪掉的搜索分支。\n\n![0-1 背包的记忆化搜索递归树](knapsack_problem.assets/knapsack_dfs_mem.png)\n\n### 方法三：动态规划\n\n动态规划实质上就是在状态转移中填充 $dp$ 表的过程，代码如下所示。\n\n```src\n[file]{knapsack}-[class]{}-[func]{knapsack_dp}\n```\n\n如下图所示，时间复杂度和空间复杂度都由数组 `dp` 大小决定，即 $O(n \\times cap)$ 。\n\n=== \"<1>\"\n    ![0-1 背包的动态规划过程](knapsack_problem.assets/knapsack_dp_step1.png)\n\n=== \"<2>\"\n    ![knapsack_dp_step2](knapsack_problem.assets/knapsack_dp_step2.png)\n\n=== \"<3>\"\n    ![knapsack_dp_step3](knapsack_problem.assets/knapsack_dp_step3.png)\n\n=== \"<4>\"\n    ![knapsack_dp_step4](knapsack_problem.assets/knapsack_dp_step4.png)\n\n=== \"<5>\"\n    ![knapsack_dp_step5](knapsack_problem.assets/knapsack_dp_step5.png)\n\n=== \"<6>\"\n    ![knapsack_dp_step6](knapsack_problem.assets/knapsack_dp_step6.png)\n\n=== \"<7>\"\n    ![knapsack_dp_step7](knapsack_problem.assets/knapsack_dp_step7.png)\n\n=== \"<8>\"\n    ![knapsack_dp_step8](knapsack_problem.assets/knapsack_dp_step8.png)\n\n=== \"<9>\"\n    ![knapsack_dp_step9](knapsack_problem.assets/knapsack_dp_step9.png)\n\n=== \"<10>\"\n    ![knapsack_dp_step10](knapsack_problem.assets/knapsack_dp_step10.png)\n\n=== \"<11>\"\n    ![knapsack_dp_step11](knapsack_problem.assets/knapsack_dp_step11.png)\n\n=== \"<12>\"\n    ![knapsack_dp_step12](knapsack_problem.assets/knapsack_dp_step12.png)\n\n=== \"<13>\"\n    ![knapsack_dp_step13](knapsack_problem.assets/knapsack_dp_step13.png)\n\n=== \"<14>\"\n    ![knapsack_dp_step14](knapsack_problem.assets/knapsack_dp_step14.png)\n\n### 空间优化\n\n由于每个状态都只与其上一行的状态有关，因此我们可以使用两个数组滚动前进，将空间复杂度从 $O(n^2)$ 将低至 $O(n)$ 。\n\n进一步思考，我们是否可以仅用一个数组实现空间优化呢？观察可知，每个状态都是由正上方或左上方的格子转移过来的。假设只有一个数组，当开始遍历第 $i$ 行时，该数组存储的仍然是第 $i-1$ 行的状态。\n\n- 如果采取正序遍历，那么遍历到 $dp[i, j]$ 时，左上方 $dp[i-1, 1]$ ~ $dp[i-1, j-1]$ 值可能已经被覆盖，此时就无法得到正确的状态转移结果。\n- 如果采取倒序遍历，则不会发生覆盖问题，状态转移可以正确进行。\n\n下图展示了在单个数组下从第 $i = 1$ 行转换至第 $i = 2$ 行的过程。请思考正序遍历和倒序遍历的区别。\n\n=== \"<1>\"\n    ![0-1 背包的空间优化后的动态规划过程](knapsack_problem.assets/knapsack_dp_comp_step1.png)\n\n=== \"<2>\"\n    ![knapsack_dp_comp_step2](knapsack_problem.assets/knapsack_dp_comp_step2.png)\n\n=== \"<3>\"\n    ![knapsack_dp_comp_step3](knapsack_problem.assets/knapsack_dp_comp_step3.png)\n\n=== \"<4>\"\n    ![knapsack_dp_comp_step4](knapsack_problem.assets/knapsack_dp_comp_step4.png)\n\n=== \"<5>\"\n    ![knapsack_dp_comp_step5](knapsack_problem.assets/knapsack_dp_comp_step5.png)\n\n=== \"<6>\"\n    ![knapsack_dp_comp_step6](knapsack_problem.assets/knapsack_dp_comp_step6.png)\n\n在代码实现中，我们仅需将数组 `dp` 的第一维 $i$ 直接删除，并且把内循环更改为倒序遍历即可。\n\n```src\n[file]{knapsack}-[class]{}-[func]{knapsack_dp_comp}\n```",
          "questions": [
            "什么是背包问题？有哪些变种？",
            "0-1背包问题的状态定义是什么？对应的子问题是什么？",
            "0-1背包问题的最优子结构是什么？如何推导出状态转移方程？",
            "在0-1背包问题中，如何确定边界条件和状态转移顺序？",
            "什么是暴力搜索？在0-1背包问题中，暴力搜索的时间复杂度是多少？",
            "什么是记忆化搜索？如何避免重叠子问题？",
            "什么是动态规划？在0-1背包问题中，动态规划的时间复杂度和空间复杂度分别是多少？",
            "如何进行空间优化？为什么需要倒序遍历？",
            "除了0-1背包问题，还有哪些经典的动态规划问题？",
            "动态规划问题的解法有哪些优缺点？如何选择合适的解法？"
          ]
        }
      ]
    },
    {
      "file_name": "dp_solution_pipeline.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 动态规划解题思路\n\n上两节介绍了动态规划问题的主要特征，接下来我们一起探究两个更加实用的问题。\n\n1. 如何判断一个问题是不是动态规划问题？\n2. 求解动态规划问题该从何处入手，完整步骤是什么？\n\n## 问题判断\n\n总的来说，如果一个问题包含重叠子问题、最优子结构，并满足无后效性，那么它通常就适合用动态规划求解。然而，我们很难从问题描述上直接提取出这些特性。因此我们通常会放宽条件，**先观察问题是否适合使用回溯（穷举）解决**。\n\n**适合用回溯解决的问题通常满足“决策树模型”**，这种问题可以使用树形结构来描述，其中每一个节点代表一个决策，每一条路径代表一个决策序列。\n\n换句话说，如果问题包含明确的决策概念，并且解是通过一系列决策产生的，那么它就满足决策树模型，通常可以使用回溯来解决。\n\n在此基础上，动态规划问题还有一些判断的“加分项”。\n\n- 问题包含最大（小）或最多（少）等最优化描述。\n- 问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系。\n\n相应地，也存在一些“减分项”。\n\n- 问题的目标是找出所有可能的解决方案，而不是找出最优解。\n- 问题描述中有明显的排列组合的特征，需要返回具体的多个方案。\n\n如果一个问题满足决策树模型，并具有较为明显的“加分项“，我们就可以假设它是一个动态规划问题，并在求解过程中验证它。\n\n## 问题求解步骤\n\n动态规划的解题流程会因问题的性质和难度而有所不同，但通常遵循以下步骤：描述决策，定义状态，建立 $dp$ 表，推导状态转移方程，确定边界条件等。\n\n为了更形象地展示解题步骤，我们使用一个经典问题“最小路径和”来举例。\n\n!!! question\n\n    给定一个 $n \\times m$ 的二维网格 `grid` ，网格中的每个单元格包含一个非负整数，表示该单元格的代价。机器人以左上角单元格为起始点，每次只能向下或者向右移动一步，直至到达右下角单元格。请返回从左上角到右下角的最小路径和。\n\n下图展示了一个例子，给定网格的最小路径和为 $13$ 。\n\n![最小路径和示例数据](dp_solution_pipeline.assets/min_path_sum_example.png)\n\n**第一步：思考每轮的决策，定义状态，从而得到 $dp$ 表**\n\n本题的每一轮的决策就是从当前格子向下或向右一步。设当前格子的行列索引为 $[i, j]$ ，则向下或向右走一步后，索引变为 $[i+1, j]$ 或 $[i, j+1]$ 。因此，状态应包含行索引和列索引两个变量，记为 $[i, j]$ 。\n\n状态 $[i, j]$ 对应的子问题为：从起始点 $[0, 0]$ 走到 $[i, j]$ 的最小路径和，解记为 $dp[i, j]$ 。\n\n至此，我们就得到了下图所示的二维 $dp$ 矩阵，其尺寸与输入网格 $grid$ 相同。\n\n![状态定义与 dp 表](dp_solution_pipeline.assets/min_path_sum_solution_step1.png)\n\n!!! note\n\n    动态规划和回溯过程可以被描述为一个决策序列，而状态由所有决策变量构成。它应当包含描述解题进度的所有变量，其包含了足够的信息，能够用来推导出下一个状态。\n    \n    每个状态都对应一个子问题，我们会定义一个 $dp$ 表来存储所有子问题的解，状态的每个独立变量都是 $dp$ 表的一个维度。本质上看，$dp$ 表是状态和子问题的解之间的映射。\n\n**第二步：找出最优子结构，进而推导出状态转移方程**\n\n对于状态 $[i, j]$ ，它只能从上边格子 $[i-1, j]$ 和左边格子 $[i, j-1]$ 转移而来。因此最优子结构为：到达 $[i, j]$ 的最小路径和由 $[i, j-1]$ 的最小路径和与 $[i-1, j]$ 的最小路径和，这两者较小的那一个决定。\n\n根据以上分析，可推出下图所示的状态转移方程：\n\n$$\ndp[i, j] = \\min(dp[i-1, j], dp[i, j-1]) + grid[i, j]\n$$\n\n![最优子结构与状态转移方程](dp_solution_pipeline.assets/min_path_sum_solution_step2.png)\n\n!!! note\n\n    根据定义好的 $dp$ 表，思考原问题和子问题的关系，找出通过子问题的最优解来构造原问题的最优解的方法，即最优子结构。\n\n    一旦我们找到了最优子结构，就可以使用它来构建出状态转移方程。\n\n**第三步：确定边界条件和状态转移顺序**\n\n在本题中，首行的状态只能从其左边的状态得来，首列的状态只能从其上边的状态得来，因此首行 $i = 0$ 和首列 $j = 0$ 是边界条件。\n\n如下图所示，由于每个格子是由其左方格子和上方格子转移而来，因此我们使用采用循环来遍历矩阵，外循环遍历各行、内循环遍历各列。\n\n![边界条件与状态转移顺序](dp_solution_pipeline.assets/min_path_sum_solution_step3.png)\n\n!!! note\n\n    边界条件在动态规划中用于初始化 $dp$ 表，在搜索中用于剪枝。\n    \n    状态转移顺序的核心是要保证在计算当前问题的解时，所有它依赖的更小子问题的解都已经被正确地计算出来。\n\n根据以上分析，我们已经可以直接写出动态规划代码。然而子问题分解是一种从顶至底的思想，因此按照“暴力搜索 $\\rightarrow$ 记忆化搜索 $\\rightarrow$ 动态规划”的顺序实现更加符合思维习惯。\n\n### 方法一：暴力搜索\n\n从状态 $[i, j]$ 开始搜索，不断分解为更小的状态 $[i-1, j]$ 和 $[i, j-1]$ ，递归函数包括以下要素。\n\n- **递归参数**：状态 $[i, j]$ 。\n- **返回值**：从 $[0, 0]$ 到 $[i, j]$ 的最小路径和 $dp[i, j]$ 。\n- **终止条件**：当 $i = 0$ 且 $j = 0$ 时，返回代价 $grid[0, 0]$ 。\n- **剪枝**：当 $i < 0$ 时或 $j < 0$ 时索引越界，此时返回代价 $+\\infty$ ，代表不可行。\n\n```src\n[file]{min_path_sum}-[class]{}-[func]{min_path_sum_dfs}\n```\n\n下图给出了以 $dp[2, 1]$ 为根节点的递归树，其中包含一些重叠子问题，其数量会随着网格 `grid` 的尺寸变大而急剧增多。\n\n本质上看，造成重叠子问题的原因为：**存在多条路径可以从左上角到达某一单元格**。\n\n![暴力搜索递归树](dp_solution_pipeline.assets/min_path_sum_dfs.png)\n\n每个状态都有向下和向右两种选择，从左上角走到右下角总共需要 $m + n - 2$ 步，所以最差时间复杂度为 $O(2^{m + n})$ 。请注意，这种计算方式未考虑临近网格边界的情况，当到达网络边界时只剩下一种选择。因此实际的路径数量会少一些。\n\n### 方法二：记忆化搜索\n\n我们引入一个和网格 `grid` 相同尺寸的记忆列表 `mem` ，用于记录各个子问题的解，并将重叠子问题进行剪枝。\n\n```src\n[file]{min_path_sum}-[class]{}-[func]{min_path_sum_dfs_mem}\n```\n\n如下图所示，在引入记忆化后，所有子问题的解只需计算一次，因此时间复杂度取决于状态总数，即网格尺寸 $O(nm)$ 。\n\n![记忆化搜索递归树](dp_solution_pipeline.assets/min_path_sum_dfs_mem.png)",
          "questions": [
            "什么样的问题适合使用动态规划求解？",
            "如何判断一个问题是否适合使用动态规划求解？",
            "什么是决策树模型？哪些问题适合使用决策树模型？",
            "动态规划问题有哪些判断的“加分项”和“减分项”？",
            "动态规划问题的解题流程是什么？",
            "什么是最优子结构？如何使用最优子结构来构建状态转移方程？",
            "在动态规划中，什么是边界条件？它们的作用是什么？",
            "在动态规划中，状态转移顺序的核心是什么？为什么要保证这个顺序？",
            "什么是记忆化搜索？它和暴力搜索有什么区别？",
            "在动态规划中，如何使用记忆化搜索来优化时间复杂度？"
          ]
        },
        {
          "content": "### 方法三：动态规划\n\n基于迭代实现动态规划解法。\n\n```src\n[file]{min_path_sum}-[class]{}-[func]{min_path_sum_dp}\n```\n\n下图展示了最小路径和的状态转移过程，其遍历了整个网格，**因此时间复杂度为 $O(nm)$** 。\n\n数组 `dp` 大小为 $n \\times m$ ，**因此空间复杂度为 $O(nm)$** 。\n\n=== \"<1>\"\n    ![最小路径和的动态规划过程](dp_solution_pipeline.assets/min_path_sum_dp_step1.png)\n\n=== \"<2>\"\n    ![min_path_sum_dp_step2](dp_solution_pipeline.assets/min_path_sum_dp_step2.png)\n\n=== \"<3>\"\n    ![min_path_sum_dp_step3](dp_solution_pipeline.assets/min_path_sum_dp_step3.png)\n\n=== \"<4>\"\n    ![min_path_sum_dp_step4](dp_solution_pipeline.assets/min_path_sum_dp_step4.png)\n\n=== \"<5>\"\n    ![min_path_sum_dp_step5](dp_solution_pipeline.assets/min_path_sum_dp_step5.png)\n\n=== \"<6>\"\n    ![min_path_sum_dp_step6](dp_solution_pipeline.assets/min_path_sum_dp_step6.png)\n\n=== \"<7>\"\n    ![min_path_sum_dp_step7](dp_solution_pipeline.assets/min_path_sum_dp_step7.png)\n\n=== \"<8>\"\n    ![min_path_sum_dp_step8](dp_solution_pipeline.assets/min_path_sum_dp_step8.png)\n\n=== \"<9>\"\n    ![min_path_sum_dp_step9](dp_solution_pipeline.assets/min_path_sum_dp_step9.png)\n\n=== \"<10>\"\n    ![min_path_sum_dp_step10](dp_solution_pipeline.assets/min_path_sum_dp_step10.png)\n\n=== \"<11>\"\n    ![min_path_sum_dp_step11](dp_solution_pipeline.assets/min_path_sum_dp_step11.png)\n\n=== \"<12>\"\n    ![min_path_sum_dp_step12](dp_solution_pipeline.assets/min_path_sum_dp_step12.png)\n\n### 空间优化\n\n由于每个格子只与其左边和上边的格子有关，因此我们可以只用一个单行数组来实现 $dp$ 表。\n\n请注意，因为数组 `dp` 只能表示一行的状态，所以我们无法提前初始化首列状态，而是在遍历每行中更新它。\n\n```src\n[file]{min_path_sum}-[class]{}-[func]{min_path_sum_dp_comp}\n```",
          "questions": [
            "动态规划解法的时间复杂度和空间复杂度分别是多少？",
            "数组 `dp` 的大小是多少？",
            "最小路径和的状态转移过程遍历了整个网格，这个过程的时间复杂度是多少？",
            "为什么数组 `dp` 的大小是 $n \\times m$？",
            "为什么空间优化后只需要一个单行数组来实现 $dp$ 表？",
            "在空间优化的解法中，为什么无法提前初始化首列状态？",
            "在动态规划解法中，每个格子与哪些格子有关？",
            "在空间优化的解法中，如何更新首列状态？",
            "在动态规划解法中，如何实现状态转移？",
            "在空间优化的解法中，如何实现状态转移？"
          ]
        }
      ]
    },
    {
      "file_name": "selection_sort.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 选择排序\n\n「选择排序 selection sort」的工作原理非常直接：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。\n\n设数组的长度为 $n$ ，选择排序的算法流程如下图所示。\n\n1. 初始状态下，所有元素未排序，即未排序（索引）区间为 $[0, n-1]$ 。\n2. 选取区间 $[0, n-1]$ 中的最小元素，将其与索引 $0$ 处元素交换。完成后，数组前 1 个元素已排序。\n3. 选取区间 $[1, n-1]$ 中的最小元素，将其与索引 $1$ 处元素交换。完成后，数组前 2 个元素已排序。\n4. 以此类推。经过 $n - 1$ 轮选择与交换后，数组前 $n - 1$ 个元素已排序。\n5. 仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。\n\n=== \"<1>\"\n    ![选择排序步骤](selection_sort.assets/selection_sort_step1.png)\n\n=== \"<2>\"\n    ![selection_sort_step2](selection_sort.assets/selection_sort_step2.png)\n\n=== \"<3>\"\n    ![selection_sort_step3](selection_sort.assets/selection_sort_step3.png)\n\n=== \"<4>\"\n    ![selection_sort_step4](selection_sort.assets/selection_sort_step4.png)\n\n=== \"<5>\"\n    ![selection_sort_step5](selection_sort.assets/selection_sort_step5.png)\n\n=== \"<6>\"\n    ![selection_sort_step6](selection_sort.assets/selection_sort_step6.png)\n\n=== \"<7>\"\n    ![selection_sort_step7](selection_sort.assets/selection_sort_step7.png)\n\n=== \"<8>\"\n    ![selection_sort_step8](selection_sort.assets/selection_sort_step8.png)\n\n=== \"<9>\"\n    ![selection_sort_step9](selection_sort.assets/selection_sort_step9.png)\n\n=== \"<10>\"\n    ![selection_sort_step10](selection_sort.assets/selection_sort_step10.png)\n\n=== \"<11>\"\n    ![selection_sort_step11](selection_sort.assets/selection_sort_step11.png)\n\n在代码中，我们用 $k$ 来记录未排序区间内的最小元素。\n\n```src\n[file]{selection_sort}-[class]{}-[func]{selection_sort}\n```\n\n## 算法特性\n\n- **时间复杂度为 $O(n^2)$、非自适应排序**：外循环共 $n - 1$ 轮，第一轮的未排序区间长度为 $n$ ，最后一轮的未排序区间长度为 $2$ ，即各轮外循环分别包含 $n$、$n - 1$、$\\dots$、$3$、$2$ 轮内循环，求和为 $\\frac{(n - 1)(n + 2)}{2}$ 。\n- **空间复杂度 $O(1)$、原地排序**：指针 $i$ 和 $j$ 使用常数大小的额外空间。\n- **非稳定排序**：如下图所示，元素 `nums[i]` 有可能被交换至与其相等的元素的右边，导致两者相对顺序发生改变。\n\n![选择排序非稳定示例](selection_sort.assets/selection_sort_instability.png)",
          "questions": [
            "选择排序的时间复杂度是多少？为什么？",
            "选择排序的空间复杂度是多少？为什么？",
            "选择排序是稳定排序还是非稳定排序？为什么？",
            "选择排序的算法流程是怎样的？",
            "选择排序中，如何记录未排序区间内的最小元素？",
            "选择排序中，每轮选择最小元素后，将其放到已排序区间的末尾，这个过程是如何实现的？",
            "选择排序中，为什么最后一个元素不需要排序？",
            "选择排序中，外循环共进行了多少轮？内循环的次数是多少？",
            "选择排序中，指针 i 和 j 使用了多少额外空间？",
            "选择排序中，可以用哪些数据结构来优化算法效率？为什么？"
          ]
        }
      ]
    },
    {
      "file_name": "space_complexity.md",
      "question_count": 30,
      "documents": [
        {
          "content": "# 空间复杂度\n\n「空间复杂度 space complexity」用于衡量算法占用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度非常类似，只需将“运行时间”替换为“占用内存空间”。\n\n## 算法相关空间\n\n算法在运行过程中使用的内存空间主要包括以下几种。\n\n- **输入空间**：用于存储算法的输入数据。\n- **暂存空间**：用于存储算法在运行过程中的变量、对象、函数上下文等数据。\n- **输出空间**：用于存储算法的输出数据。\n\n一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。\n\n暂存空间可以进一步划分为三个部分。\n\n- **暂存数据**：用于保存算法运行过程中的各种常量、变量、对象等。\n- **栈帧空间**：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。\n- **指令空间**：用于保存编译后的程序指令，在实际统计中通常忽略不计。\n\n在分析一段程序的空间复杂度时，**我们通常统计暂存数据、栈帧空间和输出数据三部分**。\n\n![算法使用的相关空间](space_complexity.assets/space_types.png)\n\n=== \"Python\"\n\n    ```python title=\"\"\n    class Node:\n        \"\"\"类\"\"\"\n        def __init__(self, x: int):\n            self.val: int = x              # 节点值\n            self.next: Node | None = None  # 指向下一节点的引用\n\n    def function() -> int:\n        \"\"\"函数\"\"\"\n        # 执行某些操作...\n        return 0\n\n    def algorithm(n) -> int:  # 输入数据\n        A = 0                 # 暂存数据（常量，一般用大写字母表示）\n        b = 0                 # 暂存数据（变量）\n        node = Node(0)        # 暂存数据（对象）\n        c = function()        # 栈帧空间（调用函数）\n        return A + b + c      # 输出数据\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"\"\n    /* 结构体 */\n    struct Node {\n        int val;\n        Node *next;\n        Node(int x) : val(x), next(nullptr) {}\n    };\n\n    /* 函数 */\n    int func() {\n        // 执行某些操作...\n        return 0;\n    }\n\n    int algorithm(int n) {        // 输入数据\n        const int a = 0;          // 暂存数据（常量）\n        int b = 0;                // 暂存数据（变量）\n        Node* node = new Node(0); // 暂存数据（对象）\n        int c = func();           // 栈帧空间（调用函数）\n        return a + b + c;         // 输出数据\n    }\n    ```\n\n=== \"Java\"\n\n    ```java title=\"\"\n    /* 类 */\n    class Node {\n        int val;\n        Node next;\n        Node(int x) { val = x; }\n    }\n    \n    /* 函数 */\n    int function() {\n        // 执行某些操作...\n        return 0;\n    }\n    \n    int algorithm(int n) {        // 输入数据\n        final int a = 0;          // 暂存数据（常量）\n        int b = 0;                // 暂存数据（变量）\n        Node node = new Node(0);  // 暂存数据（对象）\n        int c = function();       // 栈帧空间（调用函数）\n        return a + b + c;         // 输出数据\n    }\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"\"\n    /* 类 */\n    class Node {\n        int val;\n        Node next;\n        Node(int x) { val = x; }\n    }\n\n    /* 函数 */\n    int Function() {\n        // 执行某些操作...\n        return 0;\n    }\n\n    int Algorithm(int n) {        // 输入数据\n        const int a = 0;          // 暂存数据（常量）\n        int b = 0;                // 暂存数据（变量）\n        Node node = new(0);  // 暂存数据（对象）\n        int c = Function();       // 栈帧空间（调用函数）\n        return a + b + c;         // 输出数据\n    }\n    ```\n\n=== \"Go\"\n\n    ```go title=\"\"\n    /* 结构体 */\n    type node struct {\n        val  int\n        next *node\n    }\n\n    /* 创建 node 结构体  */\n    func newNode(val int) *node {\n        return &node{val: val}\n    }\n    \n    /* 函数 */\n    func function() int {\n        // 执行某些操作...\n        return 0\n    }\n\n    func algorithm(n int) int { // 输入数据\n        const a = 0             // 暂存数据（常量）\n        b := 0                  // 暂存数据（变量）\n        newNode(0)              // 暂存数据（对象）\n        c := function()         // 栈帧空间（调用函数）\n        return a + b + c        // 输出数据\n    }\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"\"\n    /* 类 */\n    class Node {\n        var val: Int\n        var next: Node?\n\n        init(x: Int) {\n            val = x\n        }\n    }\n\n    /* 函数 */\n    func function() -> Int {\n        // 执行某些操作...\n        return 0\n    }\n\n    func algorithm(n: Int) -> Int { // 输入数据\n        let a = 0             // 暂存数据（常量）\n        var b = 0             // 暂存数据（变量）\n        let node = Node(x: 0) // 暂存数据（对象）\n        let c = function()    // 栈帧空间（调用函数）\n        return a + b + c      // 输出数据\n    }\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"\"\n    /* 类 */\n    class Node {\n        val;\n        next;\n        constructor(val) {\n            this.val = val === undefined ? 0 : val; // 节点值\n            this.next = null;                       // 指向下一节点的引用\n        }\n    }\n\n    /* 函数 */\n    function constFunc() {\n        // 执行某些操作\n        return 0;\n    }\n\n    function algorithm(n) {       // 输入数据\n        const a = 0;              // 暂存数据（常量）\n        let b = 0;                // 暂存数据（变量）\n        const node = new Node(0); // 暂存数据（对象）\n        const c = constFunc();    // 栈帧空间（调用函数）\n        return a + b + c;         // 输出数据\n    }\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"\"\n    /* 类 */\n    class Node {\n        val: number;\n        next: Node | null;\n        constructor(val?: number) {\n            this.val = val === undefined ? 0 : val; // 节点值\n            this.next = null;                       // 指向下一节点的引用\n        }\n    }\n\n    /* 函数 */\n    function constFunc(): number {\n        // 执行某些操作\n        return 0;\n    }\n\n    function algorithm(n: number): number { // 输入数据\n        const a = 0;                        // 暂存数据（常量）\n        let b = 0;                          // 暂存数据（变量）\n        const node = new Node(0);           // 暂存数据（对象）\n        const c = constFunc();              // 栈帧空间（调用函数）\n        return a + b + c;                   // 输出数据\n    }\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"\"\n    /* 类 */\n    class Node {\n      int val;\n      Node next;\n      Node(this.val, [this.next]);\n    }\n\n    /* 函数 */\n    int function() {\n      // 执行某些操作...\n      return 0;\n    }\n\n    int algorithm(int n) {  // 输入数据\n      const int a = 0;      // 暂存数据（常量）\n      int b = 0;            // 暂存数据（变量）\n      Node node = Node(0);  // 暂存数据（对象）\n      int c = function();   // 栈帧空间（调用函数）\n      return a + b + c;     // 输出数据\n    }\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"\"\n    use std::rc::Rc;\n    use std::cell::RefCell;\n    \n    /* 结构体 */\n    struct Node {\n        val: i32,\n        next: Option<Rc<RefCell<Node>>>,\n    }\n\n    /* 创建 Node 结构体 */\n    impl Node {\n        fn new(val: i32) -> Self {\n            Self { val: val, next: None }\n        }\n    }\n\n    /* 函数 */\n    fn function() -> i32 {      \n        // 执行某些操作...\n        return 0;\n    }\n\n    fn algorithm(n: i32) -> i32 {       // 输入数据\n        const a: i32 = 0;               // 暂存数据（常量）\n        let mut b = 0;                  // 暂存数据（变量）\n        let node = Node::new(0);        // 暂存数据（对象）\n        let c = function();             // 栈帧空间（调用函数）\n        return a + b + c;               // 输出数据\n    }\n    ```\n\n=== \"C\"\n\n    ```c title=\"\"\n    /* 函数 */\n    int func() {\n        // 执行某些操作...\n        return 0;\n    }\n\n    int algorithm(int n) { // 输入数据\n        const int a = 0;   // 暂存数据（常量）\n        int b = 0;         // 暂存数据（变量）\n        int c = func();    // 栈帧空间（调用函数）\n        return a + b + c;  // 输出数据\n    }\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"\"\n\n    ```",
          "questions": [
            "空间复杂度与时间复杂度有何异同之处？",
            "算法在运行过程中使用的内存空间主要包括哪几种？",
            "在分析一段程序的空间复杂度时，需要统计哪三部分？",
            "暂存空间可以进一步划分为哪三个部分？",
            "在 Python 中，如何定义一个类？如何定义一个函数？",
            "在 C++ 中，如何定义一个结构体？如何定义一个函数？",
            "在 Java 中，如何定义一个类？如何定义一个函数？",
            "在 C# 中，如何定义一个类？如何定义一个函数？",
            "在 Go 中，如何定义一个结构体？如何定义一个函数？",
            "在 Swift 中，如何定义一个类？如何定义一个函数？"
          ]
        },
        {
          "content": "## 推算方法\n\n空间复杂度的推算方法与时间复杂度大致相同，只需将统计对象从“操作数量”转为“使用空间大小”。\n\n而与时间复杂度不同的是，**我们通常只关注最差空间复杂度**。这是因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留。\n\n观察以下代码，最差空间复杂度中的“最差”有两层含义。\n\n1. **以最差输入数据为准**：当 $n < 10$ 时，空间复杂度为 $O(1)$ ；但当 $n > 10$ 时，初始化的数组 `nums` 占用 $O(n)$ 空间；因此最差空间复杂度为 $O(n)$ 。\n2. **以算法运行中的峰值内存为准**：例如，程序在执行最后一行之前，占用 $O(1)$ 空间；当初始化数组 `nums` 时，程序占用 $O(n)$ 空间；因此最差空间复杂度为 $O(n)$ 。\n\n=== \"Python\"\n\n    ```python title=\"\"\n    def algorithm(n: int):\n        a = 0               # O(1)\n        b = [0] * 10000     # O(1)\n        if n > 10:\n            nums = [0] * n  # O(n)\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"\"\n    void algorithm(int n) {\n        int a = 0;               // O(1)\n        vector<int> b(10000);    // O(1)\n        if (n > 10)\n            vector<int> nums(n); // O(n)\n    }\n    ```\n\n=== \"Java\"\n\n    ```java title=\"\"\n    void algorithm(int n) {\n        int a = 0;                   // O(1)\n        int[] b = new int[10000];    // O(1)\n        if (n > 10)\n            int[] nums = new int[n]; // O(n)\n    }\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"\"\n    void Algorithm(int n) {\n        int a = 0;                   // O(1)\n        int[] b = new int[10000];    // O(1)\n        if (n > 10) {\n            int[] nums = new int[n]; // O(n)\n        }\n    }\n    ```\n\n=== \"Go\"\n\n    ```go title=\"\"\n    func algorithm(n int) {\n        a := 0                      // O(1)\n        b := make([]int, 10000)     // O(1)\n        var nums []int\n        if n > 10 {\n            nums := make([]int, n)  // O(n)\n        }\n        fmt.Println(a, b, nums)\n    }\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"\"\n    func algorithm(n: Int) {\n        let a = 0 // O(1)\n        let b = Array(repeating: 0, count: 10000) // O(1)\n        if n > 10 {\n            let nums = Array(repeating: 0, count: n) // O(n)\n        }\n    }\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"\"\n    function algorithm(n) {\n        const a = 0;                   // O(1)\n        const b = new Array(10000);    // O(1)\n        if (n > 10) {\n            const nums = new Array(n); // O(n)\n        }\n    }\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"\"\n    function algorithm(n: number): void {\n        const a = 0;                   // O(1)\n        const b = new Array(10000);    // O(1)\n        if (n > 10) {\n            const nums = new Array(n); // O(n)\n        }\n    }\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"\"\n    void algorithm(int n) {\n      int a = 0;                            // O(1)\n      List<int> b = List.filled(10000, 0);  // O(1)\n      if (n > 10) {\n        List<int> nums = List.filled(n, 0); // O(n)\n      }\n    }\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"\"\n    fn algorithm(n: i32) {\n        let a = 0;                              // O(1)\n        let b = [0; 10000];                     // O(1)\n        if n > 10 {\n            let nums = vec![0; n as usize];     // O(n)\n        }\n    }\n    ```\n\n=== \"C\"\n\n    ```c title=\"\"\n    void algorithm(int n) {\n        int a = 0;               // O(1)\n        int b[10000];            // O(1)\n        if (n > 10)\n            int nums[n] = {0};   // O(n)\n    }\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"\"\n\n    ```\n\n**在递归函数中，需要注意统计栈帧空间**。例如在以下代码中：\n\n- 函数 `loop()` 在循环中调用了 $n$ 次 `function()` ，每轮中的 `function()` 都返回并释放了栈帧空间，因此空间复杂度仍为 $O(1)$ 。\n- 递归函数 `recur()` 在运行过程中会同时存在 $n$ 个未返回的 `recur()` ，从而占用 $O(n)$ 的栈帧空间。\n\n=== \"Python\"\n\n    ```python title=\"\"\n    def function() -> int:\n        # 执行某些操作\n        return 0\n\n    def loop(n: int):\n        \"\"\"循环 O(1)\"\"\"\n        for _ in range(n):\n            function()\n\n    def recur(n: int) -> int:\n        \"\"\"递归 O(n)\"\"\"\n        if n == 1: return\n        return recur(n - 1)\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"\"\n    int func() {\n        // 执行某些操作\n        return 0;\n    }\n    /* 循环 O(1) */\n    void loop(int n) {\n        for (int i = 0; i < n; i++) {\n            func();\n        }\n    }\n    /* 递归 O(n) */\n    void recur(int n) {\n        if (n == 1) return;\n        return recur(n - 1);\n    }\n    ```\n\n=== \"Java\"\n\n    ```java title=\"\"\n    int function() {\n        // 执行某些操作\n        return 0;\n    }\n    /* 循环 O(1) */\n    void loop(int n) {\n        for (int i = 0; i < n; i++) {\n            function();\n        }\n    }\n    /* 递归 O(n) */\n    void recur(int n) {\n        if (n == 1) return;\n        return recur(n - 1);\n    }\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"\"\n    int Function() {\n        // 执行某些操作\n        return 0;\n    }\n    /* 循环 O(1) */\n    void Loop(int n) {\n        for (int i = 0; i < n; i++) {\n            Function();\n        }\n    }\n    /* 递归 O(n) */\n    int Recur(int n) {\n        if (n == 1) return 1;\n        return Recur(n - 1);\n    }\n    ```\n\n=== \"Go\"\n\n    ```go title=\"\"\n    func function() int {\n        // 执行某些操作\n        return 0\n    }\n    \n    /* 循环 O(1) */\n    func loop(n int) {\n        for i := 0; i < n; i++ {\n            function()\n        }\n    }\n    \n    /* 递归 O(n) */\n    func recur(n int) {\n        if n == 1 {\n            return\n        }\n        recur(n - 1)\n    }\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"\"\n    @discardableResult\n    func function() -> Int {\n        // 执行某些操作\n        return 0\n    }\n\n    /* 循环 O(1) */\n    func loop(n: Int) {\n        for _ in 0 ..< n {\n            function()\n        }\n    }\n\n    /* 递归 O(n) */\n    func recur(n: Int) {\n        if n == 1 {\n            return\n        }\n        recur(n: n - 1)\n    }\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"\"\n    function constFunc() {\n        // 执行某些操作\n        return 0;\n    }\n    /* 循环 O(1) */\n    function loop(n) {\n        for (let i = 0; i < n; i++) {\n            constFunc();\n        }\n    }\n    /* 递归 O(n) */\n    function recur(n) {\n        if (n === 1) return;\n        return recur(n - 1);\n    }\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"\"\n    function constFunc(): number {\n        // 执行某些操作\n        return 0;\n    }\n    /* 循环 O(1) */\n    function loop(n: number): void {\n        for (let i = 0; i < n; i++) {\n            constFunc();\n        }\n    }\n    /* 递归 O(n) */\n    function recur(n: number): void {\n        if (n === 1) return;\n        return recur(n - 1);\n    }\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"\"\n    int function() {\n      // 执行某些操作\n      return 0;\n    }\n    /* 循环 O(1) */\n    void loop(int n) {\n      for (int i = 0; i < n; i++) {\n        function();\n      }\n    }\n    /* 递归 O(n) */\n    void recur(int n) {\n      if (n == 1) return;\n      return recur(n - 1);\n    }\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"\"\n    fn function() -> i32 {\n        // 执行某些操作\n        return 0;\n    }\n    /* 循环 O(1) */\n    fn loop(n: i32) {\n        for i in 0..n {\n            function();\n        }\n    }\n    /* 递归 O(n) */\n    void recur(n: i32) {\n        if n == 1 {\n            return;\n        }\n        recur(n - 1);\n    }\n    ```\n\n=== \"C\"\n\n    ```c title=\"\"\n    int func() {\n        // 执行某些操作\n        return 0;\n    }\n    /* 循环 O(1) */\n    void loop(int n) {\n        for (int i = 0; i < n; i++) {\n            func();\n        }\n    }\n    /* 递归 O(n) */\n    void recur(int n) {\n        if (n == 1) return;\n        return recur(n - 1);\n    }\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"\"\n\n    ```",
          "questions": [
            "在空间复杂度的推算中，为什么通常只关注最差空间复杂度？",
            "在代码示例中，为什么当 n > 10 时，初始化的数组 nums 占用 O(n) 空间？",
            "在递归函数中，为什么需要注意统计栈帧空间？",
            "在 Python 中，如何定义一个返回值为 int 类型的函数？",
            "在 C++ 中，如何定义一个返回值为 int 类型的函数？",
            "在 Java 中，如何定义一个返回值为 int 类型的函数？",
            "在 Go 中，如何定义一个返回值为 int 类型的函数？",
            "在 Swift 中，如何定义一个返回值为 Int 类型的函数？",
            "在 JS 中，如何定义一个返回值为 number 类型的函数？",
            "在 Dart 中，如何定义一个返回值为 int 类型的函数？"
          ]
        },
        {
          "content": "## 常见类型\n\n设输入数据大小为 $n$ ，下图展示了常见的空间复杂度类型（从低到高排列）。\n\n$$\n\\begin{aligned}\nO(1) < O(\\log n) < O(n) < O(n^2) < O(2^n) \\newline\n\\text{常数阶} < \\text{对数阶} < \\text{线性阶} < \\text{平方阶} < \\text{指数阶}\n\\end{aligned}\n$$\n\n![常见的空间复杂度类型](space_complexity.assets/space_complexity_common_types.png)\n\n### 常数阶 $O(1)$\n\n常数阶常见于数量与输入数据大小 $n$ 无关的常量、变量、对象。\n\n需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 $O(1)$ ：\n\n```src\n[file]{space_complexity}-[class]{}-[func]{constant}\n```\n\n### 线性阶 $O(n)$\n\n线性阶常见于元素数量与 $n$ 成正比的数组、链表、栈、队列等：\n\n```src\n[file]{space_complexity}-[class]{}-[func]{linear}\n```\n\n如下图所示，此函数的递归深度为 $n$ ，即同时存在 $n$ 个未返回的 `linear_recur()` 函数，使用 $O(n)$ 大小的栈帧空间：\n\n```src\n[file]{space_complexity}-[class]{}-[func]{linear_recur}\n```\n\n![递归函数产生的线性阶空间复杂度](space_complexity.assets/space_complexity_recursive_linear.png)\n\n### 平方阶 $O(n^2)$\n\n平方阶常见于矩阵和图，元素数量与 $n$ 成平方关系：\n\n```src\n[file]{space_complexity}-[class]{}-[func]{quadratic}\n```\n\n如下图所示，该函数的递归深度为 $n$ ，在每个递归函数中都初始化了一个数组，长度分别为 $n$、$n-1$、$\\dots$、$2$、$1$ ，平均长度为 $n / 2$ ，因此总体占用 $O(n^2)$ 空间：\n\n```src\n[file]{space_complexity}-[class]{}-[func]{quadratic_recur}\n```\n\n![递归函数产生的平方阶空间复杂度](space_complexity.assets/space_complexity_recursive_quadratic.png)\n\n### 指数阶 $O(2^n)$\n\n指数阶常见于二叉树。观察下图，高度为 $n$ 的“满二叉树”的节点数量为 $2^n - 1$ ，占用 $O(2^n)$ 空间：\n\n```src\n[file]{space_complexity}-[class]{}-[func]{build_tree}\n```\n\n![满二叉树产生的指数阶空间复杂度](space_complexity.assets/space_complexity_exponential.png)\n\n### 对数阶 $O(\\log n)$\n\n对数阶常见于分治算法。例如归并排序，输入长度为 $n$ 的数组，每轮递归将数组从中点划分为两半，形成高度为 $\\log n$ 的递归树，使用 $O(\\log n)$ 栈帧空间。\n\n再例如将数字转化为字符串，输入一个正整数 $n$ ，它的位数为 $\\log_{10} n + 1$ ，即对应字符串长度为 $\\log_{10} n + 1$ ，因此空间复杂度为 $O(\\log_{10} n + 1) = O(\\log n)$ 。\n\n## 权衡时间与空间\n\n理想情况下，我们希望算法的时间复杂度和空间复杂度都能达到最优。然而在实际情况中，同时优化时间复杂度和空间复杂度通常是非常困难的。\n\n**降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然**。我们将牺牲内存空间来提升算法运行速度的思路称为“以空间换时间”；反之，则称为“以时间换空间”。\n\n选择哪种思路取决于我们更看重哪个方面。在大多数情况下，时间比空间更宝贵，因此“以空间换时间”通常是更常用的策略。当然，在数据量很大的情况下，控制空间复杂度也是非常重要的。",
          "questions": [
            "常数阶空间复杂度常见于哪些变量、常量、对象？",
            "在循环中初始化变量或调用函数会占用内存吗？会对空间复杂度产生影响吗？",
            "线性阶空间复杂度常见于哪些数据结构？",
            "递归函数产生的空间复杂度是什么？如何计算？",
            "平方阶空间复杂度常见于哪些数据结构？",
            "指数阶空间复杂度常见于哪些数据结构？",
            "分治算法的空间复杂度是什么？以归并排序为例，如何计算空间复杂度？",
            "以空间换时间和以时间换空间的思路分别是什么？在什么情况下应该选择哪种思路？",
            "在大多数情况下，时间比空间更宝贵，这句话正确吗？为什么？",
            "数字转化为字符串的空间复杂度是多少？如何计算？"
          ]
        }
      ]
    },
    {
      "file_name": "radix_sort.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 基数排序\n\n上一节我们介绍了计数排序，它适用于数据量 $n$ 较大但数据范围 $m$ 较小的情况。假设我们需要对 $n = 10^6$ 个学号进行排序，而学号是一个 $8$ 位数字，这意味着数据范围 $m = 10^8$ 非常大，使用计数排序需要分配大量内存空间，而基数排序可以避免这种情况。\n\n「基数排序 radix sort」的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。\n\n## 算法流程\n\n以学号数据为例，假设数字的最低位是第 $1$ 位，最高位是第 $8$ 位，基数排序的流程如下图所示。\n\n1. 初始化位数 $k = 1$ 。\n2. 对学号的第 $k$ 位执行“计数排序”。完成后，数据会根据第 $k$ 位从小到大排序。\n3. 将 $k$ 增加 $1$ ，然后返回步骤 `2.` 继续迭代，直到所有位都排序完成后结束。\n\n![基数排序算法流程](radix_sort.assets/radix_sort_overview.png)\n\n下面来剖析代码实现。对于一个 $d$ 进制的数字 $x$ ，要获取其第 $k$ 位 $x_k$ ，可以使用以下计算公式：\n\n$$\nx_k = \\lfloor\\frac{x}{d^{k-1}}\\rfloor \\bmod d\n$$\n\n其中 $\\lfloor a \\rfloor$ 表示对浮点数 $a$ 向下取整，而 $\\bmod \\: d$ 表示对 $d$ 取余。对于学号数据，$d = 10$ 且 $k \\in [1, 8]$ 。\n\n此外，我们需要小幅改动计数排序代码，使之可以根据数字的第 $k$ 位进行排序。\n\n```src\n[file]{radix_sort}-[class]{}-[func]{radix_sort}\n```\n\n!!! question \"为什么从最低位开始排序？\"\n\n    在连续的排序轮次中，后一轮排序会覆盖前一轮排序的结果。举例来说，如果第一轮排序结果 $a < b$ ，而第二轮排序结果 $a > b$ ，那么第二轮的结果将取代第一轮的结果。由于数字的高位优先级高于低位，我们应该先排序低位再排序高位。\n\n## 算法特性\n\n相较于计数排序，基数排序适用于数值范围较大的情况，**但前提是数据必须可以表示为固定位数的格式，且位数不能过大**。例如，浮点数不适合使用基数排序，因为其位数 $k$ 过大，可能导致时间复杂度 $O(nk) \\gg O(n^2)$ 。\n\n- **时间复杂度 $O(nk)$**：设数据量为 $n$、数据为 $d$ 进制、最大位数为 $k$ ，则对某一位执行计数排序使用 $O(n + d)$ 时间，排序所有 $k$ 位使用 $O((n + d)k)$ 时间。通常情况下，$d$ 和 $k$ 都相对较小，时间复杂度趋向 $O(n)$ 。\n- **空间复杂度 $O(n + d)$、非原地排序**：与计数排序相同，基数排序需要借助长度为 $n$ 和 $d$ 的数组 `res` 和 `counter` 。\n- **稳定排序**：与计数排序相同。",
          "questions": [
            "基数排序与计数排序的核心思想有何不同？",
            "基数排序适用于什么样的数据范围？",
            "为什么基数排序可以避免计数排序需要分配大量内存空间的问题？",
            "基数排序的算法流程是怎样的？",
            "如何获取一个d进制数字x的第k位xk？",
            "为什么从最低位开始排序？",
            "什么样的数据不适合使用基数排序？",
            "基数排序的时间复杂度是多少？",
            "基数排序的空间复杂度是多少？是否为原地排序？",
            "基数排序是稳定排序吗？"
          ]
        }
      ]
    },
    {
      "file_name": "summary.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 小结\n\n### 重点回顾\n\n- 栈是一种遵循先入后出原则的数据结构，可通过数组或链表来实现。\n- 从时间效率角度看，栈的数组实现具有较高的平均效率，但在扩容过程中，单次入栈操作的时间复杂度会劣化至 $O(n)$ 。相比之下，基于链表实现的栈具有更为稳定的效率表现。\n- 在空间效率方面，栈的数组实现可能导致一定程度的空间浪费。但需要注意的是，链表节点所占用的内存空间比数组元素更大。\n- 队列是一种遵循先入先出原则的数据结构，同样可以通过数组或链表来实现。在时间效率和空间效率的对比上，队列的结论与前述栈的结论相似。\n- 双向队列是一种具有更高自由度的队列，它允许在两端进行元素的添加和删除操作。\n\n### Q & A\n\n!!! question \"浏览器的前进后退是否是双向链表实现？\"\n\n    浏览器的前进后退功能本质上是“栈”的体现。当用户访问一个新页面时，该页面会被添加到栈顶；当用户点击后退按钮时，该页面会从栈顶弹出。使用双向队列可以方便实现一些额外操作，这个在双向队列章节有提到。\n\n!!! question \"在出栈后，是否需要释放出栈节点的内存？\"\n\n    如果后续仍需要使用弹出节点，则不需要释放内存。若之后不需要用到，`Java` 和 `Python` 等语言拥有自动垃圾回收机制，因此不需要手动释放内存；在 `C` 和 `C++` 中需要手动释放内存。\n\n!!! question \"双向队列像是两个栈拼接在了一起，它的用途是什么？\"\n\n    双向队列就像是栈和队列的组合，或者是两个栈拼在了一起。它表现的是栈 + 队列的逻辑，因此可以实现栈与队列的所有应用，并且更加灵活。\n\n!!! question \"撤销（undo）和反撤销（redo）具体是如何实现的？\"\n\n    使用两个堆栈，栈 `A` 用于撤销，栈 `B` 用于反撤销。\n\n    1. 每当用户执行一个操作，将这个操作压入栈 `A` ，并清空栈 `B` 。\n    2. 当用户执行“撤销”时，从栈 `A` 中弹出最近的操作，并将其压入栈 `B` 。\n    3. 当用户执行“反撤销”时，从栈 `B` 中弹出最近的操作，并将其压入栈 `A` 。",
          "questions": [
            "浏览器的前进后退功能本质上是哪种数据结构的体现？",
            "栈可以通过哪些数据结构来实现？",
            "基于数组实现的栈在扩容过程中，单次入栈操作的时间复杂度会劣化至多少？",
            "队列是一种遵循什么原则的数据结构？",
            "双向队列允许在哪两端进行元素的添加和删除操作？",
            "在出栈后，是否需要手动释放出栈节点的内存？",
            "哪些语言拥有自动垃圾回收机制，不需要手动释放内存？",
            "双向队列表现的是哪两种数据结构的逻辑组合？",
            "撤销和反撤销是如何实现的？",
            "使用哪些数据结构可以实现撤销和反撤销功能？"
          ]
        }
      ]
    },
    {
      "file_name": "searching_algorithm_revisited.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 重识搜索算法\n\n「搜索算法 searching algorithm」用于在数据结构（例如数组、链表、树或图）中搜索一个或一组满足特定条件的元素。\n\n搜索算法可根据实现思路分为以下两类。\n\n- **通过遍历数据结构来定位目标元素**，例如数组、链表、树和图的遍历等。\n- **利用数据组织结构或数据包含的先验信息，实现高效元素查找**，例如二分查找、哈希查找和二叉搜索树查找等。\n\n不难发现，这些知识点都已在前面的章节中介绍过，因此搜索算法对于我们来说并不陌生。在本节中，我们将从更加系统的视角切入，重新审视搜索算法。\n\n## 暴力搜索\n\n暴力搜索通过遍历数据结构的每个元素来定位目标元素。\n\n- “线性搜索”适用于数组和链表等线性数据结构。它从数据结构的一端开始，逐个访问元素，直到找到目标元素或到达另一端仍没有找到目标元素为止。\n- “广度优先搜索”和“深度优先搜索”是图和树的两种遍历策略。广度优先搜索从初始节点开始逐层搜索，由近及远地访问各个节点。深度优先搜索是从初始节点开始，沿着一条路径走到头为止，再回溯并尝试其他路径，直到遍历完整个数据结构。\n\n暴力搜索的优点是简单且通用性好，**无须对数据做预处理和借助额外的数据结构**。\n\n然而，**此类算法的时间复杂度为 $O(n)$** ，其中 $n$ 为元素数量，因此在数据量较大的情况下性能较差。\n\n## 自适应搜索\n\n自适应搜索利用数据的特有属性（例如有序性）来优化搜索过程，从而更高效地定位目标元素。\n\n- “二分查找”利用数据的有序性实现高效查找，仅适用于数组。\n- “哈希查找”利用哈希表将搜索数据和目标数据建立为键值对映射，从而实现查询操作。\n- “树查找”在特定的树结构（例如二叉搜索树）中，基于比较节点值来快速排除节点，从而定位目标元素。\n\n此类算法的优点是效率高，**时间复杂度可达到 $O(\\log n)$ 甚至 $O(1)$** 。\n\n然而，**使用这些算法往往需要对数据进行预处理**。例如，二分查找需要预先对数组进行排序，哈希查找和树查找都需要借助额外的数据结构，维护这些数据结构也需要额外的时间和空间开支。\n\n!!! note\n\n    自适应搜索算法常被称为查找算法，**主要关注在特定数据结构中快速检索目标元素**。\n\n## 搜索方法选取\n\n给定大小为 $n$ 的一组数据，我们可以使用线性搜索、二分查找、树查找、哈希查找等多种方法在该数据中搜索目标元素。各个方法的工作原理如下图所示。\n\n![多种搜索策略](searching_algorithm_revisited.assets/searching_algorithms.png)\n\n上述几种方法的操作效率与特性如下表所示。\n\n<p align=\"center\"> 表 <id> &nbsp; 查找算法效率对比 </p>\n\n|              | 线性搜索 | 二分查找           | 树查找             | 哈希查找        |\n| ------------ | -------- | ------------------ | ------------------ | --------------- |\n| 查找元素     | $O(n)$   | $O(\\log n)$        | $O(\\log n)$        | $O(1)$          |\n| 插入元素     | $O(1)$   | $O(n)$             | $O(\\log n)$        | $O(1)$          |\n| 删除元素     | $O(n)$   | $O(n)$             | $O(\\log n)$        | $O(1)$          |\n| 额外空间     | $O(1)$   | $O(1)$             | $O(n)$             | $O(n)$          |\n| 数据预处理   | /        | 排序 $O(n \\log n)$ | 建树 $O(n \\log n)$ | 建哈希表 $O(n)$ |\n| 数据是否有序 | 无序     | 有序               | 有序               | 无序            |\n\n搜索算法的选择还取决于数据体量、搜索性能要求、数据查询与更新频率等。\n\n**线性搜索**\n\n- 通用性较好，无须任何数据预处理操作。假如我们仅需查询一次数据，那么其他三种方法的数据预处理的时间比线性搜索的时间还要更长。\n- 适用于体量较小的数据，此情况下时间复杂度对效率影响较小。\n- 适用于数据更新频率较高的场景，因为该方法不需要对数据进行任何额外维护。\n\n**二分查找**\n\n- 适用于大数据量的情况，效率表现稳定，最差时间复杂度为 $O(\\log n)$ 。\n- 数据量不能过大，因为存储数组需要连续的内存空间。\n- 不适用于高频增删数据的场景，因为维护有序数组的开销较大。\n\n**哈希查找**\n\n- 适合对查询性能要求很高的场景，平均时间复杂度为 $O(1)$ 。\n- 不适合需要有序数据或范围查找的场景，因为哈希表无法维护数据的有序性。\n- 对哈希函数和哈希冲突处理策略的依赖性较高，具有较大的性能劣化风险。\n- 不适合数据量过大的情况，因为哈希表需要额外空间来最大程度地减少冲突，从而提供良好的查询性能。\n\n**树查找**\n\n- 适用于海量数据，因为树节点在内存中是分散存储的。\n- 适合需要维护有序数据或范围查找的场景。\n- 在持续增删节点的过程中，二叉搜索树可能产生倾斜，时间复杂度劣化至 $O(n)$ 。\n- 若使用 AVL 树或红黑树，则各项操作可在 $O(\\log n)$ 效率下稳定运行，但维护树平衡的操作会增加额外开销。",
          "questions": [
            "什么是搜索算法？它们可以用于哪些数据结构？",
            "暴力搜索的优点和缺点是什么？它的时间复杂度是多少？",
            "自适应搜索的优点和缺点是什么？它的时间复杂度可以达到多少？",
            "什么是线性搜索？它适用于哪些数据结构和场景？",
            "什么是二分查找？它适用于哪些数据结构和场景？它的时间复杂度是多少？",
            "什么是哈希查找？它适用于哪些数据结构和场景？它的时间复杂度是多少？",
            "什么是树查找？它适用于哪些数据结构和场景？它的时间复杂度是多少？",
            "在多种搜索策略中，各个方法的操作效率和特性有哪些？它们的时间复杂度分别是多少？",
            "搜索算法的选择取决于哪些因素？如何根据数据体量、搜索性能要求、数据查询与更新频率等选择合适的搜索算法？",
            "在使用树查找时，为什么需要维护树的平衡？使用 AVL 树或红黑树的优缺点是什么？"
          ]
        }
      ]
    },
    {
      "file_name": "unbounded_knapsack_problem.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 完全背包问题\n\n在本节中，我们先求解另一个常见的背包问题：完全背包，再了解它的一种特例：零钱兑换。\n\n## 完全背包\n\n!!! question\n\n    给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i-1]$、价值为 $val[i-1]$ ，和一个容量为 $cap$ 的背包。**每个物品可以重复选取**，问在不超过背包容量下能放入物品的最大价值。\n\n![完全背包问题的示例数据](unbounded_knapsack_problem.assets/unbounded_knapsack_example.png)\n\n### 动态规划思路\n\n完全背包和 0-1 背包问题非常相似，**区别仅在于不限制物品的选择次数**。\n\n- 在 0-1 背包中，每个物品只有一个，因此将物品 $i$ 放入背包后，只能从前 $i-1$ 个物品中选择。\n- 在完全背包中，每个物品有无数个，因此将物品 $i$ 放入背包后，**仍可以从前 $i$ 个物品中选择**。\n\n在完全背包的规定下，状态 $[i, c]$ 的变化分为两种情况。\n\n- **不放入物品 $i$** ：与 0-1 背包相同，转移至 $[i-1, c]$ 。\n- **放入物品 $i$** ：与 0-1 背包不同，转移至 $[i, c-wgt[i-1]]$ 。\n\n从而状态转移方程变为：\n\n$$\ndp[i, c] = \\max(dp[i-1, c], dp[i, c - wgt[i-1]] + val[i-1])\n$$\n\n### 代码实现\n\n对比两道题目的代码，状态转移中有一处从 $i-1$ 变为 $i$ ，其余完全一致。\n\n```src\n[file]{unbounded_knapsack}-[class]{}-[func]{unbounded_knapsack_dp}\n```\n\n### 空间优化\n\n由于当前状态是从左边和上边的状态转移而来，**因此空间优化后应该对 $dp$ 表中的每一行采取正序遍历**。\n\n这个遍历顺序与 0-1 背包正好相反。请借助下图来理解两者的区别。\n\n=== \"<1>\"\n    ![完全背包的空间优化后的动态规划过程](unbounded_knapsack_problem.assets/unbounded_knapsack_dp_comp_step1.png)\n\n=== \"<2>\"\n    ![unbounded_knapsack_dp_comp_step2](unbounded_knapsack_problem.assets/unbounded_knapsack_dp_comp_step2.png)\n\n=== \"<3>\"\n    ![unbounded_knapsack_dp_comp_step3](unbounded_knapsack_problem.assets/unbounded_knapsack_dp_comp_step3.png)\n\n=== \"<4>\"\n    ![unbounded_knapsack_dp_comp_step4](unbounded_knapsack_problem.assets/unbounded_knapsack_dp_comp_step4.png)\n\n=== \"<5>\"\n    ![unbounded_knapsack_dp_comp_step5](unbounded_knapsack_problem.assets/unbounded_knapsack_dp_comp_step5.png)\n\n=== \"<6>\"\n    ![unbounded_knapsack_dp_comp_step6](unbounded_knapsack_problem.assets/unbounded_knapsack_dp_comp_step6.png)\n\n代码实现比较简单，仅需将数组 `dp` 的第一维删除。\n\n```src\n[file]{unbounded_knapsack}-[class]{}-[func]{unbounded_knapsack_dp_comp}\n```\n\n## 零钱兑换问题\n\n背包问题是一大类动态规划问题的代表，其拥有很多的变种，例如零钱兑换问题。\n\n!!! question\n\n    给定 $n$ 种硬币，第 $i$ 种硬币的面值为 $coins[i - 1]$ ，目标金额为 $amt$ ，**每种硬币可以重复选取**，问能够凑出目标金额的最少硬币个数。如果无法凑出目标金额则返回 $-1$ 。\n\n![零钱兑换问题的示例数据](unbounded_knapsack_problem.assets/coin_change_example.png)\n\n### 动态规划思路\n\n**零钱兑换可以看作是完全背包的一种特殊情况**，两者具有以下联系与不同点。\n\n- 两道题可以相互转换，“物品”对应于“硬币”、“物品重量”对应于“硬币面值”、“背包容量”对应于“目标金额”。\n- 优化目标相反，背包问题是要最大化物品价值，零钱兑换问题是要最小化硬币数量。\n- 背包问题是求“不超过”背包容量下的解，零钱兑换是求“恰好”凑到目标金额的解。\n\n**第一步：思考每轮的决策，定义状态，从而得到 $dp$ 表**\n\n状态 $[i, a]$ 对应的子问题为：**前 $i$ 种硬币能够凑出金额 $a$ 的最少硬币个数**，记为 $dp[i, a]$ 。\n\n二维 $dp$ 表的尺寸为 $(n+1) \\times (amt+1)$ 。\n\n**第二步：找出最优子结构，进而推导出状态转移方程**\n\n本题与完全背包的状态转移方程存在以下两个差异。\n\n- 本题要求最小值，因此需将运算符 $\\max()$ 更改为 $\\min()$ 。\n- 优化主体是硬币数量而非商品价值，因此在选中硬币时执行 $+1$ 即可。\n\n$$\ndp[i, a] = \\min(dp[i-1, a], dp[i, a - coins[i-1]] + 1)\n$$\n\n**第三步：确定边界条件和状态转移顺序**\n\n当目标金额为 $0$ 时，凑出它的最少硬币个数为 $0$ ，即首列所有 $dp[i, 0]$ 都等于 $0$ 。\n\n当无硬币时，**无法凑出任意 $> 0$ 的目标金额**，即是无效解。为使状态转移方程中的 $\\min()$ 函数能够识别并过滤无效解，我们考虑使用 $+ \\infty$ 来表示它们，即令首行所有 $dp[0, a]$ 都等于 $+ \\infty$ 。\n\n### 代码实现\n\n大多数编程语言并未提供 $+ \\infty$ 变量，只能使用整型 `int` 的最大值来代替。而这又会导致大数越界：状态转移方程中的 $+ 1$ 操作可能发生溢出。\n\n为此，我们采用数字 $amt + 1$ 来表示无效解，因为凑出 $amt$ 的硬币个数最多为 $amt$ 个。\n\n最后返回前，判断 $dp[n, amt]$ 是否等于 $amt + 1$ ，若是则返回 $-1$ ，代表无法凑出目标金额。\n\n```src\n[file]{coin_change}-[class]{}-[func]{coin_change_dp}\n```\n\n下图展示了零钱兑换的动态规划过程，和完全背包非常相似。\n\n=== \"<1>\"\n    ![零钱兑换问题的动态规划过程](unbounded_knapsack_problem.assets/coin_change_dp_step1.png)\n\n=== \"<2>\"\n    ![coin_change_dp_step2](unbounded_knapsack_problem.assets/coin_change_dp_step2.png)\n\n=== \"<3>\"\n    ![coin_change_dp_step3](unbounded_knapsack_problem.assets/coin_change_dp_step3.png)\n\n=== \"<4>\"\n    ![coin_change_dp_step4](unbounded_knapsack_problem.assets/coin_change_dp_step4.png)\n\n=== \"<5>\"\n    ![coin_change_dp_step5](unbounded_knapsack_problem.assets/coin_change_dp_step5.png)\n\n=== \"<6>\"\n    ![coin_change_dp_step6](unbounded_knapsack_problem.assets/coin_change_dp_step6.png)\n\n=== \"<7>\"\n    ![coin_change_dp_step7](unbounded_knapsack_problem.assets/coin_change_dp_step7.png)\n\n=== \"<8>\"\n    ![coin_change_dp_step8](unbounded_knapsack_problem.assets/coin_change_dp_step8.png)\n\n=== \"<9>\"\n    ![coin_change_dp_step9](unbounded_knapsack_problem.assets/coin_change_dp_step9.png)\n\n=== \"<10>\"\n    ![coin_change_dp_step10](unbounded_knapsack_problem.assets/coin_change_dp_step10.png)\n\n=== \"<11>\"\n    ![coin_change_dp_step11](unbounded_knapsack_problem.assets/coin_change_dp_step11.png)\n\n=== \"<12>\"\n    ![coin_change_dp_step12](unbounded_knapsack_problem.assets/coin_change_dp_step12.png)\n\n=== \"<13>\"\n    ![coin_change_dp_step13](unbounded_knapsack_problem.assets/coin_change_dp_step13.png)\n\n=== \"<14>\"\n    ![coin_change_dp_step14](unbounded_knapsack_problem.assets/coin_change_dp_step14.png)\n\n=== \"<15>\"\n    ![coin_change_dp_step15](unbounded_knapsack_problem.assets/coin_change_dp_step15.png)\n\n### 空间优化\n\n零钱兑换的空间优化的处理方式和完全背包一致。\n\n```src\n[file]{coin_change}-[class]{}-[func]{coin_change_dp_comp}\n```\n\n## 零钱兑换问题 II\n\n!!! question\n\n    给定 $n$ 种硬币，第 $i$ 种硬币的面值为 $coins[i - 1]$ ，目标金额为 $amt$ ，每种硬币可以重复选取，**问在凑出目标金额的硬币组合数量**。\n\n![零钱兑换问题 II 的示例数据](unbounded_knapsack_problem.assets/coin_change_ii_example.png)",
          "questions": [
            "什么是完全背包问题？与 0-1 背包问题有何不同？",
            "完全背包问题的状态转移方程是什么？为什么与 0-1 背包问题不同？",
            "如何对完全背包问题进行空间优化？",
            "什么是零钱兑换问题？与完全背包问题有何联系和不同点？",
            "零钱兑换问题的状态转移方程是什么？为什么要使用 $+ \\infty$ 表示无效解？",
            "如何对零钱兑换问题进行空间优化？",
            "什么是零钱兑换问题 II？与零钱兑换问题有何不同？",
            "零钱兑换问题 II 的状态转移方程是什么？为什么要使用 $+=$ 运算符？",
            "如何判断无法凑出目标金额的情况？",
            "如何对零钱兑换问题 II 进行空间优化？"
          ]
        },
        {
          "content": "### 动态规划思路\n\n相比于上一题，本题目标是组合数量，因此子问题变为：**前 $i$ 种硬币能够凑出金额 $a$ 的组合数量**。而 $dp$ 表仍然是尺寸为 $(n+1) \\times (amt + 1)$ 的二维矩阵。\n\n当前状态的组合数量等于不选当前硬币与选当前硬币这两种决策的组合数量之和。状态转移方程为：\n\n$$\ndp[i, a] = dp[i-1, a] + dp[i, a - coins[i-1]]\n$$\n\n当目标金额为 $0$ 时，无须选择任何硬币即可凑出目标金额，因此应将首列所有 $dp[i, 0]$ 都初始化为 $1$ 。当无硬币时，无法凑出任何 $>0$ 的目标金额，因此首行所有 $dp[0, a]$ 都等于 $0$ 。\n\n### 代码实现\n\n```src\n[file]{coin_change_ii}-[class]{}-[func]{coin_change_ii_dp}\n```\n\n### 空间优化\n\n空间优化处理方式相同，删除硬币维度即可。\n\n```src\n[file]{coin_change_ii}-[class]{}-[func]{coin_change_ii_dp_comp}\n```",
          "questions": [
            "本题目标是什么？",
            "本题中的子问题是什么？",
            "本题中的状态转移方程是什么？",
            "当目标金额为0时，应该如何初始化dp表？",
            "当无硬币时，应该如何初始化dp表？",
            "本题中的dp表的尺寸是多少？",
            "本题中的空间优化处理方式是什么？",
            "为什么要进行空间优化？",
            "本题中的硬币数量有限制吗？",
            "本题中的硬币面值有限制吗？"
          ]
        }
      ]
    },
    {
      "file_name": "graph_operations.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 图基础操作\n\n图的基础操作可分为对“边”的操作和对“顶点”的操作。在“邻接矩阵”和“邻接表”两种表示方法下，实现方式有所不同。\n\n## 基于邻接矩阵的实现\n\n给定一个顶点数量为 $n$ 的无向图，则各种操作的实现方式如下图所示。\n\n- **添加或删除边**：直接在邻接矩阵中修改指定的边即可，使用 $O(1)$ 时间。而由于是无向图，因此需要同时更新两个方向的边。\n- **添加顶点**：在邻接矩阵的尾部添加一行一列，并全部填 $0$ 即可，使用 $O(n)$ 时间。\n- **删除顶点**：在邻接矩阵中删除一行一列。当删除首行首列时达到最差情况，需要将 $(n-1)^2$ 个元素“向左上移动”，从而使用 $O(n^2)$ 时间。\n- **初始化**：传入 $n$ 个顶点，初始化长度为 $n$ 的顶点列表 `vertices` ，使用 $O(n)$ 时间；初始化 $n \\times n$ 大小的邻接矩阵 `adjMat` ，使用 $O(n^2)$ 时间。\n\n=== \"初始化邻接矩阵\"\n    ![邻接矩阵的初始化、增删边、增删顶点](graph_operations.assets/adjacency_matrix_initialization.png)\n\n=== \"添加边\"\n    ![adjacency_matrix_add_edge](graph_operations.assets/adjacency_matrix_add_edge.png)\n\n=== \"删除边\"\n    ![adjacency_matrix_remove_edge](graph_operations.assets/adjacency_matrix_remove_edge.png)\n\n=== \"添加顶点\"\n    ![adjacency_matrix_add_vertex](graph_operations.assets/adjacency_matrix_add_vertex.png)\n\n=== \"删除顶点\"\n    ![adjacency_matrix_remove_vertex](graph_operations.assets/adjacency_matrix_remove_vertex.png)\n\n以下是基于邻接矩阵表示图的实现代码。\n\n```src\n[file]{graph_adjacency_matrix}-[class]{graph_adj_mat}-[func]{}\n```\n\n## 基于邻接表的实现\n\n设无向图的顶点总数为 $n$、边总数为 $m$ ，则可根据下图所示的方法实现各种操作。\n\n- **添加边**：在顶点对应链表的末尾添加边即可，使用 $O(1)$ 时间。因为是无向图，所以需要同时添加两个方向的边。\n- **删除边**：在顶点对应链表中查找并删除指定边，使用 $O(m)$ 时间。在无向图中，需要同时删除两个方向的边。\n- **添加顶点**：在邻接表中添加一个链表，并将新增顶点作为链表头节点，使用 $O(1)$ 时间。\n- **删除顶点**：需遍历整个邻接表，删除包含指定顶点的所有边，使用 $O(n + m)$ 时间。\n- **初始化**：在邻接表中创建 $n$ 个顶点和 $2m$ 条边，使用 $O(n + m)$ 时间。\n\n=== \"初始化邻接表\"\n    ![邻接表的初始化、增删边、增删顶点](graph_operations.assets/adjacency_list_initialization.png)\n\n=== \"添加边\"\n    ![adjacency_list_add_edge](graph_operations.assets/adjacency_list_add_edge.png)\n\n=== \"删除边\"\n    ![adjacency_list_remove_edge](graph_operations.assets/adjacency_list_remove_edge.png)\n\n=== \"添加顶点\"\n    ![adjacency_list_add_vertex](graph_operations.assets/adjacency_list_add_vertex.png)\n\n=== \"删除顶点\"\n    ![adjacency_list_remove_vertex](graph_operations.assets/adjacency_list_remove_vertex.png)\n\n以下是基于邻接表实现图的代码示例。细心的同学可能注意到，**我们在邻接表中使用 `Vertex` 节点类来表示顶点**，而这样做是有原因的。\n\n1. 如果我们选择通过顶点值来区分不同顶点，那么值重复的顶点将无法被区分。\n2. 如果类似邻接矩阵那样，使用顶点列表索引来区分不同顶点。那么，假设我们想要删除索引为 $i$ 的顶点，则需要遍历整个邻接表，将其中 $> i$ 的索引全部减 $1$ ，这样操作效率较低。\n3. 因此我们考虑引入顶点类 `Vertex` ，使得每个顶点都是唯一的对象，此时删除顶点时就无须改动其余顶点了。\n\n```src\n[file]{graph_adjacency_list}-[class]{graph_adj_list}-[func]{}\n```\n\n## 效率对比\n\n设图中共有 $n$ 个顶点和 $m$ 条边，下表对比了邻接矩阵和邻接表的时间和空间效率。\n\n<p align=\"center\"> 表 <id> &nbsp; 邻接矩阵与邻接表对比 </p>\n\n|              | 邻接矩阵 | 邻接表（链表） | 邻接表（哈希表） |\n| ------------ | -------- | -------------- | ---------------- |\n| 判断是否邻接 | $O(1)$   | $O(m)$         | $O(1)$           |\n| 添加边       | $O(1)$   | $O(1)$         | $O(1)$           |\n| 删除边       | $O(1)$   | $O(m)$         | $O(1)$           |\n| 添加顶点     | $O(n)$   | $O(1)$         | $O(1)$           |\n| 删除顶点     | $O(n^2)$ | $O(n + m)$     | $O(n)$           |\n| 内存空间占用 | $O(n^2)$ | $O(n + m)$     | $O(n + m)$       |\n\n观察上表，似乎邻接表（哈希表）的时间与空间效率最优。但实际上，在邻接矩阵中操作边的效率更高，只需要一次数组访问或赋值操作即可。综合来看，邻接矩阵体现了“以空间换时间”的原则，而邻接表体现了“以时间换空间”的原则。",
          "questions": [
            "邻接矩阵和邻接表分别适用于什么样的图结构？",
            "在邻接矩阵中，如何添加或删除边？时间复杂度是多少？",
            "在邻接矩阵中，如何添加或删除顶点？时间复杂度是多少？",
            "在邻接表中，如何添加或删除边？时间复杂度是多少？",
            "在邻接表中，如何添加或删除顶点？时间复杂度是多少？",
            "邻接矩阵和邻接表的时间和空间效率有何区别？",
            "为什么在邻接表中使用 `Vertex` 节点类来表示顶点？",
            "邻接表中的链表和哈希表有何区别？",
            "邻接矩阵和邻接表的实现方式有何异同？",
            "邻接矩阵和邻接表的优缺点分别是什么？"
          ]
        }
      ]
    },
    {
      "file_name": "number_encoding.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 数字编码 *\n\n!!! note\n\n    在本书中，标题带有的 * 符号的是选读章节。如果你时间有限或感到理解困难，可以先跳过，等学完必读章节后再单独攻克。\n\n## 整数编码\n\n在上一节的表格中我们发现，所有整数类型能够表示的负数都比正数多一个，例如 `byte` 的取值范围是 $[-128, 127]$ 。这个现象比较反直觉，它的内在原因涉及到原码、反码、补码的相关知识。\n\n首先需要指出，**数字是以“补码”的形式存储在计算机中的**。在分析这样做的原因之前，我们首先给出三者的定义。\n\n- **原码**：我们将数字的二进制表示的最高位视为符号位，其中 $0$ 表示正数，$1$ 表示负数，其余位表示数字的值。\n- **反码**：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。\n- **补码**：正数的补码与其原码相同，负数的补码是在其反码的基础上加 $1$ 。\n\n下图展示了原码、反码和补码之间的转换方法。\n\n![原码、反码与补码之间的相互转换](number_encoding.assets/1s_2s_complement.png)\n\n「原码 true form」虽然最直观，但存在一些局限性。一方面，**负数的原码不能直接用于运算**。例如在原码下计算 $1 + (-2)$ ，得到的结果是 $-3$ ，这显然是不对的。\n\n$$\n\\begin{aligned}\n& 1 + (-2) \\newline\n& \\rightarrow 0000 \\; 0001 + 1000 \\; 0010 \\newline\n& = 1000 \\; 0011 \\newline\n& \\rightarrow -3\n\\end{aligned}\n$$\n\n为了解决此问题，计算机引入了「反码 1's complement code」。如果我们先将原码转换为反码，并在反码下计算 $1 + (-2)$ ，最后将结果从反码转化回原码，则可得到正确结果 $-1$ 。\n\n$$\n\\begin{aligned}\n& 1 + (-2) \\newline\n& \\rightarrow 0000 \\; 0001 \\; \\text{(原码)} + 1000 \\; 0010 \\; \\text{(原码)} \\newline\n& = 0000 \\; 0001 \\; \\text{(反码)} + 1111  \\; 1101 \\; \\text{(反码)} \\newline\n& = 1111 \\; 1110 \\; \\text{(反码)} \\newline\n& = 1000 \\; 0001 \\; \\text{(原码)} \\newline\n& \\rightarrow -1\n\\end{aligned}\n$$\n\n另一方面，**数字零的原码有 $+0$ 和 $-0$ 两种表示方式**。这意味着数字零对应着两个不同的二进制编码，其可能会带来歧义。比如在条件判断中，如果没有区分正零和负零，则可能会导致判断结果出错。而如果我们想要处理正零和负零歧义，则需要引入额外的判断操作，其可能会降低计算机的运算效率。\n\n$$\n\\begin{aligned}\n+0 & \\rightarrow 0000 \\; 0000 \\newline\n-0 & \\rightarrow 1000 \\; 0000\n\\end{aligned}\n$$\n\n与原码一样，反码也存在正负零歧义问题，因此计算机进一步引入了「补码 2's complement code」。我们先来观察一下负零的原码、反码、补码的转换过程：\n\n$$\n\\begin{aligned}\n-0 \\rightarrow \\; & 1000 \\; 0000 \\; \\text{(原码)} \\newline\n= \\; & 1111 \\; 1111 \\; \\text{(反码)} \\newline\n= 1 \\; & 0000 \\; 0000 \\; \\text{(补码)} \\newline\n\\end{aligned}\n$$\n\n在负零的反码基础上加 $1$ 会产生进位，但 `byte` 类型的长度只有 8 位，因此溢出到第 9 位的 $1$ 会被舍弃。也就是说，**负零的补码为 $0000 \\; 0000$ ，与正零的补码相同**。这意味着在补码表示中只存在一个零，正负零歧义从而得到解决。\n\n还剩余最后一个疑惑：`byte` 类型的取值范围是 $[-128, 127]$ ，多出来的一个负数 $-128$ 是如何得到的呢？我们注意到，区间 $[-127, +127]$ 内的所有整数都有对应的原码、反码和补码，并且原码和补码之间是可以互相转换的。\n\n然而，**补码 $1000 \\; 0000$ 是一个例外，它并没有对应的原码**。根据转换方法，我们得到该补码的原码为 $0000 \\; 0000$ 。这显然是矛盾的，因为该原码表示数字 $0$ ，它的补码应该是自身。计算机规定这个特殊的补码 $1000 \\; 0000$ 代表 $-128$ 。实际上，$(-1) + (-127)$ 在补码下的计算结果就是 $-128$ 。\n\n$$\n\\begin{aligned}\n& (-127) + (-1) \\newline\n& \\rightarrow 1111 \\; 1111 \\; \\text{(原码)} + 1000 \\; 0001 \\; \\text{(原码)} \\newline\n& = 1000 \\; 0000 \\; \\text{(反码)} + 1111  \\; 1110 \\; \\text{(反码)} \\newline\n& = 1000 \\; 0001 \\; \\text{(补码)} + 1111  \\; 1111 \\; \\text{(补码)} \\newline\n& = 1000 \\; 0000 \\; \\text{(补码)} \\newline\n& \\rightarrow -128\n\\end{aligned}\n$$\n\n你可能已经发现，上述的所有计算都是加法运算。这暗示着一个重要事实：**计算机内部的硬件电路主要是基于加法运算设计的**。这是因为加法运算相对于其他运算（比如乘法、除法和减法）来说，硬件实现起来更简单，更容易进行并行化处理，运算速度更快。\n\n请注意，这并不意味着计算机只能做加法。**通过将加法与一些基本逻辑运算结合，计算机能够实现各种其他的数学运算**。例如，计算减法 $a - b$ 可以转换为计算加法 $a + (-b)$ ；计算乘法和除法可以转换为计算多次加法或减法。\n\n现在我们可以总结出计算机使用补码的原因：基于补码表示，计算机可以用同样的电路和操作来处理正数和负数的加法，不需要设计特殊的硬件电路来处理减法，并且无须特别处理正负零的歧义问题。这大大简化了硬件设计，提高了运算效率。\n\n补码的设计非常精妙，因篇幅关系我们就先介绍到这里，建议有兴趣的读者进一步深度了解。",
          "questions": [
            "为什么数字是以补码的形式存储在计算机中？",
            "什么是原码、反码和补码？它们之间有什么关系？",
            "为什么负数的原码不能直接用于运算？",
            "为什么数字零的原码有+0和-0两种表示方式？这可能会带来什么问题？",
            "什么是补码2's complement code？它是如何解决正负零歧义问题的？",
            "为什么补码1000 0000代表-128？它的原码是什么？",
            "计算机内部的硬件电路主要是基于哪种运算设计的？为什么？",
            "如何将减法转换为加法运算？",
            "如何将乘法和除法转换为加法或减法运算？",
            "补码的设计有什么优点？"
          ]
        },
        {
          "content": "## 浮点数编码\n\n细心的你可能会发现：`int` 和 `float` 长度相同，都是 4 bytes ，但为什么 `float` 的取值范围远大于 `int` ？这非常反直觉，因为按理说 `float` 需要表示小数，取值范围应该变小才对。\n\n实际上，**这是因为浮点数 `float` 采用了不同的表示方式**。记一个 32-bit 长度的二进制数为：\n\n$$\nb_{31} b_{30} b_{29} \\ldots b_2 b_1 b_0\n$$\n\n根据 IEEE 754 标准，32-bit 长度的 `float` 由以下三个部分构成。\n\n- 符号位 $\\mathrm{S}$ ：占 1 bit ，对应 $b_{31}$ 。\n- 指数位 $\\mathrm{E}$ ：占 8 bits ，对应 $b_{30} b_{29} \\ldots b_{23}$ 。\n- 分数位 $\\mathrm{N}$ ：占 23 bits ，对应 $b_{22} b_{21} \\ldots b_0$ 。\n\n二进制数 `float` 对应的值的计算方法：\n\n$$\n\\text {val} = (-1)^{b_{31}} \\times 2^{\\left(b_{30} b_{29} \\ldots b_{23}\\right)_2-127} \\times\\left(1 . b_{22} b_{21} \\ldots b_0\\right)_2\n$$\n\n转化到十进制下的计算公式：\n\n$$\n\\text {val}=(-1)^{\\mathrm{S}} \\times 2^{\\mathrm{E} -127} \\times (1 + \\mathrm{N})\n$$\n\n其中各项的取值范围：\n\n$$\n\\begin{aligned}\n\\mathrm{S} \\in & \\{ 0, 1\\}, \\quad \\mathrm{E} \\in \\{ 1, 2, \\dots, 254 \\} \\newline\n(1 + \\mathrm{N}) = & (1 + \\sum_{i=1}^{23} b_{23-i} 2^{-i}) \\subset [1, 2 - 2^{-23}]\n\\end{aligned}\n$$\n\n![IEEE 754 标准下的 float 的计算示例](number_encoding.assets/ieee_754_float.png)\n\n观察上图，给定一个示例数据 $\\mathrm{S} = 0$ ， $\\mathrm{E} = 124$ ，$\\mathrm{N} = 2^{-2} + 2^{-3} = 0.375$ ，则有：\n\n$$\n\\text { val } = (-1)^0 \\times 2^{124 - 127} \\times (1 + 0.375) = 0.171875\n$$\n\n现在我们可以回答最初的问题：**`float` 的表示方式包含指数位，导致其取值范围远大于 `int`** 。根据以上计算，`float` 可表示的最大正数为 $2^{254 - 127} \\times (2 - 2^{-23}) \\approx 3.4 \\times 10^{38}$ ，切换符号位便可得到最小负数。\n\n**尽管浮点数 `float` 扩展了取值范围，但其副作用是牺牲了精度**。整数类型 `int` 将全部 32 位用于表示数字，数字是均匀分布的；而由于指数位的存在，浮点数 `float` 的数值越大，相邻两个数字之间的差值就会趋向越大。\n\n如下表所示，指数位 $E = 0$ 和 $E = 255$ 具有特殊含义，**用于表示零、无穷大、$\\mathrm{NaN}$ 等**。\n\n<p align=\"center\"> 表 <id> &nbsp; 指数位含义 </p>\n\n| 指数位 E           | 分数位 $\\mathrm{N} = 0$ | 分数位 $\\mathrm{N} \\ne 0$ | 计算公式                                                               |\n| ------------------ | ----------------------- | ------------------------- | ---------------------------------------------------------------------- |\n| $0$                | $\\pm 0$                 | 次正规数                  | $(-1)^{\\mathrm{S}} \\times 2^{-126} \\times (0.\\mathrm{N})$              |\n| $1, 2, \\dots, 254$ | 正规数                  | 正规数                    | $(-1)^{\\mathrm{S}} \\times 2^{(\\mathrm{E} -127)} \\times (1.\\mathrm{N})$ |\n| $255$              | $\\pm \\infty$            | $\\mathrm{NaN}$            |                                                                        |\n\n值得说明的是，次正规数显著提升了浮点数的精度。最小正正规数为 $2^{-126}$ ，最小正次正规数为 $2^{-126} \\times 2^{-23}$ 。\n\n双精度 `double` 也采用类似 `float` 的表示方法，在此不做赘述。",
          "questions": [
            "浮点数 `float` 为什么能够表示比整数 `int` 更大的数值范围？",
            "32-bit 长度的 `float` 由哪三个部分构成？",
            "如何计算二进制数 `float` 对应的十进制值？",
            "`float` 的符号位、指数位和分数位的取值范围分别是什么？",
            "`float` 的取值范围是多少？最大正数和最小负数分别是多少？",
            "`float` 的精度相对于整数 `int` 有何不同？",
            "指数位 $E = 0$ 和 $E = 255$ 分别表示什么含义？",
            "什么是次正规数？它对浮点数的精度有何影响？",
            "双精度 `double` 采用了什么样的表示方法？",
            "除了零、无穷大和 $\\mathrm{NaN}$，还有哪些特殊的浮点数值？"
          ]
        }
      ]
    },
    {
      "file_name": "hash_map.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 哈希表\n\n「哈希表 hash table」，又称「散列表」，其通过建立键 `key` 与值 `value` 之间的映射，实现高效的元素查询。具体而言，我们向哈希表输入一个键 `key` ，则可以在 $O(1)$ 时间内获取对应的值 `value` 。\n\n如下图所示，给定 $n$ 个学生，每个学生都有“姓名”和“学号”两项数据。假如我们希望实现“输入一个学号，返回对应的姓名”的查询功能，则可以采用下图所示的哈希表来实现。\n\n![哈希表的抽象表示](hash_map.assets/hash_table_lookup.png)\n\n除哈希表外，数组和链表也可以实现查询功能，它们的效率对比如下表所示。\n\n- **添加元素**：仅需将元素添加至数组（链表）的尾部即可，使用 $O(1)$ 时间。\n- **查询元素**：由于数组（链表）是乱序的，因此需要遍历其中的所有元素，使用 $O(n)$ 时间。\n- **删除元素**：需要先查询到元素，再从数组（链表）中删除，使用 $O(n)$ 时间。\n\n<p align=\"center\"> 表 <id> &nbsp; 元素查询效率对比 </p>\n\n|          | 数组   | 链表   | 哈希表 |\n| -------- | ------ | ------ | ------ |\n| 查找元素 | $O(n)$ | $O(n)$ | $O(1)$ |\n| 添加元素 | $O(1)$ | $O(1)$ | $O(1)$ |\n| 删除元素 | $O(n)$ | $O(n)$ | $O(1)$ |\n\n观察发现，**在哈希表中进行增删查改的时间复杂度都是 $O(1)$** ，非常高效。",
          "questions": [
            "哈希表的另一个名称是什么？",
            "哈希表是如何实现高效的元素查询的？",
            "哈希表中输入一个键 `key` ，可以在多长时间内获取对应的值 `value` ？",
            "哈希表与数组、链表相比，哪些操作的时间复杂度更高效？",
            "数组和链表的查询元素时间复杂度分别是多少？",
            "哈希表的增删查改操作的时间复杂度分别是多少？",
            "哈希表中的键和值有什么作用？",
            "哈希表中的键和值可以是什么类型的数据？",
            "哈希表中的冲突是什么意思？",
            "如何解决哈希表中的冲突问题？"
          ]
        },
        {
          "content": "## 哈希表简单实现\n\n我们先考虑最简单的情况，**仅用一个数组来实现哈希表**。在哈希表中，我们将数组中的每个空位称为「桶 bucket」，每个桶可存储一个键值对。因此，查询操作就是找到 `key` 对应的桶，并在桶中获取 `value` 。\n\n那么，如何基于 `key` 来定位对应的桶呢？这是通过「哈希函数 hash function」实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 `key` ，输出空间是所有桶（数组索引）。换句话说，输入一个 `key` ，**我们可以通过哈希函数得到该 `key` 对应的键值对在数组中的存储位置**。\n\n输入一个 `key` ，哈希函数的计算过程分为以下两步。\n\n1. 通过某种哈希算法 `hash()` 计算得到哈希值。\n2. 将哈希值对桶数量（数组长度）`capacity` 取模，从而获取该 `key` 对应的数组索引 `index` 。\n\n```shell\nindex = hash(key) % capacity\n```\n\n随后，我们就可以利用 `index` 在哈希表中访问对应的桶，从而获取 `value` 。\n\n设数组长度 `capacity = 100`、哈希算法 `hash(key) = key` ，易得哈希函数为 `key % 100` 。下图以 `key` 学号和 `value` 姓名为例，展示了哈希函数的工作原理。\n\n![哈希函数工作原理](hash_map.assets/hash_function.png)\n\n以下代码实现了一个简单哈希表。其中，我们将 `key` 和 `value` 封装成一个类 `Pair` ，以表示键值对。\n\n```src\n[file]{array_hash_map}-[class]{array_hash_map}-[func]{}\n```\n\n## 哈希冲突与扩容\n\n本质上看，哈希函数的作用是将所有 `key` 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此，**理论上一定存在“多个输入对应相同输出”的情况**。\n\n对于上述示例中的哈希函数，当输入的 `key` 后两位相同时，哈希函数的输出结果也相同。例如，查询学号为 12836 和 20336 的两个学生时，我们得到：\n\n```shell\n12836 % 100 = 36\n20336 % 100 = 36\n```\n\n如下图所示，两个学号指向了同一个姓名，这显然是不对的。我们将这种多个输入对应同一输出的情况称为「哈希冲突 hash collision」。\n\n![哈希冲突示例](hash_map.assets/hash_collision.png)\n\n容易想到，哈希表容量 $n$ 越大，多个 `key` 被分配到同一个桶中的概率就越低，冲突就越少。因此，**我们可以通过扩容哈希表来减少哈希冲突**。\n\n如下图所示，扩容前键值对 `(136, A)` 和 `(236, D)` 发生冲突，扩容后冲突消失。\n\n![哈希表扩容](hash_map.assets/hash_table_reshash.png)\n\n类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时。并且由于哈希表容量 `capacity` 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步提高了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。\n\n「负载因子 load factor」是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，**也常被作为哈希表扩容的触发条件**。例如在 Java 中，当负载因子超过 $0.75$ 时，系统会将哈希表容量扩展为原先的 $2$ 倍。",
          "questions": [
            "哈希表中的桶(bucket)是什么？",
            "哈希函数的作用是什么？",
            "哈希函数的计算过程分为哪两步？",
            "如何利用哈希函数定位到对应的桶？",
            "什么是哈希冲突(hash collision)？",
            "如何通过扩容哈希表来减少哈希冲突？",
            "哈希表扩容需要做哪些操作？",
            "负载因子(load factor)是什么？有什么作用？",
            "Java中哈希表的负载因子超过多少时会触发扩容？",
            "为什么编程语言通常会预留足够大的哈希表容量？"
          ]
        }
      ]
    },
    {
      "file_name": "array_representation_of_tree.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 二叉树数组表示\n\n在链表表示下，二叉树的存储单元为节点 `TreeNode` ，节点之间通过指针相连接。在上节中，我们学习了在链表表示下的二叉树的各项基本操作。\n\n那么，我们能否用数组来表示二叉树呢？答案是肯定的。\n\n## 表示完美二叉树\n\n先分析一个简单案例。给定一个完美二叉树，我们将所有节点按照层序遍历的顺序存储在一个数组中，则每个节点都对应唯一的数组索引。\n\n根据层序遍历的特性，我们可以推导出父节点索引与子节点索引之间的“映射公式”：**若节点的索引为 $i$ ，则该节点的左子节点索引为 $2i + 1$ ，右子节点索引为 $2i + 2$** 。下图展示了各个节点索引之间的映射关系。\n\n![完美二叉树的数组表示](array_representation_of_tree.assets/array_representation_binary_tree.png)\n\n**映射公式的角色相当于链表中的指针**。给定数组中的任意一个节点，我们都可以通过映射公式来访问它的左（右）子节点。\n\n## 表示任意二叉树\n\n完美二叉树是一个特例，在二叉树的中间层通常存在许多 $\\text{None}$ 。由于层序遍历序列并不包含这些 $\\text{None}$ ，因此我们无法仅凭该序列来推测 $\\text{None}$ 的数量和分布位置。**这意味着存在多种二叉树结构都符合该层序遍历序列**。\n\n如下图所示，给定一个非完美二叉树，上述的数组表示方法已经失效。\n\n![层序遍历序列对应多种二叉树可能性](array_representation_of_tree.assets/array_representation_without_empty.png)\n\n为了解决此问题，**我们可以考虑在层序遍历序列中显式地写出所有 $\\text{None}$** 。如下图所示，这样处理后，层序遍历序列就可以唯一表示二叉树了。\n\n=== \"Python\"\n\n    ```python title=\"\"\n    # 二叉树的数组表示\n    # 使用 None 来表示空位\n    tree = [1, 2, 3, 4, None, 6, 7, 8, 9, None, None, 12, None, None, 15]\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"\"\n    /* 二叉树的数组表示 */\n    // 使用 int 最大值 INT_MAX 标记空位\n    vector<int> tree = {1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12, INT_MAX, INT_MAX, 15};\n    ```\n\n=== \"Java\"\n\n    ```java title=\"\"\n    /* 二叉树的数组表示 */\n    // 使用 int 的包装类 Integer ，就可以使用 null 来标记空位\n    Integer[] tree = { 1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15 };\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"\"\n    /* 二叉树的数组表示 */\n    // 使用 int? 可空类型 ，就可以使用 null 来标记空位\n    int?[] tree = { 1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15 };\n    ```\n\n=== \"Go\"\n\n    ```go title=\"\"\n    /* 二叉树的数组表示 */\n    // 使用 any 类型的切片, 就可以使用 nil 来标记空位\n    tree := []any{1, 2, 3, 4, nil, 6, 7, 8, 9, nil, nil, 12, nil, nil, 15}\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"\"\n    /* 二叉树的数组表示 */\n    // 使用 Int? 可空类型 ，就可以使用 nil 来标记空位\n    let tree: [Int?] = [1, 2, 3, 4, nil, 6, 7, 8, 9, nil, nil, 12, nil, nil, 15]\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"\"\n    /* 二叉树的数组表示 */\n    // 使用 null 来表示空位\n    let tree = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"\"\n    /* 二叉树的数组表示 */\n    // 使用 null 来表示空位\n    let tree: (number | null)[] = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"\"\n    /* 二叉树的数组表示 */\n    // 使用 int? 可空类型 ，就可以使用 null 来标记空位\n    List<int?> tree = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"\"\n    /* 二叉树的数组表示 */\n    // 使用 None 来标记空位\n    let tree = [Some(1), Some(2), Some(3), Some(4), None, Some(6), Some(7), Some(8), Some(9), None, None, Some(12), None, None, Some(15)];\n    ```\n\n=== \"C\"\n\n    ```c title=\"\"\n    /* 二叉树的数组表示 */\n    // 使用 int 最大值标记空位，因此要求节点值不能为 INT_MAX\n    int tree[] = {1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12, INT_MAX, INT_MAX, 15};\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"\"\n\n    ```\n\n![任意类型二叉树的数组表示](array_representation_of_tree.assets/array_representation_with_empty.png)\n\n值得说明的是，**完全二叉树非常适合使用数组来表示**。回顾完全二叉树的定义，$\\text{None}$ 只出现在最底层且靠右的位置，**因此所有 $\\text{None}$ 一定出现在层序遍历序列的末尾**。\n\n这意味着使用数组表示完全二叉树时，可以省略存储所有 $\\text{None}$ ，非常方便。下图给出了一个例子。\n\n![完全二叉树的数组表示](array_representation_of_tree.assets/array_representation_complete_binary_tree.png)\n\n以下代码实现了一个基于数组表示的二叉树，包括以下几种操作。\n\n- 给定某节点，获取它的值、左（右）子节点、父节点。\n- 获取前序遍历、中序遍历、后序遍历、层序遍历序列。\n\n```src\n[file]{array_binary_tree}-[class]{array_binary_tree}-[func]{}\n```\n\n## 优势与局限性\n\n二叉树的数组表示主要有以下优点。\n\n- 数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。\n- 不需要存储指针，比较节省空间。\n- 允许随机访问节点。\n\n然而，数组表示也存在一些局限性。\n\n- 数组存储需要连续内存空间，因此不适合存储数据量过大的树。\n- 增删节点需要通过数组插入与删除操作实现，效率较低。\n- 当二叉树中存在大量 $\\text{None}$ 时，数组中包含的节点数据比重较低，空间利用率较低。",
          "questions": [
            "二叉树的数组表示有哪些优点和局限性？",
            "如何在数组中表示完美二叉树？有什么特点？",
            "在非完美二叉树中，为什么使用层序遍历序列无法唯一表示二叉树？",
            "如何在层序遍历序列中显式地写出所有空节点，以表示任意二叉树？",
            "在数组表示的二叉树中，如何给定某节点，获取它的值、左（右）子节点、父节点？",
            "在数组表示的二叉树中，如何获取前序遍历、中序遍历、后序遍历、层序遍历序列？",
            "为什么完全二叉树非常适合使用数组来表示？如何省略存储所有空节点？",
            "数组表示的二叉树不适合存储数据量过大的树，为什么？",
            "增删节点在数组表示的二叉树中需要通过数组插入与删除操作实现，效率较低，为什么？",
            "当二叉树中存在大量空节点时，数组中包含的节点数据比重较低，空间利用率较低，为什么？"
          ]
        }
      ]
    },
    {
      "file_name": "array.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 数组\n\n「数组 array」是一种线性数据结构，其将相同类型元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的「索引 index」。下图展示了数组的主要术语和概念。\n\n![数组定义与存储方式](array.assets/array_definition.png)\n\n## 数组常用操作\n\n### 初始化数组\n\n我们可以根据需求选用数组的两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为 $0$ 。\n\n=== \"Python\"\n\n    ```python title=\"array.py\"\n    # 初始化数组\n    arr: list[int] = [0] * 5  # [ 0, 0, 0, 0, 0 ]\n    nums: list[int] = [1, 3, 2, 5, 4]  \n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"array.cpp\"\n    /* 初始化数组 */\n    // 存储在栈上\n    int arr[5];\n    int nums[5] { 1, 3, 2, 5, 4 };\n    // 存储在堆上（需要手动释放空间）\n    int* arr1 = new int[5];\n    int* nums1 = new int[5] { 1, 3, 2, 5, 4 };\n    ```\n\n=== \"Java\"\n\n    ```java title=\"array.java\"\n    /* 初始化数组 */\n    int[] arr = new int[5]; // { 0, 0, 0, 0, 0 }\n    int[] nums = { 1, 3, 2, 5, 4 };\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"array.cs\"\n    /* 初始化数组 */\n    int[] arr = new int[5]; // { 0, 0, 0, 0, 0 }\n    int[] nums = { 1, 3, 2, 5, 4 };\n    ```\n\n=== \"Go\"\n\n    ```go title=\"array.go\"\n    /* 初始化数组 */\n    var arr [5]int\n    // 在 Go 中，指定长度时（[5]int）为数组，不指定长度时（[]int）为切片\n    // 由于 Go 的数组被设计为在编译期确定长度，因此只能使用常量来指定长度\n    // 为了方便实现扩容 extend() 方法，以下将切片（Slice）看作数组（Array）\n    nums := []int{1, 3, 2, 5, 4}\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"array.swift\"\n    /* 初始化数组 */\n    let arr = Array(repeating: 0, count: 5) // [0, 0, 0, 0, 0]\n    let nums = [1, 3, 2, 5, 4]\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"array.js\"\n    /* 初始化数组 */\n    var arr = new Array(5).fill(0);\n    var nums = [1, 3, 2, 5, 4];\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"array.ts\"\n    /* 初始化数组 */\n    let arr: number[] = new Array(5).fill(0);\n    let nums: number[] = [1, 3, 2, 5, 4];\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"array.dart\"\n    /* 初始化数组 */\n    List<int> arr = List.filled(5, 0); // [0, 0, 0, 0, 0]\n    List<int> nums = [1, 3, 2, 5, 4];\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"array.rs\"\n    /* 初始化数组 */\n    let arr: Vec<i32> = vec![0; 5]; // [0, 0, 0, 0, 0]\n    let nums: Vec<i32> = vec![1, 3, 2, 5, 4];\n    ```\n\n=== \"C\"\n\n    ```c title=\"array.c\"\n    /* 初始化数组 */\n    int arr[5] = { 0 }; // { 0, 0, 0, 0, 0 }\n    int nums[5] = { 1, 3, 2, 5, 4 };\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"array.zig\"\n    // 初始化数组\n    var arr = [_]i32{0} ** 5; // { 0, 0, 0, 0, 0 }\n    var nums = [_]i32{ 1, 3, 2, 5, 4 };\n    ```\n\n### 访问元素\n\n数组元素被存储在连续的内存空间中，这意味着计算数组元素的内存地址非常容易。给定数组内存地址（即首元素内存地址）和某个元素的索引，我们可以使用下图所示的公式计算得到该元素的内存地址，从而直接访问此元素。\n\n![数组元素的内存地址计算](array.assets/array_memory_location_calculation.png)\n\n观察上图，我们发现数组首个元素的索引为 $0$ ，这似乎有些反直觉，因为从 $1$ 开始计数会更自然。但从地址计算公式的角度看，**索引的含义本质上是内存地址的偏移量**。首个元素的地址偏移量是 $0$ ，因此它的索引为 $0$ 也是合理的。\n\n在数组中访问元素是非常高效的，我们可以在 $O(1)$ 时间内随机访问数组中的任意一个元素。\n\n```src\n[file]{array}-[class]{}-[func]{random_access}\n```\n\n### 插入元素\n\n数组元素在内存中是“紧挨着的”，它们之间没有空间再存放任何数据。如下图所示，如果想要在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引。\n\n![数组插入元素示例](array.assets/array_insert_element.png)\n\n值得注意的是，由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素的“丢失”。我们将这个问题的解决方案留在列表章节中讨论。\n\n```src\n[file]{array}-[class]{}-[func]{insert}\n```\n\n### 删除元素\n\n同理，如下图所示，若想要删除索引 $i$ 处的元素，则需要把索引 $i$ 之后的元素都向前移动一位。\n\n![数组删除元素示例](array.assets/array_remove_element.png)\n\n请注意，删除元素完成后，原先末尾的元素变得“无意义”了，所以我们无须特意去修改它。\n\n```src\n[file]{array}-[class]{}-[func]{remove}\n```\n\n总的来看，数组的插入与删除操作有以下缺点。\n\n- **时间复杂度高**：数组的插入和删除的平均时间复杂度均为 $O(n)$ ，其中 $n$ 为数组长度。\n- **丢失元素**：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。\n- **内存浪费**：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做也会造成部分内存空间的浪费。\n\n### 遍历数组\n\n在大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素。\n\n```src\n[file]{array}-[class]{}-[func]{traverse}\n```\n\n### 查找元素\n\n在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。\n\n因为数组是线性数据结构，所以上述查找操作被称为“线性查找”。\n\n```src\n[file]{array}-[class]{}-[func]{find}\n```\n\n### 扩容数组\n\n在复杂的系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全地扩展数组容量。因此在大多数编程语言中，**数组的长度是不可变的**。\n\n如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次拷贝到新数组。这是一个 $O(n)$ 的操作，在数组很大的情况下是非常耗时的。\n\n```src\n[file]{array}-[class]{}-[func]{extend}\n```\n\n## 数组优点与局限性\n\n数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。\n\n- **空间效率高**: 数组为数据分配了连续的内存块，无须额外的结构开销。\n- **支持随机访问**: 数组允许在 $O(1)$ 时间内访问任何元素。\n- **缓存局部性**: 当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。\n\n连续空间存储是一把双刃剑，其存在以下缺点。\n\n- **插入与删除效率低**:当数组中元素较多时，插入与删除操作需要移动大量的元素。\n- **长度不可变**: 数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。\n- **空间浪费**: 如果数组分配的大小超过了实际所需，那么多余的空间就被浪费了。",
          "questions": [
            "数组的元素存储在内存中的哪里？",
            "数组的索引从哪里开始计数？为什么？",
            "数组的初始化方式有哪些？如何给数组赋初值？",
            "数组的访问操作的时间复杂度是多少？",
            "数组的插入和删除操作的时间复杂度是多少？为什么？",
            "数组的长度是否可变？如何扩容数组？",
            "数组的优点有哪些？缺点有哪些？",
            "数组的遍历方式有哪些？如何遍历数组？",
            "数组的查找操作的时间复杂度是多少？如何实现线性查找？",
            "数组的空间效率和缓存局部性是如何实现的？"
          ]
        },
        {
          "content": "## 数组典型应用\n\n数组是一种基础且常见的数据结构，既频繁应用在各类算法之中，也可用于实现各种复杂数据结构。\n\n- **随机访问**：如果我们想要随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现样本的随机抽取。\n- **排序和搜索**：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。\n- **查找表**：当我们需要快速查找一个元素或者需要查找一个元素的对应关系时，可以使用数组作为查找表。假如我们想要实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。\n- **机器学习**：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。\n- **数据结构实现**：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。",
          "questions": [
            "数组在哪些算法中被频繁应用？",
            "如何利用数组实现样本的随机抽取？",
            "数组是哪些排序和搜索算法最常用的数据结构？",
            "数组可以用于实现哪些数据结构？",
            "数组在机器学习中的应用是什么？",
            "如何利用数组实现查找表？",
            "数组在神经网络编程中是什么样的数据结构？",
            "数组在图的表示中有哪些应用？",
            "数组的随机访问是什么意思？",
            "数组在数据结构中的应用有哪些？"
          ]
        }
      ]
    },
    {
      "file_name": "build_binary_tree_problem.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 构建二叉树问题\n\n!!! question\n\n    给定一个二叉树的前序遍历 `preorder` 和中序遍历 `inorder` ，请从中构建二叉树，返回二叉树的根节点。\n\n![构建二叉树的示例数据](build_binary_tree_problem.assets/build_tree_example.png)\n\n### 判断是否为分治问题\n\n原问题定义为从 `preorder` 和 `inorder` 构建二叉树，其是一个典型的分治问题。\n\n- **问题可以被分解**：从分治的角度切入，我们可以将原问题划分为两个子问题：构建左子树、构建右子树，加上一步操作：初始化根节点。而对于每个子树（子问题），我们仍然可以复用以上划分方法，将其划分为更小的子树（子问题），直至达到最小子问题（空子树）时终止。\n- **子问题是独立的**：左子树和右子树是相互独立的，它们之间没有交集。在构建左子树时，我们只需要关注中序遍历和前序遍历中与左子树对应的部分。右子树同理。\n- **子问题的解可以合并**：一旦得到了左子树和右子树（子问题的解），我们就可以将它们链接到根节点上，得到原问题的解。\n\n### 如何划分子树\n\n根据以上分析，这道题是可以使用分治来求解的，**但如何通过前序遍历 `preorder` 和中序遍历 `inorder` 来划分左子树和右子树呢**？\n\n根据定义，`preorder` 和 `inorder` 都可以被划分为三个部分。\n\n- 前序遍历：`[ 根节点 | 左子树 | 右子树 ]` ，例如上图的树对应 `[ 3 | 9 | 2 1 7 ]` 。\n- 中序遍历：`[ 左子树 | 根节点 ｜ 右子树 ]` ，例如上图的树对应 `[ 9 | 3 | 1 2 7 ]` 。\n\n以上图数据为例，我们可以通过下图所示的步骤得到划分结果。\n\n1. 前序遍历的首元素 3 是根节点的值。\n2. 查找根节点 3 在 `inorder` 中的索引，利用该索引可将 `inorder` 划分为 `[ 9 | 3 ｜ 1 2 7 ]` 。\n3. 根据 `inorder` 划分结果，易得左子树和右子树的节点数量分别为 1 和 3 ，从而可将 `preorder` 划分为 `[ 3 | 9 | 2 1 7 ]` 。\n\n![在前序和中序遍历中划分子树](build_binary_tree_problem.assets/build_tree_preorder_inorder_division.png)\n\n### 基于变量描述子树区间\n\n根据以上划分方法，**我们已经得到根节点、左子树、右子树在 `preorder` 和 `inorder` 中的索引区间**。而为了描述这些索引区间，我们需要借助几个指针变量。\n\n- 将当前树的根节点在 `preorder` 中的索引记为 $i$ 。\n- 将当前树的根节点在 `inorder` 中的索引记为 $m$ 。\n- 将当前树在 `inorder` 中的索引区间记为 $[l, r]$ 。\n\n如下表所示，通过以上变量即可表示根节点在 `preorder` 中的索引，以及子树在 `inorder` 中的索引区间。\n\n<p align=\"center\"> 表 <id> &nbsp; 根节点和子树在前序和中序遍历中的索引 </p>\n\n|        | 根节点在 `preorder` 中的索引 | 子树在 `inorder` 中的索引区间 |\n| ------ | -------------------------------- | ----------------------------- |\n| 当前树 | $i$                              | $[l, r]$                      |\n| 左子树 | $i + 1$                          | $[l, m-1]$                    |\n| 右子树 | $i + 1 + (m - l)$                | $[m+1, r]$                    |\n\n请注意，右子树根节点索引中的 $(m-l)$ 的含义是“左子树的节点数量”，建议配合下图理解。\n\n![根节点和左右子树的索引区间表示](build_binary_tree_problem.assets/build_tree_division_pointers.png)\n\n### 代码实现\n\n为了提升查询 $m$ 的效率，我们借助一个哈希表 `hmap` 来存储数组 `inorder` 中元素到索引的映射。\n\n```src\n[file]{build_tree}-[class]{}-[func]{build_tree}\n```\n\n下图展示了构建二叉树的递归过程，各个节点是在向下“递”的过程中建立的，而各条边（即引用）是在向上“归”的过程中建立的。\n\n=== \"<1>\"\n    ![构建二叉树的递归过程](build_binary_tree_problem.assets/built_tree_step1.png)\n\n=== \"<2>\"\n    ![built_tree_step2](build_binary_tree_problem.assets/built_tree_step2.png)\n\n=== \"<3>\"\n    ![built_tree_step3](build_binary_tree_problem.assets/built_tree_step3.png)\n\n=== \"<4>\"\n    ![built_tree_step4](build_binary_tree_problem.assets/built_tree_step4.png)\n\n=== \"<5>\"\n    ![built_tree_step5](build_binary_tree_problem.assets/built_tree_step5.png)\n\n=== \"<6>\"\n    ![built_tree_step6](build_binary_tree_problem.assets/built_tree_step6.png)\n\n=== \"<7>\"\n    ![built_tree_step7](build_binary_tree_problem.assets/built_tree_step7.png)\n\n=== \"<8>\"\n    ![built_tree_step8](build_binary_tree_problem.assets/built_tree_step8.png)\n\n=== \"<9>\"\n    ![built_tree_step9](build_binary_tree_problem.assets/built_tree_step9.png)\n\n每个递归函数内的前序遍历 `preorder` 和中序遍历 `inorder` 的划分结果如下图所示。\n\n![每个递归函数中的划分结果](build_binary_tree_problem.assets/built_tree_overall.png)\n\n设树的节点数量为 $n$ ，初始化每一个节点（执行一个递归函数 `dfs()` ）使用 $O(1)$ 时间。**因此总体时间复杂度为 $O(n)$** 。\n\n哈希表存储 `inorder` 元素到索引的映射，空间复杂度为 $O(n)$ 。最差情况下，即二叉树退化为链表时，递归深度达到 $n$ ，使用 $O(n)$ 的栈帧空间。**因此总体空间复杂度为 $O(n)$** 。",
          "questions": [
            "如何判断一个问题是分治问题？有哪些典型的分治问题？",
            "在构建二叉树的过程中，如何通过前序遍历和中序遍历来划分左子树和右子树？",
            "如何通过变量描述根节点和子树在前序遍历和中序遍历中的索引？",
            "为什么需要使用哈希表来存储中序遍历中元素到索引的映射？",
            "递归函数 `dfs()` 的时间复杂度是多少？为什么？",
            "递归函数 `dfs()` 的空间复杂度是多少？为什么？",
            "在递归函数 `dfs()` 中，如何初始化每个节点？",
            "递归函数 `dfs()` 的返回值是什么？为什么？",
            "在递归函数 `dfs()` 中，如何建立各个节点之间的引用关系？",
            "二叉树退化为链表时，递归深度达到多少？使用了多少栈帧空间？"
          ]
        }
      ]
    },
    {
      "file_name": "dp_problem_features.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 动态规划问题特性\n\n在上节中，我们学习了动态规划是如何通过子问题分解来求解问题的。实际上，子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同。\n\n- 分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解。\n- 动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题。\n- 回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作为一个子问题。\n\n实际上，动态规划常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性。\n\n## 最优子结构\n\n我们对爬楼梯问题稍作改动，使之更加适合展示最优子结构概念。\n\n!!! question \"爬楼梯最小代价\"\n\n    给定一个楼梯，你每步可以上 $1$ 阶或者 $2$ 阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。给定一个非负整数数组 $cost$ ，其中 $cost[i]$ 表示在第 $i$ 个台阶需要付出的代价，$cost[0]$ 为地面起始点。请计算最少需要付出多少代价才能到达顶部？\n\n如下图所示，若第 $1$、$2$、$3$ 阶的代价分别为 $1$、$10$、$1$ ，则从地面爬到第 $3$ 阶的最小代价为 $2$ 。\n\n![爬到第 3 阶的最小代价](dp_problem_features.assets/min_cost_cs_example.png)\n\n设 $dp[i]$ 为爬到第 $i$ 阶累计付出的代价，由于第 $i$ 阶只可能从 $i - 1$ 阶或 $i - 2$ 阶走来，因此 $dp[i]$ 只可能等于 $dp[i - 1] + cost[i]$ 或 $dp[i - 2] + cost[i]$ 。为了尽可能减少代价，我们应该选择两者中较小的那一个：\n\n$$\ndp[i] = \\min(dp[i-1], dp[i-2]) + cost[i]\n$$\n\n这便可以引出最优子结构的含义：**原问题的最优解是从子问题的最优解构建得来的**。\n\n本题显然具有最优子结构：我们从两个子问题最优解 $dp[i-1]$ 和 $dp[i-2]$ 中挑选出较优的那一个，并用它构建出原问题 $dp[i]$ 的最优解。\n\n那么，上节的爬楼梯题目有没有最优子结构呢？它的目标是求解方案数量，看似是一个计数问题，但如果换一种问法：“求解最大方案数量”。我们意外地发现，**虽然题目修改前后是等价的，但最优子结构浮现出来了**：第 $n$ 阶最大方案数量等于第 $n-1$ 阶和第 $n-2$ 阶最大方案数量之和。所以说，最优子结构的解释方式比较灵活，在不同问题中会有不同的含义。\n\n根据状态转移方程，以及初始状态 $dp[1] = cost[1]$ 和 $dp[2] = cost[2]$ ，我们就可以得到动态规划代码。\n\n```src\n[file]{min_cost_climbing_stairs_dp}-[class]{}-[func]{min_cost_climbing_stairs_dp}\n```\n\n下图展示了以上代码的动态规划过程。\n\n![爬楼梯最小代价的动态规划过程](dp_problem_features.assets/min_cost_cs_dp.png)\n\n本题也可以进行空间优化，将一维压缩至零维，使得空间复杂度从 $O(n)$ 降低至 $O(1)$ 。\n\n```src\n[file]{min_cost_climbing_stairs_dp}-[class]{}-[func]{min_cost_climbing_stairs_dp_comp}\n```",
          "questions": [
            "什么是动态规划算法？它与分治算法和回溯算法有什么不同？",
            "动态规划常用来求解什么类型的问题？它们具有哪些特性？",
            "什么是最优子结构？它在动态规划中的作用是什么？",
            "请举一个具有最优子结构的例子，并说明其最优子结构的含义。",
            "在爬楼梯问题中，如何使用动态规划算法求解最小代价？",
            "请说明爬楼梯问题具有最优子结构的原因。",
            "爬楼梯问题的状态转移方程是什么？请说明其含义。",
            "如何进行空间优化，将爬楼梯问题的空间复杂度从 $O(n)$ 降低至 $O(1)$ ？",
            "除了爬楼梯问题，还有哪些常见问题可以使用动态规划算法求解？",
            "动态规划算法的时间复杂度如何计算？"
          ]
        },
        {
          "content": "## 无后效性\n\n无后效性是动态规划能够有效解决问题的重要特性之一，定义为：**给定一个确定的状态，它的未来发展只与当前状态有关，而与当前状态过去所经历过的所有状态无关**。\n\n以爬楼梯问题为例，给定状态 $i$ ，它会发展出状态 $i+1$ 和状态 $i+2$ ，分别对应跳 $1$ 步和跳 $2$ 步。在做出这两种选择时，我们无须考虑状态 $i$ 之前的状态，它们对状态 $i$ 的未来没有影响。\n\n然而，如果我们向爬楼梯问题添加一个约束，情况就不一样了。\n\n!!! question \"带约束爬楼梯\"\n\n    给定一个共有 $n$ 阶的楼梯，你每步可以上 $1$ 阶或者 $2$ 阶，**但不能连续两轮跳 $1$ 阶**，请问有多少种方案可以爬到楼顶。\n\n例如下图，爬上第 $3$ 阶仅剩 $2$ 种可行方案，其中连续三次跳 $1$ 阶的方案不满足约束条件，因此被舍弃。\n\n![带约束爬到第 3 阶的方案数量](dp_problem_features.assets/climbing_stairs_constraint_example.png)\n\n在该问题中，如果上一轮是跳 $1$ 阶上来的，那么下一轮就必须跳 $2$ 阶。这意味着，**下一步选择不能由当前状态（当前楼梯阶数）独立决定，还和前一个状态（上轮楼梯阶数）有关**。\n\n不难发现，此问题已不满足无后效性，状态转移方程 $dp[i] = dp[i-1] + dp[i-2]$ 也失效了，因为 $dp[i-1]$ 代表本轮跳 $1$ 阶，但其中包含了许多“上一轮跳 $1$ 阶上来的”方案，而为了满足约束，我们就不能将 $dp[i-1]$ 直接计入 $dp[i]$ 中。\n\n为此，我们需要扩展状态定义：**状态 $[i, j]$ 表示处在第 $i$ 阶、并且上一轮跳了 $j$ 阶**，其中 $j \\in \\{1, 2\\}$ 。此状态定义有效地区分了上一轮跳了 $1$ 阶还是 $2$ 阶，我们可以据此来判断当前状态是从何而来的。\n\n- 当上一轮跳了 $1$ 阶时，上上一轮只能选择跳 $2$ 阶，即 $dp[i, 1]$ 只能从 $dp[i-1, 2]$ 转移过来。\n- 当上一轮跳了 $2$ 阶时，上上一轮可选择跳 $1$ 阶或跳 $2$ 阶，即 $dp[i, 2]$ 可以从 $dp[i-2, 1]$ 或 $dp[i-2, 2]$ 转移过来。\n\n如下图所示，在该定义下，$dp[i, j]$ 表示状态 $[i, j]$ 对应的方案数。此时状态转移方程为：\n\n$$\n\\begin{cases}\ndp[i, 1] = dp[i-1, 2] \\\\\ndp[i, 2] = dp[i-2, 1] + dp[i-2, 2]\n\\end{cases}\n$$\n\n![考虑约束下的递推关系](dp_problem_features.assets/climbing_stairs_constraint_state_transfer.png)\n\n最终，返回 $dp[n, 1] + dp[n, 2]$ 即可，两者之和代表爬到第 $n$ 阶的方案总数。\n\n```src\n[file]{climbing_stairs_constraint_dp}-[class]{}-[func]{climbing_stairs_constraint_dp}\n```\n\n在上面的案例中，由于仅需多考虑前面一个状态，我们仍然可以通过扩展状态定义，使得问题重新满足无后效性。然而，某些问题具有非常严重的“有后效性”。\n\n!!! question \"爬楼梯与障碍生成\"\n\n    给定一个共有 $n$ 阶的楼梯，你每步可以上 $1$ 阶或者 $2$ 阶。**规定当爬到第 $i$ 阶时，系统自动会给第 $2i$ 阶上放上障碍物，之后所有轮都不允许跳到第 $2i$ 阶上**。例如，前两轮分别跳到了第 $2$、$3$ 阶上，则之后就不能跳到第 $4$、$6$ 阶上。请问有多少种方案可以爬到楼顶。\n\n在这个问题中，下次跳跃依赖于过去所有的状态，因为每一次跳跃都会在更高的阶梯上设置障碍，并影响未来的跳跃。对于这类问题，动态规划往往难以解决。\n\n实际上，许多复杂的组合优化问题（例如旅行商问题）都不满足无后效性。对于这类问题，我们通常会选择使用其他方法，例如启发式搜索、遗传算法、强化学习等，从而在有限时间内得到可用的局部最优解。",
          "questions": [
            "在动态规划中，什么是无后效性？为什么它是动态规划能够有效解决问题的重要特性之一？",
            "在爬楼梯问题中，为什么状态转移方程 $dp[i] = dp[i-1] + dp[i-2]$ 满足无后效性？",
            "在带约束爬楼梯问题中，为什么状态转移方程 $dp[i] = dp[i-1] + dp[i-2]$ 失效了？如何扩展状态定义来解决这个问题？",
            "在带约束爬楼梯问题中，状态转移方程为什么变成了 $dp[i, 1] = dp[i-1, 2]$ 和 $dp[i, 2] = dp[i-2, 1] + dp[i-2, 2]$？这两个方程分别代表什么含义？",
            "在障碍生成问题中，为什么每一次跳跃都会在更高的阶梯上设置障碍，并影响未来的跳跃？这个问题为什么不满足无后效性？",
            "对于不满足无后效性的问题，动态规划是否仍然是一个可行的解决方法？如果不是，有哪些其他方法可以使用？",
            "在动态规划中，状态转移方程的正确性是如何保证的？有哪些常见的错误可能导致状态转移方程不正确？",
            "在动态规划中，如何选择合适的状态定义？状态定义的好坏对算法的效率有哪些影响？",
            "在动态规划中，如何处理边界情况？边界情况对算法的正确性和效率有哪些影响？",
            "在动态规划中，如何优化算法的空间复杂度？有哪些常见的优化方法？"
          ]
        }
      ]
    },
    {
      "file_name": "basic_data_types.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 基本数据类型\n\n谈及计算机中的数据，我们会想到文本、图片、视频、语音、3D 模型等各种形式。尽管这些数据的组织形式各异，但它们都由各种基本数据类型构成。\n\n**基本数据类型是 CPU 可以直接进行运算的类型**，在算法中直接被使用，主要包括以下几种类型。\n\n- 整数类型 `byte`、`short`、`int`、`long` 。\n- 浮点数类型 `float`、`double` ，用于表示小数。\n- 字符类型 `char` ，用于表示各种语言的字母、标点符号、甚至表情符号等。\n- 布尔类型 `bool` ，用于表示“是”与“否”判断。\n\n**基本数据类型以二进制的形式存储在计算机中**。一个二进制位即为 $1$ 比特。在绝大多数现代系统中，$1$ 字节（byte）由 $8$ 比特（bits）组成。\n\n基本数据类型的取值范围取决于其占用的空间大小。下面以 Java 为例。\n\n- 整数类型 `byte` 占用 $1$ byte = $8$ bits ，可以表示 $2^{8}$ 个数字。\n- 整数类型 `int` 占用 $4$ bytes = $32$ bits ，可以表示 $2^{32}$ 个数字。\n\n下表列举了各种基本数据类型的占用空间、取值范围和默认值。此表格无须硬背，大致理解即可，需要时可以通过查表来回忆。\n\n<p align=\"center\"> 表 <id> &nbsp; 基本数据类型的占用空间和取值范围 </p>\n\n| 类型   | 符号     | 占用空间         | 最小值                   | 最大值                  | 默认值         |\n| ------ | -------- | ---------------- | ------------------------ | ----------------------- | -------------- |\n| 整数   | `byte`   | 1 byte           | $-2^7$ ($-128$)          | $2^7 - 1$ ($127$)       | $0$            |\n|        | `short`  | 2 bytes          | $-2^{15}$                | $2^{15} - 1$            | $0$            |\n|        | `int`    | 4 bytes          | $-2^{31}$                | $2^{31} - 1$            | $0$            |\n|        | `long`   | 8 bytes          | $-2^{63}$                | $2^{63} - 1$            | $0$            |\n| 浮点数 | `float`  | 4 bytes          | $1.175 \\times 10^{-38}$  | $3.403 \\times 10^{38}$  | $0.0 f$        |\n|        | `double` | 8 bytes          | $2.225 \\times 10^{-308}$ | $1.798 \\times 10^{308}$ | $0.0$          |\n| 字符   | `char`   | 2 bytes / 1 byte | $0$                      | $2^{16} - 1$            | $0$            |\n| 布尔   | `bool`   | 1 byte           | $\\text{false}$           | $\\text{true}$           | $\\text{false}$ |\n\n对于上表，需要注意以下几点。\n\n- C 和 C++ 未明确规定基本数据类型大小，而因实现和平台各异。上表遵循 LP64 [数据模型](https://en.cppreference.com/w/cpp/language/types#Properties)，其用于包括 Linux 和 macOS 在内的 Unix 64 位操作系统。\n- 字符 `char` 的大小在 C 和 C++ 中为 1 字节，在大多数编程语言中取决于特定的字符编码方法，详见“字符编码”章节。\n- 即使表示布尔量仅需 1 位（$0$ 或 $1$），它在内存中通常被存储为 1 字节。这是因为现代计算机 CPU 通常将 1 字节作为最小寻址内存单元。\n\n那么，基本数据类型与数据结构之间有什么联系呢？我们知道，数据结构是在计算机中组织与存储数据的方式。它的主语是“结构”而非“数据”。\n\n如果想要表示“一排数字”，我们自然会想到使用数组。这是因为数组的线性结构可以表示数字的相邻关系和顺序关系，但至于存储的内容是整数 `int`、小数 `float` 或是字符 `char` ，则与“数据结构”无关。\n\n换句话说，**基本数据类型提供了数据的“内容类型”，而数据结构提供了数据的“组织方式”**。例如以下代码，我们用相同的数据结构（数组）来存储与表示不同的基本数据类型，包括 `int`、`float`、`char`、`bool` 等。\n\n=== \"Python\"\n\n    ```python title=\"\"\n    # 使用多种基本数据类型来初始化数组\n    numbers: list[int] = [0] * 5\n    decimals: list[float] = [0.0] * 5\n    # Python 的字符应被看作长度为一的字符串\n    characters: list[str] = ['0'] * 5\n    bools: list[bool] = [False] * 5\n    # Python 的列表可以自由存储各种基本数据类型和对象引用\n    data = [0, 0.0, 'a', False, ListNode(0)]\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"\"\n    // 使用多种基本数据类型来初始化数组\n    int numbers[5];\n    float decimals[5];\n    char characters[5];\n    bool bools[5];\n    ```\n\n=== \"Java\"\n\n    ```java title=\"\"\n    // 使用多种基本数据类型来初始化数组\n    int[] numbers = new int[5];\n    float[] decimals = new float[5];\n    char[] characters = new char[5];\n    boolean[] bools = new boolean[5];\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"\"\n    // 使用多种基本数据类型来初始化数组\n    int[] numbers = new int[5];\n    float[] decimals = new float[5];\n    char[] characters = new char[5];\n    bool[] bools = new bool[5];\n    ```\n\n=== \"Go\"\n\n    ```go title=\"\"\n    // 使用多种基本数据类型来初始化数组\n    var numbers = [5]int{}\n    var decimals = [5]float64{}\n    var characters = [5]byte{}\n    var bools = [5]bool{}\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"\"\n    // 使用多种基本数据类型来初始化数组\n    let numbers = Array(repeating: Int(), count: 5)\n    let decimals = Array(repeating: Double(), count: 5)\n    let characters = Array(repeating: Character(\"a\"), count: 5)\n    let bools = Array(repeating: Bool(), count: 5)\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"\"\n    // JavaScript 的数组可以自由存储各种基本数据类型和对象\n    const array = [0, 0.0, 'a', false];\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"\"\n    // 使用多种基本数据类型来初始化数组\n    const numbers: number[] = [];\n    const characters: string[] = [];\n    const bools: boolean[] = [];\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"\"\n    // 使用多种基本数据类型来初始化数组\n    List<int> numbers = List.filled(5, 0);\n    List<double> decimals = List.filled(5, 0.0);\n    List<String> characters = List.filled(5, 'a');\n    List<bool> bools = List.filled(5, false);\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"\"\n    // 使用多种基本数据类型来初始化数组\n    let numbers: Vec<i32> = vec![0; 5];\n    let decimals: Vec<float> = vec![0.0, 5];\n    let characters: Vec<char> = vec!['0'; 5];\n    let bools: Vec<bool> = vec![false; 5];\n    ```\n\n=== \"C\"\n\n    ```c title=\"\"\n    // 使用多种基本数据类型来初始化数组\n    int numbers[10];\n    float decimals[10];\n    char characters[10];\n    bool bools[10];\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"\"\n    \n    ```",
          "questions": [
            "基本数据类型是什么？它们在算法中的作用是什么？",
            "基本数据类型以什么形式存储在计算机中？",
            "一个二进制位是多少比特？一个字节由多少比特组成？",
            "基本数据类型的取值范围取决于什么？以 Java 为例，各种基本数据类型的占用空间、取值范围和默认值是什么？",
            "基本数据类型与数据结构之间有什么联系？它们分别提供了什么？",
            "如何使用数组来存储不同的基本数据类型？请举例说明。",
            "C 和 C++ 中基本数据类型的大小取决于什么？为什么？",
            "字符 `char` 的大小在 C 和 C++ 中是多少字节？在大多数编程语言中取决于什么？",
            "布尔量在内存中通常被存储为多少字节？为什么？",
            "什么是 LP64 数据模型？它在哪些操作系统中使用？"
          ]
        }
      ]
    },
    {
      "file_name": "n_queens_problem.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# N 皇后问题\n\n!!! question\n\n    根据国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。给定 $n$ 个皇后和一个 $n \\times n$ 大小的棋盘，寻找使得所有皇后之间无法相互攻击的摆放方案。\n\n如下图所示，当 $n = 4$ 时，共可以找到两个解。从回溯算法的角度看，$n \\times n$ 大小的棋盘共有 $n^2$ 个格子，给出了所有的选择 `choices` 。在逐个放置皇后的过程中，棋盘状态在不断地变化，每个时刻的棋盘就是状态 `state` 。\n\n![4 皇后问题的解](n_queens_problem.assets/solution_4_queens.png)\n\n下图展示了本题的三个约束条件：**多个皇后不能在同一行、同一列、同一对角线**。值得注意的是，对角线分为主对角线 `\\` 和次对角线 `/` 两种。\n\n![n 皇后问题的约束条件](n_queens_problem.assets/n_queens_constraints.png)\n\n### 逐行放置策略\n\n皇后的数量和棋盘的行数都为 $n$ ，因此我们容易得到一个推论：**棋盘每行都允许且只允许放置一个皇后**。\n\n也就是说，我们可以采取逐行放置策略：从第一行开始，在每行放置一个皇后，直至最后一行结束。\n\n如下图所示，为 $4$ 皇后问题的逐行放置过程。受画幅限制，下图仅展开了第一行的其中一个搜索分支，并且将不满足列约束和对角线约束的方案都进行了剪枝。\n\n![逐行放置策略](n_queens_problem.assets/n_queens_placing.png)\n\n本质上看，**逐行放置策略起到了剪枝的作用**，它避免了同一行出现多个皇后的所有搜索分支。\n\n### 列与对角线剪枝\n\n为了满足列约束，我们可以利用一个长度为 $n$ 的布尔型数组 `cols` 记录每一列是否有皇后。在每次决定放置前，我们通过 `cols` 将已有皇后的列进行剪枝，并在回溯中动态更新 `cols` 的状态。\n\n那么，如何处理对角线约束呢？设棋盘中某个格子的行列索引为 $(row, col)$ ，选定矩阵中的某条主对角线，我们发现该对角线上所有格子的行索引减列索引都相等，**即对角线上所有格子的 $row - col$ 为恒定值**。\n\n也就是说，如果两个格子满足 $row_1 - col_1 = row_2 - col_2$ ，则它们一定处在同一条主对角线上。利用该规律，我们可以借助下图所示的数组 `diag1` ，记录每条主对角线上是否有皇后。\n\n同理，**次对角线上的所有格子的 $row + col$ 是恒定值**。我们同样也可以借助数组 `diag2` 来处理次对角线约束。\n\n![处理列约束和对角线约束](n_queens_problem.assets/n_queens_cols_diagonals.png)\n\n### 代码实现\n\n请注意，$n$ 维方阵中 $row - col$ 的范围是 $[-n + 1, n - 1]$ ，$row + col$ 的范围是 $[0, 2n - 2]$ ，所以主对角线和次对角线的数量都为 $2n - 1$ ，即数组 `diag1` 和 `diag2` 的长度都为 $2n - 1$ 。\n\n```src\n[file]{n_queens}-[class]{}-[func]{n_queens}\n```\n\n逐行放置 $n$ 次，考虑列约束，则从第一行到最后一行分别有 $n$、$n-1$、$\\dots$、$2$、$1$ 个选择，**因此时间复杂度为 $O(n!)$** 。实际上，根据对角线约束的剪枝也能够大幅地缩小搜索空间，因而搜索效率往往优于以上时间复杂度。\n\n数组 `state` 使用 $O(n^2)$ 空间，数组 `cols`、`diags1` 和 `diags2` 皆使用 $O(n)$ 空间。最大递归深度为 $n$ ，使用 $O(n)$ 栈帧空间。因此，**空间复杂度为 $O(n^2)$** 。",
          "questions": [
            "如何利用逐行放置策略来剪枝搜索空间？",
            "如何利用布尔型数组 `cols` 来处理列约束？",
            "如何利用数组 `diag1` 和 `diag2` 来处理对角线约束？",
            "为什么逐行放置策略可以避免同一行出现多个皇后的所有搜索分支？",
            "为什么主对角线上所有格子的 $row - col$ 为恒定值？",
            "为什么次对角线上所有格子的 $row + col$ 是恒定值？",
            "为什么主对角线和次对角线的数量都为 $2n - 1$？",
            "时间复杂度为什么是 $O(n!)$？",
            "空间复杂度为什么是 $O(n^2)$？",
            "为什么最大递归深度为 $n$，使用 $O(n)$ 栈帧空间？"
          ]
        }
      ]
    },
    {
      "file_name": "deque.md",
      "question_count": 10,
      "documents": [
        {
          "content": "## 双向队列实现 *\n\n双向队列的实现与队列类似，可以选择链表或数组作为底层数据结构。\n\n### 基于双向链表的实现\n\n回顾上一节内容，我们使用普通单向链表来实现队列，因为它可以方便地删除头节点（对应出队操作）和在尾节点后添加新节点（对应入队操作）。\n\n对于双向队列而言，头部和尾部都可以执行入队和出队操作。换句话说，双向队列需要实现另一个对称方向的操作。为此，我们采用“双向链表”作为双向队列的底层数据结构。\n\n如下图所示，我们将双向链表的头节点和尾节点视为双向队列的队首和队尾，同时实现在两端添加和删除节点的功能。\n\n=== \"LinkedListDeque\"\n    ![基于链表实现双向队列的入队出队操作](deque.assets/linkedlist_deque.png)\n\n=== \"pushLast()\"\n    ![linkedlist_deque_push_last](deque.assets/linkedlist_deque_push_last.png)\n\n=== \"pushFirst()\"\n    ![linkedlist_deque_push_first](deque.assets/linkedlist_deque_push_first.png)\n\n=== \"popLast()\"\n    ![linkedlist_deque_pop_last](deque.assets/linkedlist_deque_pop_last.png)\n\n=== \"popFirst()\"\n    ![linkedlist_deque_pop_first](deque.assets/linkedlist_deque_pop_first.png)\n\n实现代码如下所示。\n\n```src\n[file]{linkedlist_deque}-[class]{linked_list_deque}-[func]{}\n```\n\n### 基于数组的实现\n\n如下图所示，与基于数组实现队列类似，我们也可以使用环形数组来实现双向队列。\n\n=== \"ArrayDeque\"\n    ![基于数组实现双向队列的入队出队操作](deque.assets/array_deque.png)\n\n=== \"pushLast()\"\n    ![array_deque_push_last](deque.assets/array_deque_push_last.png)\n\n=== \"pushFirst()\"\n    ![array_deque_push_first](deque.assets/array_deque_push_first.png)\n\n=== \"popLast()\"\n    ![array_deque_pop_last](deque.assets/array_deque_pop_last.png)\n\n=== \"popFirst()\"\n    ![array_deque_pop_first](deque.assets/array_deque_pop_first.png)\n\n在队列的实现基础上，仅需增加“队首入队”和“队尾出队”的方法。\n\n```src\n[file]{array_deque}-[class]{array_deque}-[func]{}\n```\n\n## 双向队列应用\n\n双向队列兼具栈与队列的逻辑，**因此它可以实现这两者的所有应用场景，同时提供更高的自由度**。\n\n我们知道，软件的“撤销”功能通常使用栈来实现：系统将每次更改操作 `push` 到栈中，然后通过 `pop` 实现撤销。然而，考虑到系统资源的限制，软件通常会限制撤销的步数（例如仅允许保存 $50$ 步）。当栈的长度超过 $50$ 时，软件需要在栈底（即队首）执行删除操作。**但栈无法实现该功能，此时就需要使用双向队列来替代栈**。请注意，“撤销”的核心逻辑仍然遵循栈的先入后出原则，只是双向队列能够更加灵活地实现一些额外逻辑。",
          "questions": [
            "双向队列与队列的底层数据结构有什么不同？",
            "双向队列需要实现哪些对称方向的操作？",
            "为什么使用双向链表作为双向队列的底层数据结构？",
            "双向队列的头部和尾部都可以执行哪些操作？",
            "基于数组的实现中，为什么需要使用环形数组？",
            "双向队列相比于栈和队列有什么优势？",
            "如何使用双向队列实现撤销功能？",
            "双向队列能否同时实现栈和队列的所有应用场景？",
            "双向队列的实现代码中，pushLast()和pushFirst()的区别是什么？",
            "双向队列的实现代码中，popLast()和popFirst()的区别是什么？"
          ]
        }
      ]
    },
    {
      "file_name": "list.md",
      "question_count": 30,
      "documents": [
        {
          "content": "# 列表\n\n「列表 list」是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无需使用者考虑容量限制的问题。列表可以基于链表或数组实现。\n\n- 链表天然可以被看作是一个列表，其支持元素增删查改操作，并且可以灵活动态扩容。\n- 数组也支持元素增删查改，但由于其长度不可变，因此只能被看作是一个具有长度限制的列表。\n\n当使用数组实现列表时，**长度不可变的性质会导致列表的实用性降低**。这是因为我们通常无法事先确定需要存储多少数据，从而难以选择合适的列表长度。若长度过小，则很可能无法满足使用需求；若长度过大，则会造成内存空间的浪费。\n\n为解决此问题，我们可以使用「动态数组 dynamic array」来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。\n\n实际上，**许多编程语言中的标准库提供的列表都是基于动态数组实现的**，例如 Python 中的 `list` 、Java 中的 `ArrayList` 、C++ 中的 `vector` 和 C# 中的 `List` 等。在接下来的讨论中，我们将把“列表”和“动态数组”视为等同的概念。\n\n## 列表常用操作\n\n### 初始化列表\n\n我们通常使用“无初始值”和“有初始值”这两种初始化方法。\n\n=== \"Python\"\n\n    ```python title=\"list.py\"\n    # 初始化列表\n    # 无初始值\n    nums1: nums[int] = []\n    # 有初始值\n    nums: nums[int] = [1, 3, 2, 5, 4]\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"list.cpp\"\n    /* 初始化列表 */\n    // 需注意，C++ 中 vector 即是本文描述的 nums\n    // 无初始值\n    vector<int> nums1;\n    // 有初始值\n    vector<int> nums = { 1, 3, 2, 5, 4 };\n    ```\n\n=== \"Java\"\n\n    ```java title=\"list.java\"\n    /* 初始化列表 */\n    // 无初始值\n    List<Integer> nums1 = new ArrayList<>();\n    // 有初始值（注意数组的元素类型需为 int[] 的包装类 Integer[]）\n    Integer[] numbers = new Integer[] { 1, 3, 2, 5, 4 };\n    List<Integer> nums = new ArrayList<>(Arrays.asList(numbers));\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"list.cs\"\n    /* 初始化列表 */\n    // 无初始值\n    List<int> nums1 = new();\n    // 有初始值\n    int[] numbers = new int[] { 1, 3, 2, 5, 4 };\n    List<int> nums = numbers.ToList();\n    ```\n\n=== \"Go\"\n\n    ```go title=\"list_test.go\"\n    /* 初始化列表 */\n    // 无初始值\n    nums1 := []int\n    // 有初始值\n    nums := []int{1, 3, 2, 5, 4}\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"list.swift\"\n    /* 初始化列表 */\n    // 无初始值\n    let nums1: [Int] = []\n    // 有初始值\n    var nums = [1, 3, 2, 5, 4]\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"list.js\"\n    /* 初始化列表 */\n    // 无初始值\n    const nums1 = [];\n    // 有初始值\n    const nums = [1, 3, 2, 5, 4];\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"list.ts\"\n    /* 初始化列表 */\n    // 无初始值\n    const nums1: number[] = [];\n    // 有初始值\n    const nums: number[] = [1, 3, 2, 5, 4];\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"list.dart\"\n    /* 初始化列表 */\n    // 无初始值\n    List<int> nums1 = [];\n    // 有初始值\n    List<int> nums = [1, 3, 2, 5, 4];\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"list.rs\"\n    /* 初始化列表 */\n    // 无初始值\n    let nums1: Vec<i32> = Vec::new();\n    // 有初始值\n    let nums: Vec<i32> = vec![1, 3, 2, 5, 4];\n    ```\n\n=== \"C\"\n\n    ```c title=\"list.c\"\n    // C 未提供内置动态数组\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"list.zig\"\n    // 初始化列表\n    var nums = std.ArrayList(i32).init(std.heap.page_allocator);\n    defer nums.deinit();\n    try nums.appendSlice(&[_]i32{ 1, 3, 2, 5, 4 });\n    ```\n\n### 访问元素\n\n列表本质上是数组，因此可以在 $O(1)$ 时间内访问和更新元素，效率很高。\n\n=== \"Python\"\n\n    ```python title=\"list.py\"\n    # 访问元素\n    num: int = nums[1]  # 访问索引 1 处的元素\n\n    # 更新元素\n    nums[1] = 0    # 将索引 1 处的元素更新为 0\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"list.cpp\"\n    /* 访问元素 */\n    int num = nums[1];  // 访问索引 1 处的元素\n\n    /* 更新元素 */\n    nums[1] = 0;  // 将索引 1 处的元素更新为 0\n    ```\n\n=== \"Java\"\n\n    ```java title=\"list.java\"\n    /* 访问元素 */\n    int num = nums.get(1);  // 访问索引 1 处的元素\n\n    /* 更新元素 */\n    nums.set(1, 0);  // 将索引 1 处的元素更新为 0\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"list.cs\"\n    /* 访问元素 */\n    int num = nums[1];  // 访问索引 1 处的元素\n\n    /* 更新元素 */\n    nums[1] = 0;  // 将索引 1 处的元素更新为 0\n    ```\n\n=== \"Go\"\n\n    ```go title=\"list_test.go\"\n    /* 访问元素 */\n    num := nums[1]  // 访问索引 1 处的元素\n\n    /* 更新元素 */\n    nums[1] = 0     // 将索引 1 处的元素更新为 0\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"list.swift\"\n    /* 访问元素 */\n    let num = nums[1] // 访问索引 1 处的元素\n\n    /* 更新元素 */\n    nums[1] = 0 // 将索引 1 处的元素更新为 0\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"list.js\"\n    /* 访问元素 */\n    const num = nums[1];  // 访问索引 1 处的元素\n\n    /* 更新元素 */\n    nums[1] = 0;  // 将索引 1 处的元素更新为 0\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"list.ts\"\n    /* 访问元素 */\n    const num: number = nums[1];  // 访问索引 1 处的元素\n\n    /* 更新元素 */\n    nums[1] = 0;  // 将索引 1 处的元素更新为 0\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"list.dart\"\n    /* 访问元素 */\n    int num = nums[1];  // 访问索引 1 处的元素\n\n    /* 更新元素 */\n    nums[1] = 0;  // 将索引 1 处的元素更新为 0\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"list.rs\"\n    /* 访问元素 */\n    let num: i32 = nums[1];  // 访问索引 1 处的元素\n    /* 更新元素 */\n    nums[1] = 0;             // 将索引 1 处的元素更新为 0\n    ```\n\n=== \"C\"\n\n    ```c title=\"list.c\"\n    // C 未提供内置动态数组\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"list.zig\"\n    // 访问元素\n    var num = nums.items[1]; // 访问索引 1 处的元素\n\n    // 更新元素\n    nums.items[1] = 0; // 将索引 1 处的元素更新为 0  \n    ```",
          "questions": [
            "列表可以基于哪两种数据结构实现？",
            "数组作为列表的实现方式有哪些缺点？",
            "动态数组相比于数组的优点是什么？",
            "常见编程语言中的标准库提供的列表都是基于哪种数据结构实现的？",
            "如何初始化一个空列表？如何初始化一个有初始值的列表？",
            "如何访问列表中的元素？如何更新列表中的元素？",
            "在Java中，如何将一个数组转换为列表？",
            "在C#中，如何将一个数组转换为列表？",
            "在Go中，如何访问和更新列表中的元素？",
            "在Rust中，如何访问和更新列表中的元素？"
          ]
        },
        {
          "content": "### 插入与删除元素\n\n相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为 $O(1)$ ，但插入和删除元素的效率仍与数组相同，时间复杂度为 $O(n)$ 。\n\n=== \"Python\"\n\n    ```python title=\"list.py\"\n    # 清空列表\n    nums.clear()\n\n    # 尾部添加元素\n    nums.append(1)\n    nums.append(3)\n    nums.append(2)\n    nums.append(5)\n    nums.append(4)\n\n    # 中间插入元素\n    nums.insert(3, 6)  # 在索引 3 处插入数字 6\n\n    # 删除元素\n    nums.pop(3)        # 删除索引 3 处的元素\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"list.cpp\"\n    /* 清空列表 */\n    nums.clear();\n\n    /* 尾部添加元素 */\n    nums.push_back(1);\n    nums.push_back(3);\n    nums.push_back(2);\n    nums.push_back(5);\n    nums.push_back(4);\n\n    /* 中间插入元素 */\n    nums.insert(nums.begin() + 3, 6);  // 在索引 3 处插入数字 6\n\n    /* 删除元素 */\n    nums.erase(nums.begin() + 3);      // 删除索引 3 处的元素\n    ```\n\n=== \"Java\"\n\n    ```java title=\"list.java\"\n    /* 清空列表 */\n    nums.clear();\n\n    /* 尾部添加元素 */\n    nums.add(1);\n    nums.add(3);\n    nums.add(2);\n    nums.add(5);\n    nums.add(4);\n\n    /* 中间插入元素 */\n    nums.add(3, 6);  // 在索引 3 处插入数字 6\n\n    /* 删除元素 */\n    nums.remove(3);  // 删除索引 3 处的元素\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"list.cs\"\n    /* 清空列表 */\n    nums.Clear();\n\n    /* 尾部添加元素 */\n    nums.Add(1);\n    nums.Add(3);\n    nums.Add(2);\n    nums.Add(5);\n    nums.Add(4);\n\n    /* 中间插入元素 */\n    nums.Insert(3, 6);\n\n    /* 删除元素 */\n    nums.RemoveAt(3);\n    ```\n\n=== \"Go\"\n\n    ```go title=\"list_test.go\"\n    /* 清空列表 */\n    nums = nil\n\n    /* 尾部添加元素 */\n    nums = append(nums, 1)\n    nums = append(nums, 3)\n    nums = append(nums, 2)\n    nums = append(nums, 5)\n    nums = append(nums, 4)\n\n    /* 中间插入元素 */\n    nums = append(nums[:3], append([]int{6}, nums[3:]...)...) // 在索引 3 处插入数字 6\n\n    /* 删除元素 */\n    nums = append(nums[:3], nums[4:]...) // 删除索引 3 处的元素\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"list.swift\"\n    /* 清空列表 */\n    nums.removeAll()\n\n    /* 尾部添加元素 */\n    nums.append(1)\n    nums.append(3)\n    nums.append(2)\n    nums.append(5)\n    nums.append(4)\n\n    /* 中间插入元素 */\n    nums.insert(6, at: 3) // 在索引 3 处插入数字 6\n\n    /* 删除元素 */\n    nums.remove(at: 3) // 删除索引 3 处的元素\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"list.js\"\n    /* 清空列表 */\n    nums.length = 0;\n\n    /* 尾部添加元素 */\n    nums.push(1);\n    nums.push(3);\n    nums.push(2);\n    nums.push(5);\n    nums.push(4);\n\n    /* 中间插入元素 */\n    nums.splice(3, 0, 6);\n\n    /* 删除元素 */\n    nums.splice(3, 1);\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"list.ts\"\n    /* 清空列表 */\n    nums.length = 0;\n\n    /* 尾部添加元素 */\n    nums.push(1);\n    nums.push(3);\n    nums.push(2);\n    nums.push(5);\n    nums.push(4);\n\n    /* 中间插入元素 */\n    nums.splice(3, 0, 6);\n\n    /* 删除元素 */\n    nums.splice(3, 1);\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"list.dart\"\n    /* 清空列表 */\n    nums.clear();\n\n    /* 尾部添加元素 */\n    nums.add(1);\n    nums.add(3);\n    nums.add(2);\n    nums.add(5);\n    nums.add(4);\n\n    /* 中间插入元素 */\n    nums.insert(3, 6); // 在索引 3 处插入数字 6\n\n    /* 删除元素 */\n    nums.removeAt(3); // 删除索引 3 处的元素\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"list.rs\"\n    /* 清空列表 */\n    nums.clear();\n\n    /* 尾部添加元素 */\n    nums.push(1);\n    nums.push(3);\n    nums.push(2);\n    nums.push(5);\n    nums.push(4);\n\n    /* 中间插入元素 */\n    nums.insert(3, 6);  // 在索引 3 处插入数字 6\n\n    /* 删除元素 */\n    nums.remove(3);    // 删除索引 3 处的元素\n    ```\n\n=== \"C\"\n\n    ```c title=\"list.c\"\n    // C 未提供内置动态数组\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"list.zig\"\n    // 清空列表\n    nums.clearRetainingCapacity();\n\n    // 尾部添加元素\n    try nums.append(1);\n    try nums.append(3);\n    try nums.append(2);\n    try nums.append(5);\n    try nums.append(4);\n\n    // 中间插入元素\n    try nums.insert(3, 6); // 在索引 3 处插入数字 6\n\n    // 删除元素\n    _ = nums.orderedRemove(3); // 删除索引 3 处的元素\n    ```\n\n### 遍历列表\n\n与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。\n\n=== \"Python\"\n\n    ```python title=\"list.py\"\n    # 通过索引遍历列表\n    count = 0\n    for i in range(len(nums)):\n        count += 1\n\n    # 直接遍历列表元素\n    count = 0\n    for num in nums:\n        count += 1\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"list.cpp\"\n    /* 通过索引遍历列表 */\n    int count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        count++;\n    }\n\n    /* 直接遍历列表元素 */\n    count = 0;\n    for (int num : nums) {\n        count++;\n    }\n    ```\n\n=== \"Java\"\n\n    ```java title=\"list.java\"\n    /* 通过索引遍历列表 */\n    int count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        count++;\n    }\n\n    /* 直接遍历列表元素 */\n    count = 0;\n    for (int num : nums) {\n        count++;\n    }\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"list.cs\"\n    /* 通过索引遍历列表 */\n    int count = 0;\n    for (int i = 0; i < nums.Count; i++) {\n        count++;\n    }\n\n    /* 直接遍历列表元素 */\n    count = 0;\n    foreach (int num in nums) {\n        count++;\n    }\n    ```\n\n=== \"Go\"\n\n    ```go title=\"list_test.go\"\n    /* 通过索引遍历列表 */\n    count := 0\n    for i := 0; i < len(nums); i++ {\n        count++\n    }\n\n    /* 直接遍历列表元素 */\n    count = 0\n    for range nums {\n        count++\n    }\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"list.swift\"\n    /* 通过索引遍历列表 */\n    var count = 0\n    for _ in nums.indices {\n        count += 1\n    }\n\n    /* 直接遍历列表元素 */\n    count = 0\n    for _ in nums {\n        count += 1\n    }\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"list.js\"\n    /* 通过索引遍历列表 */\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        count++;\n    }\n\n    /* 直接遍历列表元素 */\n    count = 0;\n    for (const num of nums) {\n        count++;\n    }\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"list.ts\"\n    /* 通过索引遍历列表 */\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        count++;\n    }\n\n    /* 直接遍历列表元素 */\n    count = 0;\n    for (const num of nums) {\n        count++;\n    }\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"list.dart\"\n    /* 通过索引遍历列表 */\n    int count = 0;\n    for (int i = 0; i < nums.length; i++) {\n        count++;\n    }\n\n    /* 直接遍历列表元素 */\n    count = 0;\n    for (int num in nums) {\n        count++;\n    }\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"list.rs\"\n    /* 通过索引遍历列表 */\n    let mut count = 0;\n    for (index, value) in nums.iter().enumerate() {\n        count += 1;\n    }\n\n    /* 直接遍历列表元素 */\n    let mut count = 0;\n    for value in nums.iter() {\n        count += 1;\n    }\n    ```\n\n=== \"C\"\n\n    ```c title=\"list.c\"\n    // C 未提供内置动态数组\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"list.zig\"\n    // 通过索引遍历列表\n    var count: i32 = 0;\n    var i: i32 = 0;\n    while (i < nums.items.len) : (i += 1) {\n        count += 1;\n    }\n\n    // 直接遍历列表元素\n    count = 0;\n    for (nums.items) |_| {\n        count += 1;\n    }\n    ```",
          "questions": [
            "列表相较于数组的优势是什么？",
            "在 Python 中，如何清空一个列表？",
            "在 C++ 中，如何通过索引遍历一个列表？",
            "在 Java 中，如何直接遍历一个列表的元素？",
            "在 C# 中，如何删除一个列表中指定索引的元素？",
            "在 Go 中，如何在列表中间插入一个元素？",
            "在 Swift 中，如何通过索引遍历一个列表？",
            "在 JavaScript 中，如何直接遍历一个列表的元素？",
            "在 Dart 中，如何删除一个列表中指定索引的元素？",
            "在 Rust 中，如何通过索引遍历一个列表？"
          ]
        },
        {
          "content": "### 拼接列表\n\n给定一个新列表 `nums1` ，我们可以将该列表拼接到原列表的尾部。\n\n=== \"Python\"\n\n    ```python title=\"list.py\"\n    # 拼接两个列表\n    nums1: nums[int] = [6, 8, 7, 10, 9]\n    nums += nums1  # 将列表 nums1 拼接到 nums 之后\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"list.cpp\"\n    /* 拼接两个列表 */\n    vector<int> nums1 = { 6, 8, 7, 10, 9 };\n    // 将列表 nums1 拼接到 nums 之后\n    nums.insert(nums.end(), nums1.begin(), nums1.end());\n    ```\n\n=== \"Java\"\n\n    ```java title=\"list.java\"\n    /* 拼接两个列表 */\n    List<Integer> nums1 = new ArrayList<>(Arrays.asList(new Integer[] { 6, 8, 7, 10, 9 }));\n    nums.addAll(nums1);  // 将列表 nums1 拼接到 nums 之后\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"list.cs\"\n    /* 拼接两个列表 */\n    List<int> nums1 = new() { 6, 8, 7, 10, 9 };\n    nums.AddRange(nums1);  // 将列表 nums1 拼接到 nums 之后\n    ```\n\n=== \"Go\"\n\n    ```go title=\"list_test.go\"\n    /* 拼接两个列表 */\n    nums1 := []int{6, 8, 7, 10, 9}\n    nums = append(nums, nums1...)  // 将列表 nums1 拼接到 nums 之后\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"list.swift\"\n    /* 拼接两个列表 */\n    let nums1 = [6, 8, 7, 10, 9]\n    nums.append(contentsOf: nums1) // 将列表 nums1 拼接到 nums 之后\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"list.js\"\n    /* 拼接两个列表 */\n    const nums1 = [6, 8, 7, 10, 9];\n    nums.push(...nums1);  // 将列表 nums1 拼接到 nums 之后\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"list.ts\"\n    /* 拼接两个列表 */\n    const nums1: number[] = [6, 8, 7, 10, 9];\n    nums.push(...nums1);  // 将列表 nums1 拼接到 nums 之后\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"list.dart\"\n    /* 拼接两个列表 */\n    List<int> nums1 = [6, 8, 7, 10, 9];\n    nums.addAll(nums1);  // 将列表 nums1 拼接到 nums 之后\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"list.rs\"\n    /* 拼接两个列表 */\n    let nums1: Vec<i32> = vec![6, 8, 7, 10, 9];\n    nums.extend(nums1);\n    ```\n\n=== \"C\"\n\n    ```c title=\"list.c\"\n    // C 未提供内置动态数组\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"list.zig\"\n    // 拼接两个列表\n    var nums1 = std.ArrayList(i32).init(std.heap.page_allocator);\n    defer nums1.deinit();\n    try nums1.appendSlice(&[_]i32{ 6, 8, 7, 10, 9 });\n    try nums.insertSlice(nums.items.len, nums1.items); // 将列表 nums1 拼接到 nums 之后\n    ```\n\n### 排序列表\n\n完成列表排序后，我们便可以使用在数组类算法题中经常考察的“二分查找”和“双指针”算法。\n\n=== \"Python\"\n\n    ```python title=\"list.py\"\n    # 排序列表\n    nums.sort()  # 排序后，列表元素从小到大排列\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"list.cpp\"\n    /* 排序列表 */\n    sort(nums.begin(), nums.end());  // 排序后，列表元素从小到大排列\n    ```\n\n=== \"Java\"\n\n    ```java title=\"list.java\"\n    /* 排序列表 */\n    Collections.sort(nums);  // 排序后，列表元素从小到大排列\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"list.cs\"\n    /* 排序列表 */\n    nums.Sort(); // 排序后，列表元素从小到大排列\n    ```\n\n=== \"Go\"\n\n    ```go title=\"list_test.go\"\n    /* 排序列表 */\n    sort.Ints(nums)  // 排序后，列表元素从小到大排列\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"list.swift\"\n    /* 排序列表 */\n    nums.sort() // 排序后，列表元素从小到大排列\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"list.js\"\n    /* 排序列表 */  \n    nums.sort((a, b) => a - b);  // 排序后，列表元素从小到大排列\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"list.ts\"\n    /* 排序列表 */\n    nums.sort((a, b) => a - b);  // 排序后，列表元素从小到大排列\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"list.dart\"\n    /* 排序列表 */\n    nums.sort(); // 排序后，列表元素从小到大排列\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"list.rs\"\n    /* 排序列表 */\n    nums.sort(); // 排序后，列表元素从小到大排列\n    ```\n\n=== \"C\"\n\n    ```c title=\"list.c\"\n    // C 未提供内置动态数组\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"list.zig\"\n    // 排序列表\n    std.sort.sort(i32, nums.items, {}, comptime std.sort.asc(i32));\n    ```\n\n## 列表实现\n\n许多编程语言都提供内置的列表，例如 Java、C++、Python 等。它们的实现比较复杂，各个参数的设定也非常有考究，例如初始容量、扩容倍数等。感兴趣的读者可以查阅源码进行学习。\n\n为了加深对列表工作原理的理解，我们尝试实现一个简易版列表，包括以下三个重点设计。\n\n- **初始容量**：选取一个合理的数组初始容量。在本示例中，我们选择 10 作为初始容量。\n- **数量记录**：声明一个变量 `size` ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。\n- **扩容机制**：若插入元素时列表容量已满，则需要进行扩容。首先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的 2 倍。\n\n```src\n[file]{my_list}-[class]{my_list}-[func]{}\n```",
          "questions": [
            "如何实现一个简易版列表？",
            "在实现列表时，需要考虑哪些重点设计？",
            "初始容量应该如何选取？",
            "如何记录列表当前元素数量？",
            "如何判断是否需要扩容？",
            "扩容机制是什么？",
            "在本示例中，每次将数组扩容至之前的几倍？",
            "如何将当前数组的所有元素依次移动至新数组？",
            "如何定位列表尾部？",
            "如何判断列表是否为空？"
          ]
        }
      ]
    },
    {
      "file_name": "merge_sort.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 归并排序\n\n「归并排序 merge sort」是一种基于分治策略的排序算法，包含下图所示的“划分”和“合并”阶段。\n\n1. **划分阶段**：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。\n2. **合并阶段**：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。\n\n![归并排序的划分与合并阶段](merge_sort.assets/merge_sort_overview.png)\n\n## 算法流程\n\n如下图所示，“划分阶段”从顶至底递归地将数组从中点切分为两个子数组。\n\n1. 计算数组中点 `mid` ，递归划分左子数组（区间 `[left, mid]` ）和右子数组（区间 `[mid + 1, right]` ）。\n2. 递归执行步骤 `1.` ，直至子数组区间长度为 1 时，终止递归划分。\n\n“合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的。\n\n=== \"<1>\"\n    ![归并排序步骤](merge_sort.assets/merge_sort_step1.png)\n\n=== \"<2>\"\n    ![merge_sort_step2](merge_sort.assets/merge_sort_step2.png)\n\n=== \"<3>\"\n    ![merge_sort_step3](merge_sort.assets/merge_sort_step3.png)\n\n=== \"<4>\"\n    ![merge_sort_step4](merge_sort.assets/merge_sort_step4.png)\n\n=== \"<5>\"\n    ![merge_sort_step5](merge_sort.assets/merge_sort_step5.png)\n\n=== \"<6>\"\n    ![merge_sort_step6](merge_sort.assets/merge_sort_step6.png)\n\n=== \"<7>\"\n    ![merge_sort_step7](merge_sort.assets/merge_sort_step7.png)\n\n=== \"<8>\"\n    ![merge_sort_step8](merge_sort.assets/merge_sort_step8.png)\n\n=== \"<9>\"\n    ![merge_sort_step9](merge_sort.assets/merge_sort_step9.png)\n\n=== \"<10>\"\n    ![merge_sort_step10](merge_sort.assets/merge_sort_step10.png)\n\n观察发现，归并排序与二叉树后序遍历的递归顺序是一致的。\n\n- **后序遍历**：先递归左子树，再递归右子树，最后处理根节点。\n- **归并排序**：先递归左子数组，再递归右子数组，最后处理合并。\n\n```src\n[file]{merge_sort}-[class]{}-[func]{merge_sort}\n```\n\n实现合并函数 `merge()` 存在以下难点。\n\n- **需要特别注意各个变量的含义**。`nums` 的待合并区间为 `[left, right]` ，但由于 `tmp` 仅复制了 `nums` 该区间的元素，因此 `tmp` 对应区间为 `[0, right - left]` 。\n- 在比较 `tmp[i]` 和 `tmp[j]` 的大小时，**还需考虑子数组遍历完成后的索引越界问题**，即 `i > leftEnd` 和 `j > rightEnd` 的情况。索引越界的优先级是最高的，如果左子数组已经被合并完了，那么不需要继续比较，直接合并右子数组元素即可。\n\n## 算法特性\n\n- **时间复杂度 $O(n \\log n)$、非自适应排序**：划分产生高度为 $\\log n$ 的递归树，每层合并的总操作数量为 $n$ ，因此总体时间复杂度为 $O(n \\log n)$ 。\n- **空间复杂度 $O(n)$、非原地排序**：递归深度为 $\\log n$ ，使用 $O(\\log n)$ 大小的栈帧空间。合并操作需要借助辅助数组实现，使用 $O(n)$ 大小的额外空间。\n- **稳定排序**：在合并过程中，相等元素的次序保持不变。\n\n## 链表排序 *\n\n对于链表，归并排序相较于其他排序算法具有显著优势，**可以将链表排序任务的空间复杂度优化至 $O(1)$** 。\n\n- **划分阶段**：可以通过使用“迭代”替代“递归”来实现链表划分工作，从而省去递归使用的栈帧空间。\n- **合并阶段**：在链表中，节点增删操作仅需改变引用（指针）即可实现，因此合并阶段（将两个短有序链表合并为一个长有序链表）无须创建额外链表。\n\n具体实现细节比较复杂，有兴趣的同学可以查阅相关资料进行学习。",
          "questions": [
            "归并排序的时间复杂度是多少？为什么？",
            "归并排序的空间复杂度是多少？为什么？",
            "归并排序是稳定排序还是非稳定排序？为什么？",
            "归并排序的划分阶段和合并阶段分别是如何实现的？",
            "归并排序的合并函数 `merge()` 实现时需要注意哪些问题？",
            "归并排序与二叉树后序遍历的递归顺序有何关系？",
            "对于链表排序，为什么归并排序的空间复杂度可以优化至 $O(1)$？",
            "在链表排序中，如何实现划分阶段的迭代操作？",
            "在链表排序中，如何实现合并阶段的节点增删操作？",
            "归并排序与快速排序相比，有哪些优缺点？"
          ]
        }
      ]
    },
    {
      "file_name": "binary_search_insertion.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 二分查找插入点\n\n二分查找不仅可用于搜索目标元素，还具有许多变种问题，比如搜索目标元素的插入位置。\n\n## 无重复元素的情况\n\n!!! question\n\n    给定一个长度为 $n$ 的有序数组 `nums` 和一个元素 `target` ，数组不存在重复元素。现将 `target` 插入到数组 `nums` 中，并保持其有序性。若数组中已存在元素 `target` ，则插入到其左方。请返回插入后 `target` 在数组中的索引。\n\n![二分查找插入点示例数据](binary_search_insertion.assets/binary_search_insertion_example.png)\n\n如果想要复用上节的二分查找代码，则需要回答以下两个问题。\n\n**问题一**：当数组中包含 `target` 时，插入点的索引是否是该元素的索引？\n\n题目要求将 `target` 插入到相等元素的左边，这意味着新插入的 `target` 替换了原来 `target` 的位置。也就是说，**当数组包含 `target` 时，插入点的索引就是该 `target` 的索引**。\n\n**问题二**：当数组中不存在 `target` 时，插入点是哪个元素的索引？\n\n进一步思考二分查找过程：当 `nums[m] < target` 时 $i$ 移动，这意味着指针 $i$ 在向大于等于 `target` 的元素靠近。同理，指针 $j$ 始终在向小于等于 `target` 的元素靠近。\n\n因此二分结束时一定有：$i$ 指向首个大于 `target` 的元素，$j$ 指向首个小于 `target` 的元素。**易得当数组不包含 `target` 时，插入索引为 $i$** 。\n\n```src\n[file]{binary_search_insertion}-[class]{}-[func]{binary_search_insertion_simple}\n```\n\n## 存在重复元素的情况\n\n!!! question\n\n    在上一题的基础上，规定数组可能包含重复元素，其余不变。\n\n假设数组中存在多个 `target` ，则普通二分查找只能返回其中一个 `target` 的索引，**而无法确定该元素的左边和右边还有多少 `target`**。\n\n题目要求将目标元素插入到最左边，**所以我们需要查找数组中最左一个 `target` 的索引**。初步考虑通过下图所示的步骤实现。\n\n1. 执行二分查找，得到任意一个 `target` 的索引，记为 $k$ 。\n2. 从索引 $k$ 开始，向左进行线性遍历，当找到最左边的 `target` 时返回。\n\n![线性查找重复元素的插入点](binary_search_insertion.assets/binary_search_insertion_naive.png)\n\n此方法虽然可用，但其包含线性查找，因此时间复杂度为 $O(n)$ 。当数组中存在很多重复的 `target` 时，该方法效率很低。\n\n现考虑拓展二分查找代码。如下图所示，整体流程保持不变，每轮先计算中点索引 $m$ ，再判断 `target` 和 `nums[m]` 大小关系，分为以下几种情况。\n\n- 当 `nums[m] < target` 或 `nums[m] > target` 时，说明还没有找到 `target` ，因此采用普通二分查找的缩小区间操作，**从而使指针 $i$ 和 $j$ 向 `target` 靠近**。\n- 当 `nums[m] == target` 时，说明小于 `target` 的元素在区间 $[i, m - 1]$ 中，因此采用 $j = m - 1$ 来缩小区间，**从而使指针 $j$ 向小于 `target` 的元素靠近**。\n\n循环完成后，$i$ 指向最左边的 `target` ，$j$ 指向首个小于 `target` 的元素，**因此索引 $i$ 就是插入点**。\n\n=== \"<1>\"\n    ![二分查找重复元素的插入点的步骤](binary_search_insertion.assets/binary_search_insertion_step1.png)\n\n=== \"<2>\"\n    ![binary_search_insertion_step2](binary_search_insertion.assets/binary_search_insertion_step2.png)\n\n=== \"<3>\"\n    ![binary_search_insertion_step3](binary_search_insertion.assets/binary_search_insertion_step3.png)\n\n=== \"<4>\"\n    ![binary_search_insertion_step4](binary_search_insertion.assets/binary_search_insertion_step4.png)\n\n=== \"<5>\"\n    ![binary_search_insertion_step5](binary_search_insertion.assets/binary_search_insertion_step5.png)\n\n=== \"<6>\"\n    ![binary_search_insertion_step6](binary_search_insertion.assets/binary_search_insertion_step6.png)\n\n=== \"<7>\"\n    ![binary_search_insertion_step7](binary_search_insertion.assets/binary_search_insertion_step7.png)\n\n=== \"<8>\"\n    ![binary_search_insertion_step8](binary_search_insertion.assets/binary_search_insertion_step8.png)\n\n观察以下代码，判断分支 `nums[m] > target` 和 `nums[m] == target` 的操作相同，因此两者可以合并。\n\n即便如此，我们仍然可以将判断条件保持展开，因为其逻辑更加清晰、可读性更好。\n\n```src\n[file]{binary_search_insertion}-[class]{}-[func]{binary_search_insertion}\n```\n\n!!! tip\n\n    本节的代码都是“双闭区间”写法。有兴趣的读者可以自行实现“左闭右开”写法。\n\n总的来看，二分查找无非就是给指针 $i$ 和 $j$ 分别设定搜索目标，目标可能是一个具体的元素（例如 `target` ），也可能是一个元素范围（例如小于 `target` 的元素）。\n\n在不断的循环二分中，指针 $i$ 和 $j$ 都逐渐逼近预先设定的目标。最终，它们或是成功找到答案，或是越过边界后停止。",
          "questions": [
            "二分查找插入点的时间复杂度是多少？",
            "当数组中存在多个重复的target时，如何确定该元素的左边和右边还有多少target？",
            "为什么当nums[m] < target时，指针i和j会向target靠近？",
            "为什么当nums[m] > target时，指针i和j会向target靠近？",
            "为什么当nums[m] == target时，采用j = m - 1来缩小区间？",
            "为什么当nums[m] == target时，小于target的元素在区间[i, m - 1]中？",
            "为什么当数组包含target时，插入点的索引就是该target的索引？",
            "当数组不包含target时，插入索引为什么是i？",
            "为什么本节的代码都是“双闭区间”写法？",
            "二分查找的指针i和j分别设定搜索目标，目标可能是什么？"
          ]
        }
      ]
    },
    {
      "file_name": "edit_distance_problem.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 编辑距离问题\n\n编辑距离，也被称为 Levenshtein 距离，指两个字符串之间互相转换的最小修改次数，通常用于在信息检索和自然语言处理中度量两个序列的相似度。\n\n!!! question\n\n    输入两个字符串 $s$ 和 $t$ ，返回将 $s$ 转换为 $t$ 所需的最少编辑步数。\n    \n    你可以在一个字符串中进行三种编辑操作：插入一个字符、删除一个字符、替换字符为任意一个字符。\n\n如下图所示，将 `kitten` 转换为 `sitting` 需要编辑 3 步，包括 2 次替换操作与 1 次添加操作；将 `hello` 转换为 `algo` 需要 3 步，包括 2 次替换操作和 1 次删除操作。\n\n![编辑距离的示例数据](edit_distance_problem.assets/edit_distance_example.png)\n\n**编辑距离问题可以很自然地用决策树模型来解释**。字符串对应树节点，一轮决策（一次编辑操作）对应树的一条边。\n\n如下图所示，在不限制操作的情况下，每个节点都可以派生出许多条边，每条边对应一种操作，这意味着从 `hello` 转换到 `algo` 有许多种可能的路径。\n\n从决策树的角度看，本题的目标是求解节点 `hello` 和节点 `algo` 之间的最短路径。\n\n![基于决策树模型表示编辑距离问题](edit_distance_problem.assets/edit_distance_decision_tree.png)\n\n### 动态规划思路\n\n**第一步：思考每轮的决策，定义状态，从而得到 $dp$ 表**\n\n每一轮的决策是对字符串 $s$ 进行一次编辑操作。\n\n我们希望在编辑操作的过程中，问题的规模逐渐缩小，这样才能构建子问题。设字符串 $s$ 和 $t$ 的长度分别为 $n$ 和 $m$ ，我们先考虑两字符串尾部的字符 $s[n-1]$ 和 $t[m-1]$ 。\n\n- 若 $s[n-1]$ 和 $t[m-1]$ 相同，我们可以跳过它们，直接考虑 $s[n-2]$ 和 $t[m-2]$ 。\n- 若 $s[n-1]$ 和 $t[m-1]$ 不同，我们需要对 $s$ 进行一次编辑（插入、删除、替换），使得两字符串尾部的字符相同，从而可以跳过它们，考虑规模更小的问题。\n\n也就是说，我们在字符串 $s$ 中进行的每一轮决策（编辑操作），都会使得 $s$ 和 $t$ 中剩余的待匹配字符发生变化。因此，状态为当前在 $s$ 和 $t$ 中考虑的第 $i$ 和 $j$ 个字符，记为 $[i, j]$ 。\n\n状态 $[i, j]$ 对应的子问题：**将 $s$ 的前 $i$ 个字符更改为 $t$ 的前 $j$ 个字符所需的最少编辑步数**。\n\n至此，得到一个尺寸为 $(i+1) \\times (j+1)$ 的二维 $dp$ 表。\n\n**第二步：找出最优子结构，进而推导出状态转移方程**\n\n考虑子问题 $dp[i, j]$ ，其对应的两个字符串的尾部字符为 $s[i-1]$ 和 $t[j-1]$ ，可根据不同编辑操作分为下图所示的三种情况。\n\n1. 在 $s[i-1]$ 之后添加 $t[j-1]$ ，则剩余子问题 $dp[i, j-1]$ 。\n2. 删除 $s[i-1]$ ，则剩余子问题 $dp[i-1, j]$ 。\n3. 将 $s[i-1]$ 替换为 $t[j-1]$ ，则剩余子问题 $dp[i-1, j-1]$ 。\n\n![编辑距离的状态转移](edit_distance_problem.assets/edit_distance_state_transfer.png)\n\n根据以上分析，可得最优子结构：$dp[i, j]$ 的最少编辑步数等于 $dp[i, j-1]$、$dp[i-1, j]$、$dp[i-1, j-1]$ 三者中的最少编辑步数，再加上本次的编辑步数 $1$ 。对应的状态转移方程为：\n\n$$\ndp[i, j] = \\min(dp[i, j-1], dp[i-1, j], dp[i-1, j-1]) + 1\n$$\n\n请注意，**当 $s[i-1]$ 和 $t[j-1]$ 相同时，无须编辑当前字符**，这种情况下的状态转移方程为：\n\n$$\ndp[i, j] = dp[i-1, j-1]\n$$\n\n**第三步：确定边界条件和状态转移顺序**\n\n当两字符串都为空时，编辑步数为 $0$ ，即 $dp[0, 0] = 0$ 。当 $s$ 为空但 $t$ 不为空时，最少编辑步数等于 $t$ 的长度，即首行 $dp[0, j] = j$ 。当 $s$ 不为空但 $t$ 为空时，等于 $s$ 的长度，即首列 $dp[i, 0] = i$ 。\n\n观察状态转移方程，解 $dp[i, j]$ 依赖左方、上方、左上方的解，因此通过两层循环正序遍历整个 $dp$ 表即可。\n\n### 代码实现\n\n```src\n[file]{edit_distance}-[class]{}-[func]{edit_distance_dp}\n```\n\n如下图所示，编辑距离问题的状态转移过程与背包问题非常类似，都可以看作是填写一个二维网格的过程。\n\n=== \"<1>\"\n    ![编辑距离的动态规划过程](edit_distance_problem.assets/edit_distance_dp_step1.png)\n\n=== \"<2>\"\n    ![edit_distance_dp_step2](edit_distance_problem.assets/edit_distance_dp_step2.png)\n\n=== \"<3>\"\n    ![edit_distance_dp_step3](edit_distance_problem.assets/edit_distance_dp_step3.png)\n\n=== \"<4>\"\n    ![edit_distance_dp_step4](edit_distance_problem.assets/edit_distance_dp_step4.png)\n\n=== \"<5>\"\n    ![edit_distance_dp_step5](edit_distance_problem.assets/edit_distance_dp_step5.png)\n\n=== \"<6>\"\n    ![edit_distance_dp_step6](edit_distance_problem.assets/edit_distance_dp_step6.png)\n\n=== \"<7>\"\n    ![edit_distance_dp_step7](edit_distance_problem.assets/edit_distance_dp_step7.png)\n\n=== \"<8>\"\n    ![edit_distance_dp_step8](edit_distance_problem.assets/edit_distance_dp_step8.png)\n\n=== \"<9>\"\n    ![edit_distance_dp_step9](edit_distance_problem.assets/edit_distance_dp_step9.png)\n\n=== \"<10>\"\n    ![edit_distance_dp_step10](edit_distance_problem.assets/edit_distance_dp_step10.png)\n\n=== \"<11>\"\n    ![edit_distance_dp_step11](edit_distance_problem.assets/edit_distance_dp_step11.png)\n\n=== \"<12>\"\n    ![edit_distance_dp_step12](edit_distance_problem.assets/edit_distance_dp_step12.png)\n\n=== \"<13>\"\n    ![edit_distance_dp_step13](edit_distance_problem.assets/edit_distance_dp_step13.png)\n\n=== \"<14>\"\n    ![edit_distance_dp_step14](edit_distance_problem.assets/edit_distance_dp_step14.png)\n\n=== \"<15>\"\n    ![edit_distance_dp_step15](edit_distance_problem.assets/edit_distance_dp_step15.png)\n\n### 空间优化\n\n由于 $dp[i,j]$ 是由上方 $dp[i-1, j]$、左方 $dp[i, j-1]$、左上方状态 $dp[i-1, j-1]$ 转移而来，而正序遍历会丢失左上方 $dp[i-1, j-1]$ ，倒序遍历无法提前构建 $dp[i, j-1]$ ，因此两种遍历顺序都不可取。\n\n为此，我们可以使用一个变量 `leftup` 来暂存左上方的解 $dp[i-1, j-1]$ ，从而只需考虑左方和上方的解。此时的情况与完全背包问题相同，可使用正序遍历。\n\n```src\n[file]{edit_distance}-[class]{}-[func]{edit_distance_dp_comp}\n```",
          "questions": [
            "编辑距离问题的定义是什么？它通常用于哪些领域？",
            "如何用决策树模型表示编辑距离问题？它有什么作用？",
            "在编辑距离问题中，如何定义状态？状态对应的子问题是什么？",
            "编辑距离问题的动态规划思路是什么？它包括哪些步骤？",
            "在编辑距离问题中，如何找出最优子结构？推导出状态转移方程？",
            "编辑距离问题的边界条件是什么？状态转移顺序是什么？",
            "编辑距离问题的状态转移过程与哪个经典问题非常类似？它们有什么相似之处？",
            "如何进行空间优化，减少动态规划算法的空间复杂度？",
            "编辑距离问题的时间复杂度是多少？空间复杂度是多少？",
            "编辑距离问题有哪些实际应用？它们是如何使用编辑距离算法的？"
          ]
        }
      ]
    },
    {
      "file_name": "quick_sort.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 快速排序\n\n「快速排序 quick sort」是一种基于分治策略的排序算法，运行高效，应用广泛。\n\n快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。具体来说，哨兵划分的流程如下图所示。\n\n1. 选取数组最左端元素作为基准数，初始化两个指针 `i` 和 `j` 分别指向数组的两端。\n2. 设置一个循环，在每轮中使用 `i`（`j`）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。\n3. 循环执行步骤 `2.` ，直到 `i` 和 `j` 相遇时停止，最后将基准数交换至两个子数组的分界线。\n\n=== \"<1>\"\n    ![哨兵划分步骤](quick_sort.assets/pivot_division_step1.png)\n\n=== \"<2>\"\n    ![pivot_division_step2](quick_sort.assets/pivot_division_step2.png)\n\n=== \"<3>\"\n    ![pivot_division_step3](quick_sort.assets/pivot_division_step3.png)\n\n=== \"<4>\"\n    ![pivot_division_step4](quick_sort.assets/pivot_division_step4.png)\n\n=== \"<5>\"\n    ![pivot_division_step5](quick_sort.assets/pivot_division_step5.png)\n\n=== \"<6>\"\n    ![pivot_division_step6](quick_sort.assets/pivot_division_step6.png)\n\n=== \"<7>\"\n    ![pivot_division_step7](quick_sort.assets/pivot_division_step7.png)\n\n=== \"<8>\"\n    ![pivot_division_step8](quick_sort.assets/pivot_division_step8.png)\n\n=== \"<9>\"\n    ![pivot_division_step9](quick_sort.assets/pivot_division_step9.png)\n\n哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组，且满足“左子数组任意元素 $\\leq$ 基准数 $\\leq$ 右子数组任意元素”。因此，我们接下来只需对这两个子数组进行排序。\n\n!!! note \"快速排序的分治策略\"\n\n    哨兵划分的实质是将一个较长数组的排序问题简化为两个较短数组的排序问题。\n\n```src\n[file]{quick_sort}-[class]{quick_sort}-[func]{partition}\n```\n\n## 算法流程\n\n快速排序的整体流程如下图所示。\n\n1. 首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。\n2. 然后，对左子数组和右子数组分别递归执行“哨兵划分”。\n3. 持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序。\n\n![快速排序流程](quick_sort.assets/quick_sort_overview.png)\n\n```src\n[file]{quick_sort}-[class]{quick_sort}-[func]{quick_sort}\n```\n\n## 算法特性\n\n- **时间复杂度 $O(n \\log n)$、自适应排序**：在平均情况下，哨兵划分的递归层数为 $\\log n$ ，每层中的总循环数为 $n$ ，总体使用 $O(n \\log n)$ 时间。在最差情况下，每轮哨兵划分操作都将长度为 $n$ 的数组划分为长度为 $0$ 和 $n - 1$ 的两个子数组，此时递归层数达到 $n$ 层，每层中的循环数为 $n$ ，总体使用 $O(n^2)$ 时间。\n- **空间复杂度 $O(n)$、原地排序**：在输入数组完全倒序的情况下，达到最差递归深度 $n$ ，使用 $O(n)$ 栈帧空间。排序操作是在原数组上进行的，未借助额外数组。\n- **非稳定排序**：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。\n\n## 快排为什么快？\n\n从名称上就能看出，快速排序在效率方面应该具有一定的优势。尽管快速排序的平均时间复杂度与“归并排序”和“堆排序”相同，但通常快速排序的效率更高，主要有以下原因。\n\n- **出现最差情况的概率很低**：虽然快速排序的最差时间复杂度为 $O(n^2)$ ，没有归并排序稳定，但在绝大多数情况下，快速排序能在 $O(n \\log n)$ 的时间复杂度下运行。\n- **缓存使用效率高**：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性。\n- **复杂度的常数系数低**：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的原因类似。\n\n## 基准数优化\n\n**快速排序在某些输入下的时间效率可能降低**。举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为 $n - 1$、右子数组长度为 $0$ 。如此递归下去，每轮哨兵划分后的右子数组长度都为 $0$ ，分治策略失效，快速排序退化为“冒泡排序”。\n\n为了尽量避免这种情况发生，**我们可以优化哨兵划分中的基准数的选取策略**。例如，我们可以随机选取一个元素作为基准数。然而，如果运气不佳，每次都选到不理想的基准数，效率仍然不尽如人意。\n\n需要注意的是，编程语言通常生成的是“伪随机数”。如果我们针对伪随机数序列构建一个特定的测试样例，那么快速排序的效率仍然可能劣化。\n\n为了进一步改进，我们可以在数组中选取三个候选元素（通常为数组的首、尾、中点元素），**并将这三个候选元素的中位数作为基准数**。这样一来，基准数“既不太小也不太大”的概率将大幅提升。当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至 $O(n^2)$ 的概率大大降低。\n\n```src\n[file]{quick_sort}-[class]{quick_sort_median}-[func]{partition}\n```\n\n## 尾递归优化\n\n**在某些输入下，快速排序可能占用空间较多**。以完全倒序的输入数组为例，由于每轮哨兵划分后右子数组长度为 $0$ ，递归树的高度会达到 $n - 1$ ，此时需要占用 $O(n)$ 大小的栈帧空间。\n\n为了防止栈帧空间的累积，我们可以在每轮哨兵排序完成后，比较两个子数组的长度，**仅对较短的子数组进行递归**。由于较短子数组的长度不会超过 $n / 2$ ，因此这种方法能确保递归深度不超过 $\\log n$ ，从而将最差空间复杂度优化至 $O(\\log n)$ 。\n\n```src\n[file]{quick_sort}-[class]{quick_sort_tail_call}-[func]{quick_sort}\n```",
          "questions": [
            "快速排序的核心操作是什么？",
            "哨兵划分的流程是怎样的？",
            "哨兵划分完成后，原数组被划分成了哪三部分？",
            "快速排序的时间复杂度是多少？最差情况下的时间复杂度是多少？",
            "快速排序的空间复杂度是多少？为什么是原地排序？",
            "快速排序是稳定排序还是非稳定排序？",
            "快速排序为什么快？有哪些优势？",
            "如何优化快速排序中的基准数选取策略？",
            "在某些输入下，快速排序可能占用空间较多，如何进行优化？",
            "快速排序的流程中，哪些部分可以使用尾递归优化？"
          ]
        }
      ]
    },
    {
      "file_name": "heap.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 堆\n\n「堆 heap」是一种满足特定条件的完全二叉树，主要可分为下图所示的两种类型。\n\n- 「大顶堆 max heap」：任意节点的值 $\\geq$ 其子节点的值。\n- 「小顶堆 min heap」：任意节点的值 $\\leq$ 其子节点的值。\n\n![小顶堆与大顶堆](heap.assets/min_heap_and_max_heap.png)\n\n堆作为完全二叉树的一个特例，具有以下特性。\n\n- 最底层节点靠左填充，其他层的节点都被填满。\n- 我们将二叉树的根节点称为“堆顶”，将底层最靠右的节点称为“堆底”。\n- 对于大顶堆（小顶堆），堆顶元素（即根节点）的值分别是最大（最小）的。",
          "questions": [
            "堆是什么？有哪些类型？",
            "堆的特性有哪些？",
            "什么是大顶堆？什么是小顶堆？",
            "大顶堆和小顶堆的区别是什么？",
            "堆顶元素在大顶堆和小顶堆中分别是什么？",
            "堆底元素在大顶堆和小顶堆中分别是什么？",
            "堆的节点填充规则是什么？",
            "堆顶元素的值在大顶堆和小顶堆中分别是最大和最小的，这个说法正确吗？",
            "堆的应用有哪些？",
            "堆排序的时间复杂度是多少？"
          ]
        },
        {
          "content": "## 堆的实现\n\n下文实现的是大顶堆。若要将其转换为小顶堆，只需将所有大小逻辑判断取逆（例如，将 $\\geq$ 替换为 $\\leq$ ）。感兴趣的读者可以自行实现。\n\n### 堆的存储与表示\n\n我们在二叉树章节中学习到，完全二叉树非常适合用数组来表示。由于堆正是一种完全二叉树，**我们将采用数组来存储堆**。\n\n当使用数组表示二叉树时，元素代表节点值，索引代表节点在二叉树中的位置。**节点指针通过索引映射公式来实现**。\n\n如下图所示，给定索引 $i$ ，其左子节点索引为 $2i + 1$ ，右子节点索引为 $2i + 2$ ，父节点索引为 $(i - 1) / 2$（向下取整）。当索引越界时，表示空节点或节点不存在。\n\n![堆的表示与存储](heap.assets/representation_of_heap.png)\n\n我们可以将索引映射公式封装成函数，方便后续使用。\n\n```src\n[file]{my_heap}-[class]{max_heap}-[func]{parent}\n```\n\n### 访问堆顶元素\n\n堆顶元素即为二叉树的根节点，也就是列表的首个元素。\n\n```src\n[file]{my_heap}-[class]{max_heap}-[func]{peek}\n```\n\n### 元素入堆\n\n给定元素 `val` ，我们首先将其添加到堆底。添加之后，由于 val 可能大于堆中其他元素，堆的成立条件可能已被破坏。因此，**需要修复从插入节点到根节点的路径上的各个节点**，这个操作被称为「堆化 heapify」。\n\n考虑从入堆节点开始，**从底至顶执行堆化**。如下图所示，我们比较插入节点与其父节点的值，如果插入节点更大，则将它们交换。然后继续执行此操作，从底至顶修复堆中的各个节点，直至越过根节点或遇到无须交换的节点时结束。\n\n=== \"<1>\"\n    ![元素入堆步骤](heap.assets/heap_push_step1.png)\n\n=== \"<2>\"\n    ![heap_push_step2](heap.assets/heap_push_step2.png)\n\n=== \"<3>\"\n    ![heap_push_step3](heap.assets/heap_push_step3.png)\n\n=== \"<4>\"\n    ![heap_push_step4](heap.assets/heap_push_step4.png)\n\n=== \"<5>\"\n    ![heap_push_step5](heap.assets/heap_push_step5.png)\n\n=== \"<6>\"\n    ![heap_push_step6](heap.assets/heap_push_step6.png)\n\n=== \"<7>\"\n    ![heap_push_step7](heap.assets/heap_push_step7.png)\n\n=== \"<8>\"\n    ![heap_push_step8](heap.assets/heap_push_step8.png)\n\n=== \"<9>\"\n    ![heap_push_step9](heap.assets/heap_push_step9.png)\n\n设节点总数为 $n$ ，则树的高度为 $O(\\log n)$ 。由此可知，堆化操作的循环轮数最多为 $O(\\log n)$ ，**元素入堆操作的时间复杂度为 $O(\\log n)$** 。\n\n```src\n[file]{my_heap}-[class]{max_heap}-[func]{sift_up}\n```\n\n### 堆顶元素出堆\n\n堆顶元素是二叉树的根节点，即列表首元素。如果我们直接从列表中删除首元素，那么二叉树中所有节点的索引都会发生变化，这将使得后续使用堆化修复变得困难。为了尽量减少元素索引的变动，我们采用以下操作步骤。\n\n1. 交换堆顶元素与堆底元素（即交换根节点与最右叶节点）。\n2. 交换完成后，将堆底从列表中删除（注意，由于已经交换，实际上删除的是原来的堆顶元素）。\n3. 从根节点开始，**从顶至底执行堆化**。\n\n如下图所示，**“从顶至底堆化”的操作方向与“从底至顶堆化”相反**，我们将根节点的值与其两个子节点的值进行比较，将最大的子节点与根节点交换。然后循环执行此操作，直到越过叶节点或遇到无须交换的节点时结束。\n\n=== \"<1>\"\n    ![堆顶元素出堆步骤](heap.assets/heap_pop_step1.png)\n\n=== \"<2>\"\n    ![heap_pop_step2](heap.assets/heap_pop_step2.png)\n\n=== \"<3>\"\n    ![heap_pop_step3](heap.assets/heap_pop_step3.png)\n\n=== \"<4>\"\n    ![heap_pop_step4](heap.assets/heap_pop_step4.png)\n\n=== \"<5>\"\n    ![heap_pop_step5](heap.assets/heap_pop_step5.png)\n\n=== \"<6>\"\n    ![heap_pop_step6](heap.assets/heap_pop_step6.png)\n\n=== \"<7>\"\n    ![heap_pop_step7](heap.assets/heap_pop_step7.png)\n\n=== \"<8>\"\n    ![heap_pop_step8](heap.assets/heap_pop_step8.png)\n\n=== \"<9>\"\n    ![heap_pop_step9](heap.assets/heap_pop_step9.png)\n\n=== \"<10>\"\n    ![heap_pop_step10](heap.assets/heap_pop_step10.png)\n\n与元素入堆操作相似，堆顶元素出堆操作的时间复杂度也为 $O(\\log n)$ 。\n\n```src\n[file]{my_heap}-[class]{max_heap}-[func]{sift_down}\n```\n\n## 堆常见应用\n\n- **优先队列**：堆通常作为实现优先队列的首选数据结构，其入队和出队操作的时间复杂度均为 $O(\\log n)$ ，而建队操作为 $O(n)$ ，这些操作都非常高效。\n- **堆排序**：给定一组数据，我们可以用它们建立一个堆，然后不断地执行元素出堆操作，从而得到有序数据。然而，我们通常会使用一种更优雅的方式实现堆排序，详见后续的堆排序章节。\n- **获取最大的 $k$ 个元素**：这是一个经典的算法问题，同时也是一种典型应用，例如选择热度前 10 的新闻作为微博热搜，选取销量前 10 的商品等。",
          "questions": [
            "如何用数组来表示堆？为什么堆适合用数组来表示？",
            "堆顶元素是什么？如何访问堆顶元素？",
            "元素入堆的时间复杂度是多少？为什么？",
            "元素入堆的具体操作步骤是什么？如何进行堆化操作？",
            "堆顶元素出堆的时间复杂度是多少？为什么？",
            "堆顶元素出堆的具体操作步骤是什么？如何进行堆化操作？",
            "堆排序是什么？如何实现堆排序？",
            "什么是优先队列？堆通常作为实现优先队列的首选数据结构，为什么？",
            "如何用堆来获取最大的k个元素？",
            "堆的应用有哪些？可以举例说明吗？"
          ]
        }
      ]
    },
    {
      "file_name": "classification_of_data_structure.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 数据结构分类\n\n常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。\n\n## 逻辑结构：线性与非线性\n\n**逻辑结构揭示了数据元素之间的逻辑关系**。在数组和链表中，数据按照顺序依次排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出祖先与后代之间的派生关系；图则由节点和边构成，反映了复杂的网络关系。\n\n如下图所示，逻辑结构可被分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列。\n\n- **线性数据结构**：数组、链表、栈、队列、哈希表。\n- **非线性数据结构**：树、堆、图、哈希表。\n\n![线性与非线性数据结构](classification_of_data_structure.assets/classification_logic_structure.png)\n\n非线性数据结构可以进一步被划分为树形结构和网状结构。\n\n- **线性结构**：数组、链表、队列、栈、哈希表，元素之间是一对一的顺序关系。\n- **树形结构**：树、堆、哈希表，元素之间是一对多的关系。\n- **网状结构**：图，元素之间是多对多的关系。\n\n## 物理结构：连续与分散\n\n在计算机中，内存和硬盘是两种主要的存储硬件设备。硬盘主要用于长期存储数据，容量较大（通常可达到 TB 级别）、速度较慢。内存用于运行程序时暂存数据，速度较快，但容量较小（通常为 GB 级别）。\n\n**在算法运行过程中，相关数据都存储在内存中**。下图展示了一个计算机内存条，其中每个黑色方块都包含一块内存空间。我们可以将内存想象成一个巨大的 Excel 表格，其中每个单元格都可以存储一定大小的数据，在算法运行时，所有数据都被存储在这些单元格中。\n\n**系统通过内存地址来访问目标位置的数据**。如下图所示，计算机根据特定规则为表格中的每个单元格分配编号，确保每个内存空间都有唯一的内存地址。有了这些地址，程序便可以访问内存中的数据。\n\n![内存条、内存空间、内存地址](classification_of_data_structure.assets/computer_memory_location.png)\n\n内存是所有程序的共享资源，当某块内存被某个程序占用时，则无法被其他程序同时使用了。**因此在数据结构与算法的设计中，内存资源是一个重要的考虑因素**。比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果缺少连续大块的内存空间，那么所选用的数据结构必须能够存储在分散的内存空间内。\n\n如下图所示，**物理结构反映了数据在计算机内存中的存储方式**，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，同时在时间效率和空间效率方面呈现出互补的特点。\n\n![连续空间存储与分散空间存储](classification_of_data_structure.assets/classification_phisical_structure.png)\n\n值得说明的是，**所有数据结构都是基于数组、链表或二者的组合实现的**。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。\n\n- **基于数组可实现**：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 $\\geq 3$ 的数组）等。\n- **基于链表可实现**：栈、队列、哈希表、树、堆、图等。\n\n基于数组实现的数据结构也被称为“静态数据结构”，这意味着此类数据结构在初始化后长度不可变。相对应地，基于链表实现的数据结构被称为“动态数据结构”，这类数据结构在初始化后，仍可以在程序运行过程中对其长度进行调整。\n\n!!! tip\n\n    如果你感觉物理结构理解起来有困难，建议先阅读下一章“数组与链表”，然后再回顾本节内容。",
          "questions": [
            "什么是逻辑结构？它有哪些分类？",
            "数组和链表有什么区别？它们属于哪种逻辑结构？",
            "树和图有什么区别？它们属于哪种逻辑结构？",
            "什么是物理结构？它有哪些分类？",
            "数组和链表有什么区别？它们属于哪种物理结构？",
            "基于数组可实现哪些数据结构？基于链表可实现哪些数据结构？",
            "什么是静态数据结构？什么是动态数据结构？",
            "内存是什么？它在算法设计中的作用是什么？",
            "物理结构从底层决定了数据的哪些操作方法？",
            "什么是连续空间存储？什么是分散空间存储？它们有什么区别？"
          ]
        }
      ]
    },
    {
      "file_name": "iteration_and_recursion.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 迭代与递归\n\n在数据结构与算法中，重复执行某个任务是很常见的，其与算法的复杂度密切相关。而要重复执行某个任务，我们通常会选用两种基本的程序结构：迭代和递归。\n\n## 迭代\n\n「迭代 iteration」是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。\n\n### for 循环\n\n`for` 循环是最常见的迭代形式之一，**适合预先知道迭代次数时使用**。\n\n以下函数基于 `for` 循环实现了求和 $1 + 2 + \\dots + n$ ，求和结果使用变量 `res` 记录。需要注意的是，Python 中 `range(a, b)` 对应的区间是“左闭右开”的，对应的遍历范围为 $a, a + 1, \\dots, b-1$ 。\n\n```src\n[file]{iteration}-[class]{}-[func]{for_loop}\n```\n\n下图展示了该求和函数的流程框图。\n\n![求和函数的流程框图](iteration_and_recursion.assets/iteration.png)\n\n此求和函数的操作数量与输入数据大小 $n$ 成正比，或者说成“线性关系”。实际上，**时间复杂度描述的就是这个“线性关系”**。相关内容将会在下一节中详细介绍。\n\n### while 循环\n\n与 `for` 循环类似，`while` 循环也是一种实现迭代的方法。在 `while` 循环中，程序每轮都会先检查条件，如果条件为真则继续执行，否则就结束循环。\n\n下面，我们用 `while` 循环来实现求和 $1 + 2 + \\dots + n$ 。\n\n```src\n[file]{iteration}-[class]{}-[func]{while_loop}\n```\n\n在 `while` 循环中，由于初始化和更新条件变量的步骤是独立在循环结构之外的，**因此它比 `for` 循环的自由度更高**。\n\n例如在以下代码中，条件变量 $i$ 每轮进行了两次更新，这种情况就不太方便用 `for` 循环实现。\n\n```src\n[file]{iteration}-[class]{}-[func]{while_loop_ii}\n```\n\n总的来说，**`for` 循环的代码更加紧凑，`while` 循环更加灵活**，两者都可以实现迭代结构。选择使用哪一个应该根据特定问题的需求来决定。\n\n### 嵌套循环\n\n我们可以在一个循环结构内嵌套另一个循环结构，以 `for` 循环为例：\n\n```src\n[file]{iteration}-[class]{}-[func]{nested_for_loop}\n```\n\n下图给出了该嵌套循环的流程框图。\n\n![嵌套循环的流程框图](iteration_and_recursion.assets/nested_iteration.png)\n\n在这种情况下，函数的操作数量与 $n^2$ 成正比，或者说算法运行时间和输入数据大小 $n$ 成“平方关系”。\n\n我们可以继续添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”、“四次方关系”、以此类推。\n\n## 递归\n\n 「递归 recursion」是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。\n\n1. **递**：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。\n2. **归**：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。\n\n而从实现的角度看，递归代码主要包含三个要素。\n\n1. **终止条件**：用于决定什么时候由“递”转“归”。\n2. **递归调用**：对应“递”，函数调用自身，通常输入更小或更简化的参数。\n3. **返回结果**：对应“归”，将当前递归层级的结果返回至上一层。\n\n观察以下代码，我们只需调用函数 `recur(n)`  ，就可以完成 $1 + 2 + \\dots + n$ 的计算：\n\n```src\n[file]{recursion}-[class]{}-[func]{recur}\n```\n\n下图展示了该函数的递归过程。\n\n![求和函数的递归过程](iteration_and_recursion.assets/recursion_sum.png)\n\n虽然从计算角度看，迭代与递归可以得到相同的结果，**但它们代表了两种完全不同的思考和解决问题的范式**。\n\n- **迭代**：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。\n- **递归**：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。\n\n以上述的求和函数为例，设问题 $f(n) = 1 + 2 + \\dots + n$ 。\n\n- **迭代**：在循环中模拟求和过程，从 $1$ 遍历到 $n$ ，每轮执行求和操作，即可求得 $f(n)$ 。\n- **递归**：将问题分解为子问题 $f(n) = n + f(n-1)$ ，不断（递归地）分解下去，直至基本情况 $f(1) = 1$ 时终止。\n\n### 调用栈\n\n递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。\n\n- 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，**递归通常比迭代更加耗费内存空间**。\n- 递归调用函数会产生额外的开销。**因此递归通常比循环的时间效率更低**。\n\n如下图所示，在触发终止条件前，同时存在 $n$ 个未返回的递归函数，**递归深度为 $n$** 。\n\n![递归调用深度](iteration_and_recursion.assets/recursion_sum_depth.png)\n\n在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出报错。\n\n### 尾递归\n\n有趣的是，**如果函数在返回前的最后一步才进行递归调用**，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为「尾递归 tail recursion」。\n\n- **普通递归**：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。\n- **尾递归**：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无需继续执行其他操作，因此系统无需保存上一层函数的上下文。\n\n以计算 $1 + 2 + \\dots + n$ 为例，我们可以将结果变量 `res` 设为函数参数，从而实现尾递归。\n\n```src\n[file]{recursion}-[class]{}-[func]{tail_recur}\n```\n\n尾递归的执行过程如下图所示。对比普通递归和尾递归，求和操作的执行点是不同的。\n\n- **普通递归**：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。\n- **尾递归**：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。\n\n![尾递归过程](iteration_and_recursion.assets/tail_recursion_sum.png)\n\n!!! tip\n\n    请注意，许多编译器或解释器并不支持尾递归优化。例如，Python 默认不支持尾递归优化，因此即使函数是尾递归形式，但仍然可能会遇到栈溢出问题。",
          "questions": [
            "迭代和递归分别是什么？它们的区别是什么？",
            "什么是迭代循环？它适用于哪些情况？",
            "什么是嵌套循环？它的时间复杂度是多少？",
            "什么是递归？它的实现要素有哪些？",
            "递归和迭代的时间和空间复杂度有何区别？",
            "什么是调用栈？它与递归有何关系？",
            "什么是尾递归？它与普通递归有何区别？",
            "为什么递归通常比循环更耗费内存空间？",
            "为什么递归调用函数会产生额外的开销？",
            "什么是栈溢出报错？如何避免它的发生？"
          ]
        },
        {
          "content": "### 递归树\n\n当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。以“斐波那契数列”为例。\n\n!!! question\n\n    给定一个斐波那契数列 $0, 1, 1, 2, 3, 5, 8, 13, \\dots$ ，求该数列的第 $n$ 个数字。\n\n设斐波那契数列的第 $n$ 个数字为 $f(n)$ ，易得两个结论。\n\n- 数列的前两个数字为 $f(1) = 0$ 和 $f(2) = 1$ 。\n- 数列中的每个数字是前两个数字的和，即 $f(n) = f(n - 1) + f(n - 2)$ 。\n\n按照递推关系进行递归调用，将前两个数字作为终止条件，便可写出递归代码。调用 `fib(n)` 即可得到斐波那契数列的第 $n$ 个数字。\n\n```src\n[file]{recursion}-[class]{}-[func]{fib}\n```\n\n观察以上代码，我们在函数内递归调用了两个函数，**这意味着从一个调用产生了两个调用分支**。如下图所示，这样不断递归调用下去，最终将产生一个层数为 $n$ 的「递归树 recursion tree」。\n\n![斐波那契数列的递归树](iteration_and_recursion.assets/recursion_tree.png)\n\n本质上看，递归体现“将问题分解为更小子问题”的思维范式，这种分治策略是至关重要的。\n\n- 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略都直接或间接地应用这种思维方式。\n- 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。\n\n## 两者对比\n\n总结以上内容，如下表所示，迭代和递归在实现、性能和适用性上有所不同。\n\n<p align=\"center\"> 表 <id> &nbsp; 迭代与递归特点对比 </p>\n\n|          | 迭代                                   | 递归                                                         |\n| -------- | -------------------------------------- | ------------------------------------------------------------ |\n| 实现方式 | 循环结构                               | 函数调用自身                                                 |\n| 时间效率 | 效率通常较高，无函数调用开销           | 每次函数调用都会产生开销                                     |\n| 内存使用 | 通常使用固定大小的内存空间             | 累积函数调用可能使用大量的栈帧空间                           |\n| 适用问题 | 适用于简单循环任务，代码直观、可读性好 | 适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰 |\n\n!!! tip\n\n    如果感觉以下内容理解困难，可以在读完“栈”章节后再来复习。\n\n那么，迭代和递归具有什么内在联系呢？以上述的递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，**这种工作机制与栈的“先入后出”原则是异曲同工的**。\n\n事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。\n\n1. **递**：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。\n2. **归**：当函数完成执行并返回时，对应的栈帧会从“调用栈”上被移除，恢复之前函数的执行环境。\n\n因此，**我们可以使用一个显式的栈来模拟调用栈的行为**，从而将递归转化为迭代形式：\n\n```src\n[file]{recursion}-[class]{}-[func]{for_loop_recur}\n```\n\n观察以上代码，当递归被转换为迭代后，代码变得更加复杂了。尽管迭代和递归在很多情况下可以互相转换，但也不一定值得这样做，有以下两点原因。\n\n- 转化后的代码可能更加难以理解，可读性更差。\n- 对于某些复杂问题，模拟系统调用栈的行为可能非常困难。\n\n总之，**选择迭代还是递归取决于特定问题的性质**。在编程实践中，权衡两者的优劣并根据情境选择合适的方法是至关重要的。",
          "questions": [
            "递归和迭代在实现方式、时间效率、内存使用和适用问题上有哪些不同？",
            "为什么递归天然适合处理链表、树和图的相关问题？",
            "什么是递归树？如何通过递归树来理解递归的工作机制？",
            "递归和栈之间有什么密切关系？如何使用一个显式的栈来模拟调用栈的行为？",
            "为什么在某些情况下，将递归转化为迭代并不值得？",
            "什么是斐波那契数列？如何通过递归来求解斐波那契数列的第n个数字？",
            "递归和分治策略有什么关系？分治策略在哪些算法问题中得到了应用？",
            "递归和动态规划策略有什么关系？动态规划策略在哪些算法问题中得到了应用？",
            "递归和回溯策略有什么关系？回溯策略在哪些算法问题中得到了应用？",
            "递归和排序算法有什么关系？常见的排序算法中有哪些使用了递归的思想？"
          ]
        }
      ]
    },
    {
      "file_name": "permutations_problem.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 全排列问题\n\n全排列问题是回溯算法的一个典型应用。它的定义是在给定一个集合（如一个数组或字符串）的情况下，找出这个集合中元素的所有可能的排列。\n\n下表列举了几个示例数据，包括输入数组和对应的所有排列。\n\n<p align=\"center\"> 表 <id> &nbsp; 全排列示例 </p>\n\n| 输入数组    | 所有排列                                                           |\n| :---------- | :----------------------------------------------------------------- |\n| $[1]$       | $[1]$                                                              |\n| $[1, 2]$    | $[1, 2], [2, 1]$                                                   |\n| $[1, 2, 3]$ | $[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]$ |\n\n## 无相等元素的情况\n\n!!! question\n\n    输入一个整数数组，数组中不包含重复元素，返回所有可能的排列。\n\n从回溯算法的角度看，**我们可以把生成排列的过程想象成一系列选择的结果**。假设输入数组为 $[1, 2, 3]$ ，如果我们先选择 $1$、再选择 $3$、最后选择 $2$ ，则获得排列 $[1, 3, 2]$ 。回退表示撤销一个选择，之后继续尝试其他选择。\n\n从回溯代码的角度看，候选集合 `choices` 是输入数组中的所有元素，状态 `state` 是直至目前已被选择的元素。请注意，每个元素只允许被选择一次，**因此 `state` 中的所有元素都应该是唯一的**。\n\n如下图所示，我们可以将搜索过程展开成一个递归树，树中的每个节点代表当前状态 `state` 。从根节点开始，经过三轮选择后到达叶节点，每个叶节点都对应一个排列。\n\n![全排列的递归树](permutations_problem.assets/permutations_i.png)\n\n### 重复选择剪枝\n\n为了实现每个元素只被选择一次，我们考虑引入一个布尔型数组 `selected` ，其中 `selected[i]` 表示 `choices[i]` 是否已被选择，并基于它实现以下剪枝操作。\n\n- 在做出选择 `choice[i]` 后，我们就将 `selected[i]` 赋值为 $\\text{True}$ ，代表它已被选择。\n- 遍历选择列表 `choices` 时，跳过所有已被选择过的节点，即剪枝。\n\n如下图所示，假设我们第一轮选择 1 ，第二轮选择 3 ，第三轮选择 2 ，则需要在第二轮剪掉元素 1 的分支，在第三轮剪掉元素 1 和元素 3 的分支。\n\n![全排列剪枝示例](permutations_problem.assets/permutations_i_pruning.png)\n\n观察上图发现，该剪枝操作将搜索空间大小从 $O(n^n)$ 降低至 $O(n!)$ 。\n\n### 代码实现\n\n想清楚以上信息之后，我们就可以在框架代码中做“完形填空”了。为了缩短代码行数，我们不单独实现框架代码中的各个函数，而是将他们展开在 `backtrack()` 函数中。\n\n```src\n[file]{permutations_i}-[class]{}-[func]{permutations_i}\n```\n\n## 考虑相等元素的情况\n\n!!! question\n\n    输入一个整数数组，**数组中可能包含重复元素**，返回所有不重复的排列。\n\n假设输入数组为 $[1, 1, 2]$ 。为了方便区分两个重复元素 $1$ ，我们将第二个 $1$ 记为 $\\hat{1}$ 。\n\n如下图所示，上述方法生成的排列有一半都是重复的。\n\n![重复排列](permutations_problem.assets/permutations_ii.png)\n\n那么如何去除重复的排列呢？最直接地，考虑借助一个哈希表，直接对排列结果进行去重。然而这样做不够优雅，**因为生成重复排列的搜索分支是没有必要的，应当被提前识别并剪枝**，这样可以进一步提升算法效率。\n\n### 相等元素剪枝\n\n观察下图，在第一轮中，选择 $1$ 或选择 $\\hat{1}$ 是等价的，在这两个选择之下生成的所有排列都是重复的。因此应该把 $\\hat{1}$ 剪枝掉。\n\n同理，在第一轮选择 $2$ 之后，第二轮选择中的 $1$ 和 $\\hat{1}$ 也会产生重复分支，因此也应将第二轮的 $\\hat{1}$ 剪枝。\n\n本质上看，**我们的目标是在某一轮选择中，保证多个相等的元素仅被选择一次**。\n\n![重复排列剪枝](permutations_problem.assets/permutations_ii_pruning.png)\n\n### 代码实现\n\n在上一题的代码的基础上，我们考虑在每一轮选择中开启一个哈希表 `duplicated` ，用于记录该轮中已经尝试过的元素，并将重复元素剪枝。\n\n```src\n[file]{permutations_ii}-[class]{}-[func]{permutations_ii}\n```\n\n假设元素两两之间互不相同，则 $n$ 个元素共有 $n!$  种排列（阶乘）；在记录结果时，需要复制长度为 $n$ 的列表，使用 $O(n)$ 时间。**因此时间复杂度为 $O(n!n)$** 。\n\n最大递归深度为 $n$ ，使用 $O(n)$ 栈帧空间。`selected` 使用 $O(n)$ 空间。同一时刻最多共有 $n$ 个 `duplicated` ，使用 $O(n^2)$ 空间。**因此空间复杂度为 $O(n^2)$** 。\n\n### 两种剪枝对比\n\n请注意，虽然 `selected` 和 `duplicated` 都用作剪枝，但两者的目标是不同的。\n\n- **重复选择剪枝**：整个搜索过程中只有一个 `selected` 。它记录的是当前状态中包含哪些元素，作用是避免某个元素在 `state` 中重复出现。\n- **相等元素剪枝**：每轮选择（即每个开启的 `backtrack` 函数）都包含一个 `duplicated` 。它记录的是在遍历中哪些元素已被选择过，作用是保证相等元素只被选择一次。\n\n下图展示了两个剪枝条件的生效范围。注意，树中的每个节点代表一个选择，从根节点到叶节点的路径上的各个节点构成一个排列。\n\n![两种剪枝条件的作用范围](permutations_problem.assets/permutations_ii_pruning_summary.png)",
          "questions": [
            "如何定义全排列问题？请举例说明。",
            "全排列问题可以使用什么算法解决？它的基本思想是什么？",
            "在回溯算法中，如何将生成排列的过程想象成一系列选择的结果？请举例说明。",
            "在回溯算法中，候选集合 `choices` 和状态 `state` 分别代表什么？它们之间的关系是什么？",
            "在全排列问题中，每个元素只允许被选择一次，如何保证 `state` 中的所有元素都是唯一的？",
            "在全排列问题中，如何使用剪枝操作避免重复搜索已经搜索过的分支？请举例说明。",
            "在全排列问题中，如果输入数组中包含重复元素，如何去除重复的排列？请举例说明。",
            "在相等元素剪枝中，我们的目标是什么？如何实现这个目标？",
            "在重复选择剪枝和相等元素剪枝中，`selected` 和 `duplicated` 的作用分别是什么？它们的目标有何不同？",
            "在全排列问题中，时间复杂度和空间复杂度分别是多少？请说明原因。"
          ]
        }
      ]
    },
    {
      "file_name": "sorting_algorithm.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 排序算法\n\n「排序算法 sorting algorithm」用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更有效地查找、分析和处理。\n\n如下图所示，排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则。\n\n![数据类型和判断规则示例](sorting_algorithm.assets/sorting_examples.png)\n\n## 评价维度\n\n**运行效率**：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（即时间复杂度中的常数项降低）。对于大数据量情况，运行效率显得尤为重要。\n\n**就地性**：顾名思义，「原地排序」通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。\n\n**稳定性**：「稳定排序」在完成排序后，相等元素在数组中的相对顺序不发生改变。\n\n稳定排序是多级排序场景的必要条件。假设我们有一个存储学生信息的表格，第 1 列和第 2 列分别是姓名和年龄。在这种情况下，「非稳定排序」可能导致输入数据的有序性丧失。\n\n```shell\n# 输入数据是按照姓名排序好的\n# (name, age)\n  ('A', 19)\n  ('B', 18)\n  ('C', 21)\n  ('D', 19)\n  ('E', 23)\n\n# 假设使用非稳定排序算法按年龄排序列表，\n# 结果中 ('D', 19) 和 ('A', 19) 的相对位置改变，\n# 输入数据按姓名排序的性质丢失\n  ('B', 18)\n  ('D', 19)\n  ('A', 19)\n  ('C', 21)\n  ('E', 23)\n```\n\n**自适应性**：「自适应排序」的时间复杂度会受输入数据的影响，即最佳、最差、平均时间复杂度并不完全相等。\n\n自适应性需要根据具体情况来评估。如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性；而如果最佳时间复杂度优于平均时间复杂度，则被视为正面属性。\n\n**是否基于比较**：「基于比较的排序」依赖于比较运算符（$<$、$=$、$>$）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 $O(n \\log n)$ 。而「非比较排序」不使用比较运算符，时间复杂度可达 $O(n)$ ，但其通用性相对较差。\n\n## 理想排序算法\n\n**运行快、原地、稳定、正向自适应、通用性好**。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定。\n\n接下来，我们将共同学习各种排序算法，并基于上述评价维度对各个排序算法的优缺点进行分析。",
          "questions": [
            "排序算法有哪些应用场景？",
            "排序算法的判断规则可以根据什么设定？",
            "什么是排序算法的时间复杂度？为什么运行效率显得尤为重要？",
            "什么是原地排序？它有什么优点？",
            "什么是稳定排序？为什么稳定排序是多级排序场景的必要条件？",
            "什么是自适应排序？如何评估自适应性？",
            "基于比较的排序和非比较排序有什么区别？它们的时间复杂度分别是多少？",
            "理想排序算法应该具备哪些特性？",
            "如何根据具体的数据特点和问题需求来选择排序算法？",
            "排序算法中有哪些经典的算法？它们的优缺点是什么？"
          ]
        }
      ]
    },
    {
      "file_name": "intro_to_dynamic_programming.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 初探动态规划\n\n「动态规划 dynamic programming」是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。\n\n在本节中，我们从一个经典例题入手，先给出它的暴力回溯解法，观察其中包含的重叠子问题，再逐步导出更高效的动态规划解法。\n\n!!! question \"爬楼梯\"\n\n    给定一个共有 $n$ 阶的楼梯，你每步可以上 $1$ 阶或者 $2$ 阶，请问有多少种方案可以爬到楼顶。\n\n如下图所示，对于一个 $3$ 阶楼梯，共有 $3$ 种方案可以爬到楼顶。\n\n![爬到第 3 阶的方案数量](intro_to_dynamic_programming.assets/climbing_stairs_example.png)\n\n本题的目标是求解方案数量，**我们可以考虑通过回溯来穷举所有可能性**。具体来说，将爬楼梯想象为一个多轮选择的过程：从地面出发，每轮选择上 $1$ 阶或 $2$ 阶，每当到达楼梯顶部时就将方案数量加 $1$ ，当越过楼梯顶部时就将其剪枝。\n\n```src\n[file]{climbing_stairs_backtrack}-[class]{}-[func]{climbing_stairs_backtrack}\n```\n\n## 方法一：暴力搜索\n\n回溯算法通常并不显式地对问题进行拆解，而是将问题看作一系列决策步骤，通过试探和剪枝，搜索所有可能的解。\n\n我们可以尝试从问题分解的角度分析这道题。设爬到第 $i$ 阶共有 $dp[i]$ 种方案，那么 $dp[i]$ 就是原问题，其子问题包括:\n\n$$\ndp[i-1], dp[i-2], \\dots, dp[2], dp[1]\n$$\n\n由于每轮只能上 $1$ 阶或 $2$ 阶，因此当我们站在第 $i$ 阶楼梯上时，上一轮只可能站在第 $i - 1$ 阶或第 $i - 2$ 阶上。换句话说，我们只能从第 $i -1$ 阶或第 $i - 2$ 阶前往第 $i$ 阶。\n\n由此便可得出一个重要推论：**爬到第 $i - 1$ 阶的方案数加上爬到第 $i - 2$ 阶的方案数就等于爬到第 $i$ 阶的方案数**。公式如下：\n\n$$\ndp[i] = dp[i-1] + dp[i-2]\n$$\n\n这意味着在爬楼梯问题中，各个子问题之间存在递推关系，**原问题的解可以由子问题的解构建得来**。下图展示了该递推关系。\n\n![方案数量递推关系](intro_to_dynamic_programming.assets/climbing_stairs_state_transfer.png)\n\n我们可以根据递推公式得到暴力搜索解法。以 $dp[n]$ 为起始点，**递归地将一个较大问题拆解为两个较小问题的和**，直至到达最小子问题 $dp[1]$ 和 $dp[2]$ 时返回。其中，最小子问题的解是已知的，即 $dp[1] = 1$、$dp[2] = 2$ ，表示爬到第 $1$、$2$ 阶分别有 $1$、$2$ 种方案。\n\n观察以下代码，它和标准回溯代码都属于深度优先搜索，但更加简洁。\n\n```src\n[file]{climbing_stairs_dfs}-[class]{}-[func]{climbing_stairs_dfs}\n```\n\n下图展示了暴力搜索形成的递归树。对于问题 $dp[n]$ ，其递归树的深度为 $n$ ，时间复杂度为 $O(2^n)$ 。指数阶属于爆炸式增长，如果我们输入一个比较大的 $n$ ，则会陷入漫长的等待之中。\n\n![爬楼梯对应递归树](intro_to_dynamic_programming.assets/climbing_stairs_dfs_tree.png)\n\n观察上图，**指数阶的时间复杂度是由于“重叠子问题”导致的**。例如 $dp[9]$ 被分解为 $dp[8]$ 和 $dp[7]$ ，$dp[8]$ 被分解为 $dp[7]$ 和 $dp[6]$ ，两者都包含子问题 $dp[7]$ 。\n\n以此类推，子问题中包含更小的重叠子问题，子子孙孙无穷尽也。绝大部分计算资源都浪费在这些重叠的问题上。\n\n## 方法二：记忆化搜索\n\n为了提升算法效率，**我们希望所有的重叠子问题都只被计算一次**。为此，我们声明一个数组 `mem` 来记录每个子问题的解，并在搜索过程中将重叠子问题剪枝。\n\n1. 当首次计算 $dp[i]$ 时，我们将其记录至 `mem[i]` ，以便之后使用。\n2. 当再次需要计算 $dp[i]$ 时，我们便可直接从 `mem[i]` 中获取结果，从而避免重复计算该子问题。\n\n```src\n[file]{climbing_stairs_dfs_mem}-[class]{}-[func]{climbing_stairs_dfs_mem}\n```\n\n观察下图，**经过记忆化处理后，所有重叠子问题都只需被计算一次，时间复杂度被优化至 $O(n)$** ，这是一个巨大的飞跃。\n\n![记忆化搜索对应递归树](intro_to_dynamic_programming.assets/climbing_stairs_dfs_memo_tree.png)\n\n## 方法三：动态规划\n\n**记忆化搜索是一种“从顶至底”的方法**：我们从原问题（根节点）开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题（叶节点）。之后，通过回溯将子问题的解逐层收集，构建出原问题的解。\n\n与之相反，**动态规划是一种“从底至顶”的方法**：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。\n\n由于动态规划不包含回溯过程，因此只需使用循环迭代实现，无须使用递归。在以下代码中，我们初始化一个数组 `dp` 来存储子问题的解，它起到了记忆化搜索中数组 `mem` 相同的记录作用。\n\n```src\n[file]{climbing_stairs_dp}-[class]{}-[func]{climbing_stairs_dp}\n```\n\n下图模拟了以上代码的执行过程。\n\n![爬楼梯的动态规划过程](intro_to_dynamic_programming.assets/climbing_stairs_dp.png)\n\n与回溯算法一样，动态规划也使用“状态”概念来表示问题求解的某个特定阶段，每个状态都对应一个子问题以及相应的局部最优解。例如，爬楼梯问题的状态定义为当前所在楼梯阶数 $i$ 。\n\n根据以上内容，我们可以总结出动态规划的常用术语。\n\n- 将数组 `dp` 称为「$dp$ 表」，$dp[i]$ 表示状态 $i$ 对应子问题的解。\n- 将最小子问题对应的状态（即第 $1$ 和 $2$ 阶楼梯）称为「初始状态」。\n- 将递推公式 $dp[i] = dp[i-1] + dp[i-2]$ 称为「状态转移方程」。\n\n## 空间优化\n\n细心的你可能发现，**由于 $dp[i]$ 只与 $dp[i-1]$ 和 $dp[i-2]$ 有关，因此我们无须使用一个数组 `dp` 来存储所有子问题的解**，而只需两个变量滚动前进即可。\n\n```src\n[file]{climbing_stairs_dp}-[class]{}-[func]{climbing_stairs_dp_comp}\n```\n\n观察以上代码，由于省去了数组 `dp` 占用的空间，因此空间复杂度从 $O(n)$ 降低至 $O(1)$ 。\n\n在动态规划问题中，当前状态往往仅与前面有限个状态有关，这时我们可以只保留必要的状态，通过“降维”来节省内存空间。**这种空间优化技巧被称为“滚动变量”或“滚动数组”**。",
          "questions": [
            "爬楼梯问题中，如何使用回溯算法求解？",
            "爬楼梯问题中，暴力搜索的时间复杂度是多少？为什么？",
            "爬楼梯问题中，如何使用记忆化搜索优化算法效率？",
            "爬楼梯问题中，动态规划是一种什么样的算法范式？",
            "爬楼梯问题中，动态规划的常用术语有哪些？",
            "爬楼梯问题中，如何使用滚动变量优化空间复杂度？",
            "动态规划和回溯算法有什么区别？",
            "什么是重叠子问题？如何避免重复计算？",
            "什么是状态转移方程？在爬楼梯问题中，状态转移方程是什么？",
            "为什么动态规划是一种“从底至顶”的方法？"
          ]
        }
      ]
    },
    {
      "file_name": "hash_collision.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 哈希冲突\n\n上节提到，**通常情况下哈希函数的输入空间远大于输出空间**，因此理论上哈希冲突是不可避免的。比如，输入空间为全体整数，输出空间为数组容量大小，则必然有多个整数映射至同一桶索引。\n\n哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为解决该问题，我们可以每当遇到哈希冲突时就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。为了提升效率，我们可以采用以下策略。\n\n1. 改良哈希表数据结构，**使得哈希表可以在存在哈希冲突时正常工作**。\n2. 仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。\n\n哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。\n\n## 链式地址\n\n在原始哈希表中，每个桶仅能存储一个键值对。「链式地址 separate chaining」将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。下图展示了一个链式地址哈希表的例子。\n\n![链式地址哈希表](hash_collision.assets/hash_table_chaining.png)\n\n基于链式地址实现的哈希表的操作方法发生了以下变化。\n\n- **查询元素**：输入 `key` ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比 `key` 以查找目标键值对。\n- **添加元素**：先通过哈希函数访问链表头节点，然后将节点（即键值对）添加到链表中。\n- **删除元素**：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点，并将其删除。\n\n链式地址存在以下局限性。\n\n- **占用空间增大**，链表包含节点指针，它相比数组更加耗费内存空间。\n- **查询效率降低**，因为需要线性遍历链表来查找对应元素。\n\n以下代码给出了链式地址哈希表的简单实现，需要注意两点。\n\n- 使用列表（动态数组）代替链表，从而简化代码。在这种设定下，哈希表（数组）包含多个桶，每个桶都是一个列表。\n- 以下实现包含哈希表扩容方法。当负载因子超过 $\\frac{2}{3}$ 时，我们将哈希表扩容至 $2$ 倍。\n\n```src\n[file]{hash_map_chaining}-[class]{hash_map_chaining}-[func]{}\n```\n\n值得注意的是，当链表很长时，查询效率 $O(n)$ 很差。**此时可以将链表转换为“AVL 树”或“红黑树”**，从而将查询操作的时间复杂度优化至 $O(\\log n)$ 。\n\n## 开放寻址\n\n「开放寻址 open addressing」不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测、多次哈希等。\n\n下面将主要以线性探测为例，介绍开放寻址哈希表的工作机制与代码实现。\n\n### 线性探测\n\n线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。\n\n- **插入元素**：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为 $1$ ），直至找到空桶，将元素插入其中。\n- **查找元素**：若发现哈希冲突，则使用相同步长向后线性遍历，直到找到对应元素，返回 `value` 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 $\\text{None}$ 。\n\n下图展示了开放寻址（线性探测）哈希表的键值对分布。根据此哈希函数，最后两位相同的 `key` 都会被映射到相同的桶。而通过线性探测，它们被依次存储在该桶以及之下的桶中。\n\n![开放寻址和线性探测](hash_collision.assets/hash_table_linear_probing.png)\n\n然而，**线性探测容易产生“聚集现象”**。具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。\n\n值得注意的是，**我们不能在开放寻址哈希表中直接删除元素**。这是因为删除元素会在数组内产生一个空桶 $\\text{None}$ ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在。\n\n![在开放寻址中删除元素导致的查询问题](hash_collision.assets/hash_table_open_addressing_deletion.png)\n\n为了解决该问题，我们可以采用「懒删除 lazy deletion」机制：它不直接从哈希表中移除元素，**而是利用一个常量 `TOMBSTONE` 来标记这个桶**。在该机制下，$\\text{None}$ 和 `TOMBSTONE` 都代表空桶，都可以放置键值对。但不同的是，线性探测到 `TOMBSTONE` 时应该继续遍历，因为其之下可能还存在键值对。\n\n然而，**懒删除可能会加速哈希表的性能退化**。这是因为每次删除操作都会产生一个删除标记，随着 `TOMBSTONE` 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 `TOMBSTONE` 才能找到目标元素。\n\n为此，考虑在线性探测中记录遇到的首个 `TOMBSTONE` 的索引，并将搜索到的目标元素与该 `TOMBSTONE` 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率。\n\n以下代码实现了一个包含懒删除的开放寻址（线性探测）哈希表。为了更加充分地使用哈希表的空间，我们将哈希表看作是一个“环形数组”，当越过数组尾部时，回到头部继续遍历。\n\n```src\n[file]{hash_map_open_addressing}-[class]{hash_map_open_addressing}-[func]{}\n```\n\n### 平方探测\n\n平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即 $1, 4, 9, \\dots$ 步。\n\n平方探测主要具有以下优势。\n\n- 平方探测通过跳过平方的距离，试图缓解线性探测的聚集效应。\n- 平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀。\n\n然而，平方探测也并不是完美的。\n\n- 仍然存在聚集现象，即某些位置比其他位置更容易被占用。\n- 由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它。\n\n### 多次哈希\n\n多次哈希使用多个哈希函数 $f_1(x)$、$f_2(x)$、$f_3(x)$、$\\dots$ 进行探测。\n\n- **插入元素**：若哈希函数 $f_1(x)$ 出现冲突，则尝试 $f_2(x)$ ，以此类推，直到找到空桶后插入元素。\n- **查找元素**：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；或当遇到空桶或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回 $\\text{None}$ 。\n\n与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会增加额外的计算量。\n\n!!! tip\n\n    请注意，开放寻址（线性探测、平方探测和多次哈希）哈希表都存在“不能直接删除元素”的问题。",
          "questions": [
            "什么是哈希冲突？为什么哈希冲突是不可避免的？",
            "哈希冲突会对哈希表的可用性产生什么影响？",
            "如何解决哈希冲突？有哪些策略可以采用？",
            "什么是链式地址？如何实现链式地址哈希表？",
            "链式地址哈希表有哪些局限性？如何解决这些局限性？",
            "什么是开放寻址？如何实现开放寻址哈希表？",
            "开放寻址哈希表中为什么不能直接删除元素？如何解决这个问题？",
            "什么是线性探测？如何避免线性探测产生的聚集现象？",
            "什么是平方探测？与线性探测相比，平方探测有哪些优势和劣势？",
            "什么是多次哈希？如何实现多次哈希探测？"
          ]
        },
        {
          "content": "## 编程语言的选择\n\n各个编程语言采取了不同的哈希表实现策略，以下举几个例子。\n\n- Java 采用链式地址。自 JDK 1.8 以来，当 HashMap 内数组长度达到 64 且链表长度达到 8 时，链表会被转换为红黑树以提升查找性能。\n- Python 采用开放寻址。字典 dict 使用伪随机数进行探测。\n- Golang 采用链式地址。Go 规定每个桶最多存储 8 个键值对，超出容量则连接一个溢出桶。当溢出桶过多时，会执行一次特殊的等量扩容操作，以确保性能。",
          "questions": [
            "Java中的HashMap在什么情况下会将链表转换为红黑树？",
            "Python中的字典dict采用什么样的哈希表实现策略？",
            "Golang中的哈希表采用什么样的地址方式？",
            "在Java中，当HashMap内数组长度达到多少且链表长度达到多少时，链表会被转换为红黑树？",
            "在Golang中，每个桶最多存储多少个键值对？",
            "Golang中的哈希表在溢出时会连接一个什么样的桶？",
            "Python中的字典dict使用什么方式进行探测？",
            "在Golang中，当溢出桶过多时会执行什么样的操作？",
            "Java中的HashMap采用什么样的地址方式？",
            "在Java中，当HashMap内数组长度达到多少时会执行扩容操作？"
          ]
        }
      ]
    },
    {
      "file_name": "backtracking_algorithm.md",
      "question_count": 30,
      "documents": [
        {
          "content": "# 回溯算法\n\n「回溯算法 backtracking algorithm」是一种通过穷举来解决问题的方法，它的核心思想是从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止。\n\n回溯算法通常采用“深度优先搜索”来遍历解空间。在二叉树章节中，我们提到前序、中序和后序遍历都属于深度优先搜索。接下来，我们利用前序遍历构造一个回溯问题，逐步了解回溯算法的工作原理。\n\n!!! question \"例题一\"\n\n    给定一个二叉树，搜索并记录所有值为 $7$ 的节点，请返回节点列表。\n\n对于此题，我们前序遍历这颗树，并判断当前节点的值是否为 $7$ ，若是则将该节点的值加入到结果列表 `res` 之中。相关过程实现如下图和以下代码所示。\n\n```src\n[file]{preorder_traversal_i_compact}-[class]{}-[func]{pre_order}\n```\n\n![在前序遍历中搜索节点](backtracking_algorithm.assets/preorder_find_nodes.png)\n\n## 尝试与回退\n\n**之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略**。当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其他可能的选择。\n\n对于例题一，访问每个节点都代表一次“尝试”，而越过叶结点或返回父节点的 `return` 则表示“回退”。\n\n值得说明的是，**回退并不仅仅包括函数返回**。为解释这一点，我们对例题一稍作拓展。\n\n!!! question \"例题二\"\n\n    在二叉树中搜索所有值为 $7$ 的节点，**请返回根节点到这些节点的路径**。\n\n在例题一代码的基础上，我们需要借助一个列表 `path` 记录访问过的节点路径。当访问到值为 $7$ 的节点时，则复制 `path` 并添加进结果列表 `res` 。遍历完成后，`res` 中保存的就是所有的解。\n\n```src\n[file]{preorder_traversal_ii_compact}-[class]{}-[func]{pre_order}\n```\n\n在每次“尝试”中，我们通过将当前节点添加进 `path` 来记录路径；而在“回退”前，我们需要将该节点从 `path` 中弹出，**以恢复本次尝试之前的状态**。\n\n观察下图所示的过程，**我们可以将尝试和回退理解为“前进”与“撤销”**，两个操作是互为逆向的。\n\n=== \"<1>\"\n    ![尝试与回退](backtracking_algorithm.assets/preorder_find_paths_step1.png)\n\n=== \"<2>\"\n    ![preorder_find_paths_step2](backtracking_algorithm.assets/preorder_find_paths_step2.png)\n\n=== \"<3>\"\n    ![preorder_find_paths_step3](backtracking_algorithm.assets/preorder_find_paths_step3.png)\n\n=== \"<4>\"\n    ![preorder_find_paths_step4](backtracking_algorithm.assets/preorder_find_paths_step4.png)\n\n=== \"<5>\"\n    ![preorder_find_paths_step5](backtracking_algorithm.assets/preorder_find_paths_step5.png)\n\n=== \"<6>\"\n    ![preorder_find_paths_step6](backtracking_algorithm.assets/preorder_find_paths_step6.png)\n\n=== \"<7>\"\n    ![preorder_find_paths_step7](backtracking_algorithm.assets/preorder_find_paths_step7.png)\n\n=== \"<8>\"\n    ![preorder_find_paths_step8](backtracking_algorithm.assets/preorder_find_paths_step8.png)\n\n=== \"<9>\"\n    ![preorder_find_paths_step9](backtracking_algorithm.assets/preorder_find_paths_step9.png)\n\n=== \"<10>\"\n    ![preorder_find_paths_step10](backtracking_algorithm.assets/preorder_find_paths_step10.png)\n\n=== \"<11>\"\n    ![preorder_find_paths_step11](backtracking_algorithm.assets/preorder_find_paths_step11.png)\n\n## 剪枝\n\n复杂的回溯问题通常包含一个或多个约束条件，**约束条件通常可用于“剪枝”**。\n\n!!! question \"例题三\"\n\n    在二叉树中搜索所有值为 $7$ 的节点，请返回根节点到这些节点的路径，**并要求路径中不包含值为 $3$ 的节点**。\n\n为了满足以上约束条件，**我们需要添加剪枝操作**：在搜索过程中，若遇到值为 $3$ 的节点，则提前返回，停止继续搜索。\n\n```src\n[file]{preorder_traversal_iii_compact}-[class]{}-[func]{pre_order}\n```\n\n剪枝是一个非常形象的名词。如下图所示，在搜索过程中，**我们“剪掉”了不满足约束条件的搜索分支**，避免许多无意义的尝试，从而提高了搜索效率。\n\n![根据约束条件剪枝](backtracking_algorithm.assets/preorder_find_constrained_paths.png)",
          "questions": [
            "什么是回溯算法？它的核心思想是什么？",
            "回溯算法通常采用什么方式来遍历解空间？",
            "什么是深度优先搜索？前序、中序和后序遍历属于哪种搜索？",
            "在例题一中，如何搜索并记录所有值为7的节点？",
            "什么是回溯算法中的“尝试”和“回退”策略？为什么称之为回溯算法？",
            "在例题二中，如何搜索所有值为7的节点并返回根节点到这些节点的路径？",
            "在回溯算法中，除了函数返回，还有哪些操作属于“回退”？",
            "什么是回溯问题中的约束条件？如何利用约束条件进行剪枝操作？",
            "在例题三中，如何搜索所有值为7的节点并返回根节点到这些节点的路径，同时要求路径中不包含值为3的节点？",
            "剪枝是什么？如何通过剪枝操作提高回溯算法的效率？"
          ]
        },
        {
          "content": "## 框架代码\n\n接下来，我们尝试将回溯的“尝试、回退、剪枝”的主体框架提炼出来，提升代码的通用性。\n\n在以下框架代码中，`state` 表示问题的当前状态，`choices` 表示当前状态下可以做出的选择。\n\n=== \"Python\"\n\n    ```python title=\"\"\n    def backtrack(state: State, choices: list[choice], res: list[state]):\n        \"\"\"回溯算法框架\"\"\"\n        # 判断是否为解\n        if is_solution(state):\n            # 记录解\n            record_solution(state, res)\n            # 停止继续搜索\n            return\n        # 遍历所有选择\n        for choice in choices:\n            # 剪枝：判断选择是否合法\n            if is_valid(state, choice):\n                # 尝试：做出选择，更新状态\n                make_choice(state, choice)\n                backtrack(state, choices, res)\n                # 回退：撤销选择，恢复到之前的状态\n                undo_choice(state, choice)\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"\"\n    /* 回溯算法框架 */\n    void backtrack(State *state, vector<Choice *> &choices, vector<State *> &res) {\n        // 判断是否为解\n        if (isSolution(state)) {\n            // 记录解\n            recordSolution(state, res);\n            // 停止继续搜索\n            return;\n        }\n        // 遍历所有选择\n        for (Choice choice : choices) {\n            // 剪枝：判断选择是否合法\n            if (isValid(state, choice)) {\n                // 尝试：做出选择，更新状态\n                makeChoice(state, choice);\n                backtrack(state, choices, res);\n                // 回退：撤销选择，恢复到之前的状态\n                undoChoice(state, choice);\n            }\n        }\n    }\n    ```\n\n=== \"Java\"\n\n    ```java title=\"\"\n    /* 回溯算法框架 */\n    void backtrack(State state, List<Choice> choices, List<State> res) {\n        // 判断是否为解\n        if (isSolution(state)) {\n            // 记录解\n            recordSolution(state, res);\n            // 停止继续搜索\n            return;\n        }\n        // 遍历所有选择\n        for (Choice choice : choices) {\n            // 剪枝：判断选择是否合法\n            if (isValid(state, choice)) {\n                // 尝试：做出选择，更新状态\n                makeChoice(state, choice);\n                backtrack(state, choices, res);\n                // 回退：撤销选择，恢复到之前的状态\n                undoChoice(state, choice);\n            }\n        }\n    }\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"\"\n    /* 回溯算法框架 */\n    void Backtrack(State state, List<Choice> choices, List<State> res) {\n        // 判断是否为解\n        if (IsSolution(state)) {\n            // 记录解\n            RecordSolution(state, res);\n            // 停止继续搜索\n            return;\n        }\n        // 遍历所有选择\n        foreach (Choice choice in choices) {\n            // 剪枝：判断选择是否合法\n            if (IsValid(state, choice)) {\n                // 尝试：做出选择，更新状态\n                MakeChoice(state, choice);\n                Backtrack(state, choices, res);\n                // 回退：撤销选择，恢复到之前的状态\n                UndoChoice(state, choice);\n            }\n        }\n    }\n    ```\n\n=== \"Go\"\n\n    ```go title=\"\"\n    /* 回溯算法框架 */\n    func backtrack(state *State, choices []Choice, res *[]State) {\n        // 判断是否为解\n        if isSolution(state) {\n            // 记录解\n            recordSolution(state, res)\n            // 停止继续搜索\n            return\n        }\n        // 遍历所有选择\n        for _, choice := range choices {\n            // 剪枝：判断选择是否合法\n            if isValid(state, choice) {\n                // 尝试：做出选择，更新状态\n                makeChoice(state, choice)\n                backtrack(state, choices, res)\n                // 回退：撤销选择，恢复到之前的状态\n                undoChoice(state, choice)\n            }\n        }\n    }\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"\"\n    /* 回溯算法框架 */\n    func backtrack(state: inout State, choices: [Choice], res: inout [State]) {\n        // 判断是否为解\n        if isSolution(state: state) {\n            // 记录解\n            recordSolution(state: state, res: &res)\n            // 停止继续搜索\n            return\n        }\n        // 遍历所有选择\n        for choice in choices {\n            // 剪枝：判断选择是否合法\n            if isValid(state: state, choice: choice) {\n                // 尝试：做出选择，更新状态\n                makeChoice(state: &state, choice: choice)\n                backtrack(state: &state, choices: choices, res: &res)\n                // 回退：撤销选择，恢复到之前的状态\n                undoChoice(state: &state, choice: choice)\n            }\n        }\n    }\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"\"\n    /* 回溯算法框架 */\n    function backtrack(state, choices, res) {\n        // 判断是否为解\n        if (isSolution(state)) {\n            // 记录解\n            recordSolution(state, res);\n            // 停止继续搜索\n            return;\n        }\n        // 遍历所有选择\n        for (let choice of choices) {\n            // 剪枝：判断选择是否合法\n            if (isValid(state, choice)) {\n                // 尝试：做出选择，更新状态\n                makeChoice(state, choice);\n                backtrack(state, choices, res);\n                // 回退：撤销选择，恢复到之前的状态\n                undoChoice(state, choice);\n            }\n        }\n    }\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"\"\n    /* 回溯算法框架 */\n    function backtrack(state: State, choices: Choice[], res: State[]): void {\n        // 判断是否为解\n        if (isSolution(state)) {\n            // 记录解\n            recordSolution(state, res);\n            // 停止继续搜索\n            return;\n        }\n        // 遍历所有选择\n        for (let choice of choices) {\n            // 剪枝：判断选择是否合法\n            if (isValid(state, choice)) {\n                // 尝试：做出选择，更新状态\n                makeChoice(state, choice);\n                backtrack(state, choices, res);\n                // 回退：撤销选择，恢复到之前的状态\n                undoChoice(state, choice);\n            }\n        }\n    }\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"\"\n    /* 回溯算法框架 */\n    void backtrack(State state, List<Choice>, List<State> res) {\n      // 判断是否为解\n      if (isSolution(state)) {\n        // 记录解\n        recordSolution(state, res);\n        // 停止继续搜索\n        return;\n      }\n      // 遍历所有选择\n      for (Choice choice in choices) {\n        // 剪枝：判断选择是否合法\n        if (isValid(state, choice)) {\n          // 尝试：做出选择，更新状态\n          makeChoice(state, choice);\n          backtrack(state, choices, res);\n          // 回退：撤销选择，恢复到之前的状态\n          undoChoice(state, choice);\n        }\n      }\n    }\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"\"\n    /* 回溯算法框架 */\n    fn backtrack(state: &mut State, choices: &Vec<Choice>, res: &mut Vec<State>) {\n        // 判断是否为解\n        if is_solution(state) {\n            // 记录解\n            record_solution(state, res);\n            // 停止继续搜索\n            return;\n        }\n        // 遍历所有选择\n        for choice in choices {\n            // 剪枝：判断选择是否合法\n            if is_valid(state, choice) {\n                // 尝试：做出选择，更新状态\n                make_choice(state, choice);\n                backtrack(state, choices, res);\n                // 回退：撤销选择，恢复到之前的状态\n                undo_choice(state, choice);\n            }\n        }\n    }\n    ```\n\n=== \"C\"\n\n    ```c title=\"\"\n    /* 回溯算法框架 */\n    void backtrack(State *state, Choice *choices, int numChoices, State *res, int numRes) {\n        // 判断是否为解\n        if (isSolution(state)) {\n            // 记录解\n            recordSolution(state, res, numRes);\n            // 停止继续搜索\n            return;\n        }\n        // 遍历所有选择\n        for (int i = 0; i < numChoices; i++) {\n            // 剪枝：判断选择是否合法\n            if (isValid(state, &choices[i])) {\n                // 尝试：做出选择，更新状态\n                makeChoice(state, &choices[i]);\n                backtrack(state, choices, numChoices, res, numRes);\n                // 回退：撤销选择，恢复到之前的状态\n                undoChoice(state, &choices[i]);\n            }\n        }\n    }\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"\"\n\n    ```\n\n接下来，我们基于框架代码来解决例题三。状态 `state` 为节点遍历路径，选择 `choices` 为当前节点的左子节点和右子节点，结果 `res` 是路径列表。\n\n```src\n[file]{preorder_traversal_iii_template}-[class]{}-[func]{backtrack}\n```\n\n根据题意，我们在找到值为 $7$ 的节点后应该继续搜索，**因此需要将记录解之后的 `return` 语句删除**。下图对比了保留或删除 `return` 语句的搜索过程。\n\n![保留与删除 return 的搜索过程对比](backtracking_algorithm.assets/backtrack_remove_return_or_not.png)\n\n相比基于前序遍历的代码实现，基于回溯算法框架的代码实现虽然显得啰嗦，但通用性更好。实际上，**许多回溯问题都可以在该框架下解决**。我们只需根据具体问题来定义 `state` 和 `choices` ，并实现框架中的各个方法即可。",
          "questions": [
            "如何判断一个状态是否为解？",
            "在回溯算法中，什么是剪枝？为什么要进行剪枝？",
            "在回溯算法中，什么是尝试？为什么要进行尝试？",
            "在回溯算法中，什么是回退？为什么要进行回退？",
            "在回溯算法中，如何记录解？",
            "除了回溯算法，还有哪些常见的搜索算法？",
            "在回溯算法中，如何定义状态和选择？",
            "在回溯算法中，如何实现剪枝、尝试和回退？",
            "在回溯算法中，如何遍历所有选择？",
            "在回溯算法中，如何恢复到之前的状态？"
          ]
        },
        {
          "content": "## 常用术语\n\n为了更清晰地分析算法问题，我们总结一下回溯算法中常用术语的含义，并对照例题三给出对应示例。\n\n<p align=\"center\"> 表 <id> &nbsp; 常见的回溯算法术语 </p>\n\n| 名词                | 定义                                                                       | 例题三                                                               |\n| ------------------- | -------------------------------------------------------------------------- | -------------------------------------------------------------------- |\n| 解 Solution         | 解是满足问题特定条件的答案，可能有一个或多个                               | 根节点到节点 $7$ 的满足约束条件的所有路径                            |\n| 约束条件 Constraint | 约束条件是问题中限制解的可行性的条件，通常用于剪枝                         | 路径中不包含节点 $3$                                                 |\n| 状态 State          | 状态表示问题在某一时刻的情况，包括已经做出的选择                           | 当前已访问的节点路径，即 `path` 节点列表                             |\n| 尝试 Attempt        | 尝试是根据可用选择来探索解空间的过程，包括做出选择，更新状态，检查是否为解 | 递归访问左（右）子节点，将节点添加进 `path` ，判断节点的值是否为 $7$ |\n| 回退 Backtracking   | 回退指遇到不满足约束条件的状态时，撤销前面做出的选择，回到上一个状态       | 当越过叶结点、结束结点访问、遇到值为 $3$ 的节点时终止搜索，函数返回  |\n| 剪枝 Pruning        | 剪枝是根据问题特性和约束条件避免无意义的搜索路径的方法，可提高搜索效率     | 当遇到值为 $3$ 的节点时，则终止继续搜索                              |\n\n!!! tip\n\n    问题、解、状态等概念是通用的，在分治、回溯、动态规划、贪心等算法中都有涉及。\n\n## 优势与局限性\n\n回溯算法本质上是一种深度优先搜索算法，它尝试所有可能的解决方案直到找到满足条件的解。这种方法的优势在于它能够找到所有可能的解决方案，而且在合理的剪枝操作下，具有很高的效率。\n\n然而，在处理大规模或者复杂问题时，**回溯算法的运行效率可能难以接受**。\n\n- **时间**：回溯算法通常需要遍历状态空间的所有可能，时间复杂度可以达到指数阶或阶乘阶。\n- **空间**：在递归调用中需要保存当前的状态（例如路径、用于剪枝的辅助变量等），当深度很大时，空间需求可能会变得很大。\n\n即便如此，**回溯算法仍然是某些搜索问题和约束满足问题的最佳解决方案**。对于这些问题，由于无法预测哪些选择可生成有效的解，因此我们必须对所有可能的选择进行遍历。在这种情况下，**关键是如何进行效率优化**，常见的效率优化方法有两种。\n\n- **剪枝**：避免搜索那些肯定不会产生解的路径，从而节省时间和空间。\n- **启发式搜索**：在搜索过程中引入一些策略或者估计值，从而优先搜索最有可能产生有效解的路径。\n\n## 回溯典型例题\n\n回溯算法可用于解决许多搜索问题、约束满足问题和组合优化问题。\n\n**搜索问题**：这类问题的目标是找到满足特定条件的解决方案。\n\n- 全排列问题：给定一个集合，求出其所有可能的排列组合。\n- 子集和问题：给定一个集合和一个目标和，找到集合中所有和为目标和的子集。\n- 汉诺塔问题：给定三个柱子和一系列大小不同的圆盘，要求将所有圆盘从一个柱子移动到另一个柱子，每次只能移动一个圆盘，且不能将大圆盘放在小圆盘上。\n\n**约束满足问题**：这类问题的目标是找到满足所有约束条件的解。\n\n- $n$ 皇后：在 $n \\times n$ 的棋盘上放置 $n$ 个皇后，使得它们互不攻击。\n- 数独：在 $9 \\times 9$ 的网格中填入数字 $1$ ~ $9$ ，使得每行、每列和每个 $3 \\times 3$ 子网格中的数字不重复。\n- 图着色问题：给定一个无向图，用最少的颜色给图的每个顶点着色，使得相邻顶点颜色不同。\n\n**组合优化问题**：这类问题的目标是在一个组合空间中找到满足某些条件的最优解。\n\n- 0-1 背包问题：给定一组物品和一个背包，每个物品有一定的价值和重量，要求在背包容量限制内，选择物品使得总价值最大。\n- 旅行商问题：在一个图中，从一个点出发，访问所有其他点恰好一次后返回起点，求最短路径。\n- 最大团问题：给定一个无向图，找到最大的完全子图，即子图中的任意两个顶点之间都有边相连。\n\n请注意，对于许多组合优化问题，回溯都不是最优解决方案。\n\n- 0-1 背包问题通常使用动态规划解决，以达到更高的时间效率。\n- 旅行商是一个著名的 NP-Hard 问题，常用解法有遗传算法和蚁群算法等。\n- 最大团问题是图论中的一个经典问题，可用贪心等启发式算法来解决。",
          "questions": [
            "回溯算法的优势和局限性分别是什么？",
            "在回溯算法中，常用的术语有哪些？请分别解释它们的含义。",
            "回溯算法本质上是一种什么样的搜索算法？它的特点是什么？",
            "回溯算法在处理大规模或复杂问题时可能存在哪些问题？如何进行效率优化？",
            "什么是搜索问题？请举例说明。",
            "什么是约束满足问题？请举例说明。",
            "什么是组合优化问题？请举例说明。",
            "回溯算法适用于哪些类型的问题？为什么？",
            "除了回溯算法，还有哪些算法可以解决搜索问题和约束满足问题？",
            "除了回溯算法，还有哪些算法可以解决组合优化问题？"
          ]
        }
      ]
    },
    {
      "file_name": "queue.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 队列\n\n「队列 queue」是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列的尾部，而位于队列头部的人逐个离开。\n\n如下图所示，我们将队列的头部称为“队首”，尾部称为“队尾”，将把元素加入队尾的操作称为“入队”，删除队首元素的操作称为“出队”。\n\n![队列的先入先出规则](queue.assets/queue_operations.png)\n\n## 队列常用操作\n\n队列的常见操作如下表所示。需要注意的是，不同编程语言的方法名称可能会有所不同。我们在此采用与栈相同的方法命名。\n\n<p align=\"center\"> 表 <id> &nbsp; 队列操作效率 </p>\n\n| 方法名     | 描述                        | 时间复杂度 |\n| --------- | -------------------------- | -------- |\n| push()    | 元素入队，即将元素添加至队尾    | $O(1)$   |\n| pop()     | 队首元素出队                 | $O(1)$   |\n| peek()    | 访问队首元素                 | $O(1)$   |\n\n我们可以直接使用编程语言中现成的队列类。\n\n=== \"Python\"\n\n    ```python title=\"queue.py\"\n    # 初始化队列\n    # 在 Python 中，我们一般将双向队列类 deque 看作队列使用\n    # 虽然 queue.Queue() 是纯正的队列类，但不太好用，因此不建议\n    que: deque[int] = collections.deque()\n    \n    # 元素入队\n    que.append(1)\n    que.append(3)\n    que.append(2)\n    que.append(5)\n    que.append(4)\n    \n    # 访问队首元素\n    front: int = que[0];\n    \n    # 元素出队\n    pop: int = que.popleft()\n    \n    # 获取队列的长度\n    size: int = len(que)\n    \n    # 判断队列是否为空\n    is_empty: bool = len(que) == 0\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"queue.cpp\"\n    /* 初始化队列 */\n    queue<int> queue;\n    \n    /* 元素入队 */\n    queue.push(1);\n    queue.push(3);\n    queue.push(2);\n    queue.push(5);\n    queue.push(4);\n    \n    /* 访问队首元素 */\n    int front = queue.front();\n    \n    /* 元素出队 */\n    queue.pop();\n    \n    /* 获取队列的长度 */\n    int size = queue.size();\n    \n    /* 判断队列是否为空 */\n    bool empty = queue.empty();\n    ```\n\n=== \"Java\"\n\n    ```java title=\"queue.java\"\n    /* 初始化队列 */\n    Queue<Integer> queue = new LinkedList<>();\n    \n    /* 元素入队 */\n    queue.offer(1);\n    queue.offer(3);\n    queue.offer(2);\n    queue.offer(5);\n    queue.offer(4);\n    \n    /* 访问队首元素 */\n    int peek = queue.peek();\n    \n    /* 元素出队 */\n    int pop = queue.poll();\n    \n    /* 获取队列的长度 */\n    int size = queue.size();\n    \n    /* 判断队列是否为空 */\n    boolean isEmpty = queue.isEmpty();\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"queue.cs\"\n    /* 初始化队列 */\n    Queue<int> queue = new();\n    \n    /* 元素入队 */\n    queue.Enqueue(1);\n    queue.Enqueue(3);\n    queue.Enqueue(2);\n    queue.Enqueue(5);\n    queue.Enqueue(4);\n    \n    /* 访问队首元素 */\n    int peek = queue.Peek();\n    \n    /* 元素出队 */\n    int pop = queue.Dequeue();\n    \n    /* 获取队列的长度 */\n    int size = queue.Count;\n    \n    /* 判断队列是否为空 */\n    bool isEmpty = queue.Count == 0;\n    ```\n\n=== \"Go\"\n\n    ```go title=\"queue_test.go\"\n    /* 初始化队列 */\n    // 在 Go 中，将 list 作为队列来使用\n    queue := list.New()\n    \n    /* 元素入队 */\n    queue.PushBack(1)\n    queue.PushBack(3)\n    queue.PushBack(2)\n    queue.PushBack(5)\n    queue.PushBack(4)\n    \n    /* 访问队首元素 */\n    peek := queue.Front()\n    \n    /* 元素出队 */\n    pop := queue.Front()\n    queue.Remove(pop)\n    \n    /* 获取队列的长度 */\n    size := queue.Len()\n    \n    /* 判断队列是否为空 */\n    isEmpty := queue.Len() == 0\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"queue.swift\"\n    /* 初始化队列 */\n    // Swift 没有内置的队列类，可以把 Array 当作队列来使用\n    var queue: [Int] = []\n    \n    /* 元素入队 */\n    queue.append(1)\n    queue.append(3)\n    queue.append(2)\n    queue.append(5)\n    queue.append(4)\n    \n    /* 访问队首元素 */\n    let peek = queue.first!\n    \n    /* 元素出队 */\n    // 由于是数组，因此 removeFirst 的复杂度为 O(n)\n    let pool = queue.removeFirst()\n    \n    /* 获取队列的长度 */\n    let size = queue.count\n    \n    /* 判断队列是否为空 */\n    let isEmpty = queue.isEmpty\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"queue.js\"\n    /* 初始化队列 */\n    // JavaScript 没有内置的队列，可以把 Array 当作队列来使用\n    const queue = [];\n    \n    /* 元素入队 */\n    queue.push(1);\n    queue.push(3);\n    queue.push(2);\n    queue.push(5);\n    queue.push(4);\n    \n    /* 访问队首元素 */\n    const peek = queue[0];\n    \n    /* 元素出队 */\n    // 底层是数组，因此 shift() 方法的时间复杂度为 O(n)\n    const pop = queue.shift();\n    \n    /* 获取队列的长度 */\n    const size = queue.length;\n    \n    /* 判断队列是否为空 */\n    const empty = queue.length === 0;\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"queue.ts\"\n    /* 初始化队列 */\n    // TypeScript 没有内置的队列，可以把 Array 当作队列来使用 \n    const queue: number[] = [];\n    \n    /* 元素入队 */\n    queue.push(1);\n    queue.push(3);\n    queue.push(2);\n    queue.push(5);\n    queue.push(4);\n    \n    /* 访问队首元素 */\n    const peek = queue[0];\n    \n    /* 元素出队 */\n    // 底层是数组，因此 shift() 方法的时间复杂度为 O(n)\n    const pop = queue.shift();\n    \n    /* 获取队列的长度 */\n    const size = queue.length;\n    \n    /* 判断队列是否为空 */\n    const empty = queue.length === 0;\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"queue.dart\"\n    /* 初始化队列 */\n    // 在 Dart 中，队列类 Qeque 是双向队列，也可作为队列使用\n    Queue<int> queue = Queue();\n\n    /* 元素入队 */\n    queue.add(1);\n    queue.add(3);\n    queue.add(2);\n    queue.add(5);\n    queue.add(4);\n\n    /* 访问队首元素 */\n    int peek = queue.first;\n\n    /* 元素出队 */\n    int pop = queue.removeFirst();\n\n    /* 获取队列的长度 */\n    int size = queue.length;\n\n    /* 判断队列是否为空 */\n    bool isEmpty = queue.isEmpty;\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"queue.rs\"\n    /* 初始化双向队列 */\n    // 在 Rust 中使用双向队列作为普通队列来使用\n    let mut deque: VecDeque<u32> = VecDeque::new();\n\n    /* 元素入队 */\n    deque.push_back(1);\n    deque.push_back(3);\n    deque.push_back(2);\n    deque.push_back(5);\n    deque.push_back(4);\n\n    /* 访问队首元素 */\n    if let Some(front) = deque.front() {\n    }\n\n    /* 元素出队 */\n    if let Some(pop) = deque.pop_front() {\n    }\n\n    /* 获取队列的长度 */\n    let size = deque.len();\n\n    /* 判断队列是否为空 */\n    let is_empty = deque.is_empty();\n    ```\n\n=== \"C\"\n\n    ```c title=\"queue.c\"\n    // C 未提供内置队列\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"queue.zig\"\n\n    ```\n\n## 队列实现\n\n为了实现队列，我们需要一种数据结构，可以在一端添加元素，并在另一端删除元素。因此，链表和数组都可以用来实现队列。\n\n### 基于链表的实现\n\n如下图所示，我们可以将链表的“头节点”和“尾节点”分别视为“队首”和“队尾”，规定队尾仅可添加节点，队首仅可删除节点。\n\n=== \"LinkedListQueue\"\n    ![基于链表实现队列的入队出队操作](queue.assets/linkedlist_queue.png)\n\n=== \"push()\"\n    ![linkedlist_queue_push](queue.assets/linkedlist_queue_push.png)\n\n=== \"pop()\"\n    ![linkedlist_queue_pop](queue.assets/linkedlist_queue_pop.png)\n\n以下是用链表实现队列的代码。\n\n```src\n[file]{linkedlist_queue}-[class]{linked_list_queue}-[func]{}\n```",
          "questions": [
            "队列是什么？它遵循什么规则？",
            "队列的头部和尾部分别被称为什么？",
            "入队和出队分别是什么操作？",
            "队列的常见操作有哪些？它们的时间复杂度是多少？",
            "Python中如何初始化队列？如何进行元素入队和出队操作？",
            "C++中如何初始化队列？如何进行元素入队和出队操作？",
            "Java中如何初始化队列？如何进行元素入队和出队操作？",
            "Go中如何初始化队列？如何进行元素入队和出队操作？",
            "Swift中如何初始化队列？如何进行元素入队和出队操作？",
            "Dart中如何初始化队列？如何进行元素入队和出队操作？"
          ]
        },
        {
          "content": "### 基于数组的实现\n\n由于数组删除首元素的时间复杂度为 $O(n)$ ，这会导致出队操作效率较低。然而，我们可以采用以下巧妙方法来避免这个问题。\n\n我们可以使用一个变量 `front` 指向队首元素的索引，并维护一个变量 `size` 用于记录队列长度。定义 `rear = front + size` ，这个公式计算出的 `rear` 指向队尾元素之后的下一个位置。\n\n基于此设计，**数组中包含元素的有效区间为 `[front, rear - 1]`**，各种操作的实现方法如下图所示。\n\n- 入队操作：将输入元素赋值给 `rear` 索引处，并将 `size` 增加 1 。\n- 出队操作：只需将 `front` 增加 1 ，并将 `size` 减少 1 。\n\n可以看到，入队和出队操作都只需进行一次操作，时间复杂度均为 $O(1)$ 。\n\n=== \"ArrayQueue\"\n    ![基于数组实现队列的入队出队操作](queue.assets/array_queue.png)\n\n=== \"push()\"\n    ![array_queue_push](queue.assets/array_queue_push.png)\n\n=== \"pop()\"\n    ![array_queue_pop](queue.assets/array_queue_pop.png)\n\n你可能会发现一个问题：在不断进行入队和出队的过程中，`front` 和 `rear` 都在向右移动，**当它们到达数组尾部时就无法继续移动了**。为解决此问题，我们可以将数组视为首尾相接的“环形数组”。\n\n对于环形数组，我们需要让 `front` 或 `rear` 在越过数组尾部时，直接回到数组头部继续遍历。这种周期性规律可以通过“取余操作”来实现，代码如下所示。\n\n```src\n[file]{array_queue}-[class]{array_queue}-[func]{}\n```\n\n以上实现的队列仍然具有局限性，即其长度不可变。然而，这个问题不难解决，我们可以将数组替换为动态数组，从而引入扩容机制。有兴趣的同学可以尝试自行实现。\n\n两种实现的对比结论与栈一致，在此不再赘述。\n\n## 队列典型应用\n\n- **淘宝订单**。购物者下单后，订单将加入队列中，系统随后会根据顺序依次处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。\n- **各类待办事项**。任何需要实现“先来后到”功能的场景，例如打印机的任务队列、餐厅的出餐队列等。队列在这些场景中可以有效地维护处理顺序。",
          "questions": [
            "如何避免数组删除首元素的时间复杂度为 O(n) ？",
            "什么是 front 和 rear ？",
            "如何计算 rear 的值？",
            "数组中包含元素的有效区间是什么？",
            "入队和出队操作的时间复杂度分别是多少？",
            "如何解决 front 和 rear 到达数组尾部时无法继续移动的问题？",
            "如何实现环形数组？",
            "队列的长度是否可变？如何实现队列长度的动态变化？",
            "队列的典型应用有哪些？",
            "队列在高并发场景中有哪些应用？"
          ]
        }
      ]
    },
    {
      "file_name": "replace_linear_by_hashing.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 哈希优化策略\n\n在算法题中，**我们常通过将线性查找替换为哈希查找来降低算法的时间复杂度**。我们借助一个算法题来加深理解。\n\n!!! question\n\n    给定一个整数数组 `nums` 和一个目标元素 `target` ，请在数组中搜索“和”为 `target` 的两个元素，并返回它们的数组索引。返回任意一个解即可。\n\n## 线性查找：以时间换空间\n\n考虑直接遍历所有可能的组合。如下图所示，我们开启一个两层循环，在每轮中判断两个整数的和是否为 `target` ，若是则返回它们的索引。\n\n![线性查找求解两数之和](replace_linear_by_hashing.assets/two_sum_brute_force.png)\n\n```src\n[file]{two_sum}-[class]{}-[func]{two_sum_brute_force}\n```\n\n此方法的时间复杂度为 $O(n^2)$ ，空间复杂度为 $O(1)$ ，在大数据量下非常耗时。\n\n## 哈希查找：以空间换时间\n\n考虑借助一个哈希表，键值对分别为数组元素和元素索引。循环遍历数组，每轮执行下图所示的步骤。\n\n1. 判断数字 `target - nums[i]` 是否在哈希表中，若是则直接返回这两个元素的索引。\n2. 将键值对 `nums[i]` 和索引 `i` 添加进哈希表。\n\n=== \"<1>\"\n    ![辅助哈希表求解两数之和](replace_linear_by_hashing.assets/two_sum_hashtable_step1.png)\n\n=== \"<2>\"\n    ![two_sum_hashtable_step2](replace_linear_by_hashing.assets/two_sum_hashtable_step2.png)\n\n=== \"<3>\"\n    ![two_sum_hashtable_step3](replace_linear_by_hashing.assets/two_sum_hashtable_step3.png)\n\n实现代码如下所示，仅需单层循环即可。\n\n```src\n[file]{two_sum}-[class]{}-[func]{two_sum_hash_table}\n```\n\n此方法通过哈希查找将时间复杂度从 $O(n^2)$ 降低至 $O(n)$ ，大幅提升运行效率。\n\n由于需要维护一个额外的哈希表，因此空间复杂度为 $O(n)$ 。**尽管如此，该方法的整体时空效率更为均衡，因此它是本题的最优解法**。",
          "questions": [
            "哈希表的时间复杂度是多少？",
            "哈希表的空间复杂度是多少？",
            "为什么哈希表能够提高算法的时间复杂度？",
            "为什么哈希表的空间复杂度为O(n)？",
            "什么是线性查找？",
            "线性查找的时间复杂度是多少？",
            "线性查找的空间复杂度是多少？",
            "为什么哈希表的时间复杂度为O(1)？",
            "为什么哈希表的空间复杂度为O(n)？",
            "为什么哈希表是本题的最优解法？"
          ]
        }
      ]
    },
    {
      "file_name": "binary_tree.md",
      "question_count": 30,
      "documents": [
        {
          "content": "# 二叉树\n\n「二叉树 binary tree」是一种非线性数据结构，代表着祖先与后代之间的派生关系，体现着“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含：值、左子节点引用、右子节点引用。\n\n=== \"Python\"\n\n    ```python title=\"\"\n    class TreeNode:\n        \"\"\"二叉树节点类\"\"\"\n        def __init__(self, val: int):\n            self.val: int = val                # 节点值\n            self.left: TreeNode | None = None  # 左子节点引用\n            self.right: TreeNode | None = None # 右子节点引用\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"\"\n    /* 二叉树节点结构体 */\n    struct TreeNode {\n        int val;          // 节点值\n        TreeNode *left;   // 左子节点指针\n        TreeNode *right;  // 右子节点指针\n        TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    };\n    ```\n\n=== \"Java\"\n\n    ```java title=\"\"\n    /* 二叉树节点类 */\n    class TreeNode {\n        int val;         // 节点值\n        TreeNode left;   // 左子节点引用\n        TreeNode right;  // 右子节点引用\n        TreeNode(int x) { val = x; }\n    }\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"\"\n    /* 二叉树节点类 */\n    class TreeNode {\n        int val;          // 节点值\n        TreeNode? left;   // 左子节点引用\n        TreeNode? right;  // 右子节点引用\n        TreeNode(int x) { val = x; }\n    }\n    ```\n\n=== \"Go\"\n\n    ```go title=\"\"\n    /* 二叉树节点结构体 */\n    type TreeNode struct {\n        Val   int\n        Left  *TreeNode\n        Right *TreeNode\n    }\n    /* 构造方法 */\n    func NewTreeNode(v int) *TreeNode {\n        return &TreeNode{\n            Left:  nil, // 左子节点指针\n            Right: nil, // 右子节点指针\n            Val:   v,   // 节点值\n        }\n    }\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"\"\n    /* 二叉树节点类 */\n    class TreeNode {\n        var val: Int // 节点值\n        var left: TreeNode? // 左子节点引用\n        var right: TreeNode? // 右子节点引用\n\n        init(x: Int) {\n            val = x\n        }\n    }\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"\"\n    /* 二叉树节点类 */\n    class TreeNode {\n        val; // 节点值\n        left; // 左子节点指针\n        right; // 右子节点指针\n        constructor(val, left, right) {\n            this.val = val === undefined ? 0 : val;\n            this.left = left === undefined ? null : left;\n            this.right = right === undefined ? null : right;\n        }\n    }\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"\"\n    /* 二叉树节点类 */\n    class TreeNode {\n        val: number;\n        left: TreeNode | null;\n        right: TreeNode | null;\n    \n        constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n            this.val = val === undefined ? 0 : val; // 节点值\n            this.left = left === undefined ? null : left; // 左子节点引用\n            this.right = right === undefined ? null : right; // 右子节点引用\n        }\n    }\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"\"\n    /* 二叉树节点类 */\n    class TreeNode {\n      int val;         // 节点值\n      TreeNode? left;  // 左子节点引用\n      TreeNode? right; // 右子节点引用\n      TreeNode(this.val, [this.left, this.right]);\n    }\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"\"\n    use std::rc::Rc;\n    use std::cell::RefCell;\n\n    /* 二叉树节点结构体 */\n    struct TreeNode {\n        val: i32,                               // 节点值\n        left: Option<Rc<RefCell<TreeNode>>>,    // 左子节点引用\n        right: Option<Rc<RefCell<TreeNode>>>,   // 右子节点引用\n    }\n\n    impl TreeNode {\n        /* 构造方法 */\n        fn new(val: i32) -> Rc<RefCell<Self>> {\n            Rc::new(RefCell::new(Self {\n                val,\n                left: None,\n                right: None\n            }))\n        }\n    }\n    ```\n\n=== \"C\"\n\n    ```c title=\"\"\n    /* 二叉树节点结构体 */\n    typedef struct TreeNode {\n        int val;                // 节点值\n        int height;             // 节点高度\n        struct TreeNode *left;  // 左子节点指针\n        struct TreeNode *right; // 右子节点指针\n    } TreeNode;\n\n    /* 构造函数 */\n    TreeNode *newTreeNode(int val) {\n        TreeNode *node;\n\n        node = (TreeNode *)malloc(sizeof(TreeNode));\n        node->val = val;\n        node->height = 0;\n        node->left = NULL;\n        node->right = NULL;\n        return node;\n    }\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"\"\n\n    ```\n\n每个节点都有两个引用（指针），分别指向「左子节点 left-child node」和「右子节点 right-child node」，该节点被称为这两个子节点的「父节点 parent node」。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的「左子树 left subtree」，同理可得「右子树 right subtree」。\n\n**在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树**。如下图所示，如果将“节点 2”视为父节点，则其左子节点和右子节点分别是“节点 4”和“节点 5”，左子树是“节点 4 及其以下节点形成的树”，右子树是“节点 5 及其以下节点形成的树”。\n\n![父节点、子节点、子树](binary_tree.assets/binary_tree_definition.png)\n\n## 二叉树常见术语\n\n二叉树的常用术语如下图所示。\n\n- 「根节点 root node」：位于二叉树顶层的节点，没有父节点。\n- 「叶节点 leaf node」：没有子节点的节点，其两个指针均指向 $\\text{None}$ 。\n- 「边 edge」：连接两个节点的线段，即节点引用（指针）。\n- 节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。\n- 节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。\n- 二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。\n- 节点的「深度 depth」：从根节点到该节点所经过的边的数量。\n- 节点的「高度 height」：从最远叶节点到该节点所经过的边的数量。\n\n![二叉树的常用术语](binary_tree.assets/binary_tree_terminology.png)\n\n!!! tip\n\n    请注意，我们通常将“高度”和“深度”定义为“走过边的数量”，但有些题目或教材可能会将其定义为“走过节点的数量”。在这种情况下，高度和深度都需要加 1 。\n\n## 二叉树基本操作",
          "questions": [
            "二叉树的基本单元是什么？每个节点包含哪些内容？",
            "二叉树的节点类在 Python、C++、Java、C#、Go、Swift、JS、TS、Dart、Rust、C 语言中的实现分别是怎样的？",
            "什么是二叉树的根节点？它有哪些特点？",
            "什么是二叉树的叶节点？它有哪些特点？",
            "什么是二叉树的边？它有哪些特点？",
            "什么是二叉树的度？在二叉树中，度的取值范围是什么？",
            "什么是二叉树的高度？如何计算二叉树的高度？",
            "什么是二叉树的深度？如何计算二叉树的深度？",
            "什么是二叉树的层？如何计算二叉树的层数？",
            "二叉树的常用术语有哪些？它们分别代表什么意思？"
          ]
        },
        {
          "content": "### 初始化二叉树\n\n与链表类似，首先初始化节点，然后构建引用（指针）。\n\n=== \"Python\"\n\n    ```python title=\"binary_tree.py\"\n    # 初始化二叉树\n    # 初始化节点\n    n1 = TreeNode(val=1)\n    n2 = TreeNode(val=2)\n    n3 = TreeNode(val=3)\n    n4 = TreeNode(val=4)\n    n5 = TreeNode(val=5)\n    # 构建引用指向（即指针）\n    n1.left = n2\n    n1.right = n3\n    n2.left = n4\n    n2.right = n5\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"binary_tree.cpp\"\n    /* 初始化二叉树 */\n    // 初始化节点\n    TreeNode* n1 = new TreeNode(1);\n    TreeNode* n2 = new TreeNode(2);\n    TreeNode* n3 = new TreeNode(3);\n    TreeNode* n4 = new TreeNode(4);\n    TreeNode* n5 = new TreeNode(5);\n    // 构建引用指向（即指针）\n    n1->left = n2;\n    n1->right = n3;\n    n2->left = n4;\n    n2->right = n5;\n    ```\n\n=== \"Java\"\n\n    ```java title=\"binary_tree.java\"\n    // 初始化节点\n    TreeNode n1 = new TreeNode(1);\n    TreeNode n2 = new TreeNode(2);\n    TreeNode n3 = new TreeNode(3);\n    TreeNode n4 = new TreeNode(4);\n    TreeNode n5 = new TreeNode(5);\n    // 构建引用指向（即指针）\n    n1.left = n2;\n    n1.right = n3;\n    n2.left = n4;\n    n2.right = n5;\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"binary_tree.cs\"\n    /* 初始化二叉树 */\n    // 初始化节点\n    TreeNode n1 = new(1);\n    TreeNode n2 = new(2);\n    TreeNode n3 = new(3);\n    TreeNode n4 = new(4);\n    TreeNode n5 = new(5);\n    // 构建引用指向（即指针）\n    n1.left = n2;\n    n1.right = n3;\n    n2.left = n4;\n    n2.right = n5;\n    ```\n\n=== \"Go\"\n\n    ```go title=\"binary_tree.go\"\n    /* 初始化二叉树 */\n    // 初始化节点\n    n1 := NewTreeNode(1)\n    n2 := NewTreeNode(2)\n    n3 := NewTreeNode(3)\n    n4 := NewTreeNode(4)\n    n5 := NewTreeNode(5)\n    // 构建引用指向（即指针）\n    n1.Left = n2\n    n1.Right = n3\n    n2.Left = n4\n    n2.Right = n5\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"binary_tree.swift\"\n    // 初始化节点\n    let n1 = TreeNode(x: 1)\n    let n2 = TreeNode(x: 2)\n    let n3 = TreeNode(x: 3)\n    let n4 = TreeNode(x: 4)\n    let n5 = TreeNode(x: 5)\n    // 构建引用指向（即指针）\n    n1.left = n2\n    n1.right = n3\n    n2.left = n4\n    n2.right = n5\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"binary_tree.js\"\n    /* 初始化二叉树 */\n    // 初始化节点\n    let n1 = new TreeNode(1),\n        n2 = new TreeNode(2),\n        n3 = new TreeNode(3),\n        n4 = new TreeNode(4),\n        n5 = new TreeNode(5);\n    // 构建引用指向（即指针）\n    n1.left = n2;\n    n1.right = n3;\n    n2.left = n4;\n    n2.right = n5;\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"binary_tree.ts\"\n    /* 初始化二叉树 */\n    // 初始化节点\n    let n1 = new TreeNode(1),\n        n2 = new TreeNode(2),\n        n3 = new TreeNode(3),\n        n4 = new TreeNode(4),\n        n5 = new TreeNode(5);\n    // 构建引用指向（即指针）\n    n1.left = n2;\n    n1.right = n3;\n    n2.left = n4;\n    n2.right = n5;\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"binary_tree.dart\"\n    /* 初始化二叉树 */\n    // 初始化节点\n    TreeNode n1 = new TreeNode(1);\n    TreeNode n2 = new TreeNode(2);\n    TreeNode n3 = new TreeNode(3);\n    TreeNode n4 = new TreeNode(4);\n    TreeNode n5 = new TreeNode(5);\n    // 构建引用指向（即指针）\n    n1.left = n2;\n    n1.right = n3;\n    n2.left = n4;\n    n2.right = n5;\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"binary_tree.rs\"\n    // 初始化节点\n    let n1 = TreeNode::new(1);\n    let n2 = TreeNode::new(2);\n    let n3 = TreeNode::new(3);\n    let n4 = TreeNode::new(4);\n    let n5 = TreeNode::new(5);\n    // 构建引用指向（即指针）\n    n1.borrow_mut().left = Some(n2.clone());\n    n1.borrow_mut().right = Some(n3);\n    n2.borrow_mut().left = Some(n4);\n    n2.borrow_mut().right = Some(n5);\n    ```\n\n=== \"C\"\n\n    ```c title=\"binary_tree.c\"\n    /* 初始化二叉树 */\n    // 初始化节点\n    TreeNode *n1 = newTreeNode(1);\n    TreeNode *n2 = newTreeNode(2);\n    TreeNode *n3 = newTreeNode(3);\n    TreeNode *n4 = newTreeNode(4);\n    TreeNode *n5 = newTreeNode(5);\n    // 构建引用指向（即指针）\n    n1->left = n2;\n    n1->right = n3;\n    n2->left = n4;\n    n2->right = n5;\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"binary_tree.zig\"\n\n    ```\n\n### 插入与删除节点\n\n与链表类似，在二叉树中插入与删除节点可以通过修改指针来实现。下图给出了一个示例。\n\n![在二叉树中插入与删除节点](binary_tree.assets/binary_tree_add_remove.png)\n\n=== \"Python\"\n\n    ```python title=\"binary_tree.py\"\n    # 插入与删除节点\n    p = TreeNode(0)\n    # 在 n1 -> n2 中间插入节点 P\n    n1.left = p\n    p.left = n2\n    # 删除节点 P\n    n1.left = n2\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"binary_tree.cpp\"\n    /* 插入与删除节点 */\n    TreeNode* P = new TreeNode(0);\n    // 在 n1 -> n2 中间插入节点 P\n    n1->left = P;\n    P->left = n2;\n    // 删除节点 P\n    n1->left = n2;\n    ```\n\n=== \"Java\"\n\n    ```java title=\"binary_tree.java\"\n    TreeNode P = new TreeNode(0);\n    // 在 n1 -> n2 中间插入节点 P\n    n1.left = P;\n    P.left = n2;\n    // 删除节点 P\n    n1.left = n2;\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"binary_tree.cs\"\n    /* 插入与删除节点 */\n    TreeNode P = new(0);\n    // 在 n1 -> n2 中间插入节点 P\n    n1.left = P;\n    P.left = n2;\n    // 删除节点 P\n    n1.left = n2;\n    ```\n\n=== \"Go\"\n\n    ```go title=\"binary_tree.go\"\n    /* 插入与删除节点 */\n    // 在 n1 -> n2 中间插入节点 P\n    p := NewTreeNode(0)\n    n1.Left = p\n    p.Left = n2\n    // 删除节点 P\n    n1.Left = n2\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"binary_tree.swift\"\n    let P = TreeNode(x: 0)\n    // 在 n1 -> n2 中间插入节点 P\n    n1.left = P\n    P.left = n2\n    // 删除节点 P\n    n1.left = n2\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"binary_tree.js\"\n    /* 插入与删除节点 */\n    let P = new TreeNode(0);\n    // 在 n1 -> n2 中间插入节点 P\n    n1.left = P;\n    P.left = n2;\n    // 删除节点 P\n    n1.left = n2;\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"binary_tree.ts\"\n    /* 插入与删除节点 */\n    const P = new TreeNode(0);\n    // 在 n1 -> n2 中间插入节点 P\n    n1.left = P;\n    P.left = n2;\n    // 删除节点 P\n    n1.left = n2;\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"binary_tree.dart\"\n    /* 插入与删除节点 */\n    TreeNode P = new TreeNode(0);\n    // 在 n1 -> n2 中间插入节点 P\n    n1.left = P;\n    P.left = n2;\n    // 删除节点 P\n    n1.left = n2;\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"binary_tree.rs\"\n    let p = TreeNode::new(0);\n    // 在 n1 -> n2 中间插入节点 P\n    n1.borrow_mut().left = Some(p.clone());\n    p.borrow_mut().left = Some(n2.clone());\n    // 删除节点 p\n    n1.borrow_mut().left = Some(n2);\n    ```\n\n=== \"C\"\n\n    ```c title=\"binary_tree.c\"\n    /* 插入与删除节点 */\n    TreeNode *P = newTreeNode(0);\n    // 在 n1 -> n2 中间插入节点 P\n    n1->left = P;\n    P->left = n2;\n    // 删除节点 P\n    n1->left = n2;\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"binary_tree.zig\"\n\n    ```\n\n!!! note\n\n    需要注意的是，插入节点可能会改变二叉树的原有逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除操作通常是由一套操作配合完成的，以实现有实际意义的操作。\n\n## 常见二叉树类型\n\n### 完美二叉树\n\n「完美二叉树 perfect binary tree」所有层的节点都被完全填满。在完美二叉树中，叶节点的度为 $0$ ，其余所有节点的度都为 $2$ ；若树高度为 $h$ ，则节点总数为 $2^{h+1} - 1$ ，呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。\n\n!!! tip\n\n    请注意，在中文社区中，完美二叉树常被称为「满二叉树」。\n\n![完美二叉树](binary_tree.assets/perfect_binary_tree.png)",
          "questions": [
            "二叉树中节点的度数有哪些？",
            "什么是完美二叉树？它的节点总数与树高之间有什么关系？",
            "如何初始化一个二叉树？请给出 Python、C++、Java、C#、Go、Swift、JS、TS、Dart 和 Rust 的示例代码。",
            "如何在二叉树中插入和删除节点？请给出 Python、C++、Java、C#、Go、Swift、JS、TS、Dart 和 Rust 的示例代码。",
            "二叉树的遍历方式有哪些？它们的区别是什么？",
            "什么是二叉搜索树？它有什么特点？",
            "如何判断一个二叉树是否为二叉搜索树？请给出 Python、C++、Java、C#、Go、Swift、JS、TS、Dart 和 Rust 的示例代码。",
            "什么是平衡二叉树？它有什么特点？",
            "如何判断一个二叉树是否为平衡二叉树？请给出 Python、C++、Java、C#、Go、Swift、JS、TS、Dart 和 Rust 的示例代码。",
            "什么是红黑树？它有什么特点？"
          ]
        },
        {
          "content": "### 完全二叉树\n\n如下图所示，「完全二叉树 complete binary tree」只有最底层的节点未被填满，且最底层节点尽量靠左填充。\n\n![完全二叉树](binary_tree.assets/complete_binary_tree.png)\n\n### 完满二叉树\n\n如下图所示，「完满二叉树 full binary tree」除了叶节点之外，其余所有节点都有两个子节点。\n\n![完满二叉树](binary_tree.assets/full_binary_tree.png)\n\n### 平衡二叉树\n\n如下图所示，「平衡二叉树 balanced binary tree」中任意节点的左子树和右子树的高度之差的绝对值不超过 1 。\n\n![平衡二叉树](binary_tree.assets/balanced_binary_tree.png)\n\n## 二叉树的退化\n\n下图展示了二叉树的理想与退化状态。当二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”。\n\n- 完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。\n- 链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 $O(n)$ 。\n\n![二叉树的最佳与最差结构](binary_tree.assets/binary_tree_best_worst_cases.png)\n\n如下表所示，在最佳和最差结构下，二叉树的叶节点数量、节点总数、高度等达到极大或极小值。\n\n<p align=\"center\"> 表 <id> &nbsp; 二叉树的最佳与最差情况 </p>\n\n|                         | 完美二叉树         | 链表    |\n| ----------------------- | ------------------ | ------- |\n| 第 $i$ 层的节点数量     | $2^{i-1}$          | $1$     |\n| 高度 $h$ 树的叶节点数量 | $2^h$              | $1$     |\n| 高度 $h$ 树的节点总数   | $2^{h+1} - 1$      | $h + 1$ |\n| 节点总数 $n$ 树的高度   | $\\log_2 (n+1) - 1$ | $n - 1$ |",
          "questions": [
            "什么是完全二叉树？如何填充最底层的节点？",
            "什么是完满二叉树？除了叶节点，其余节点都有几个子节点？",
            "什么是平衡二叉树？如何定义平衡二叉树？",
            "什么是二叉树的退化？如何判断二叉树是否退化？",
            "什么是完美二叉树？如何计算完美二叉树的叶节点数量、节点总数、高度等？",
            "什么是链表二叉树？如何计算链表二叉树的叶节点数量、节点总数、高度等？",
            "二叉树的最佳结构和最差结构分别是什么？它们的叶节点数量、节点总数、高度等有何特点？",
            "为什么完美二叉树可以充分发挥二叉树“分治”的优势？",
            "为什么链表二叉树各项操作都变为线性操作，时间复杂度退化至 O(n)？",
            "如何计算节点总数为 n 的二叉树的高度？"
          ]
        }
      ]
    },
    {
      "file_name": "bucket_sort.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 桶排序\n\n前述的几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越 $O(n \\log n)$ 。接下来，我们将探讨几种“非比较排序算法”，它们的时间复杂度可以达到线性阶。\n\n「桶排序 bucket sort」是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。\n\n## 算法流程\n\n考虑一个长度为 $n$ 的数组，元素是范围 $[0, 1)$ 的浮点数。桶排序的流程如下图所示。\n\n1. 初始化 $k$ 个桶，将 $n$ 个元素分配到 $k$ 个桶中。\n2. 对每个桶分别执行排序（本文采用编程语言的内置排序函数）。\n3. 按照桶的从小到大的顺序，合并结果。\n\n![桶排序算法流程](bucket_sort.assets/bucket_sort_overview.png)\n\n```src\n[file]{bucket_sort}-[class]{}-[func]{bucket_sort}\n```\n\n## 算法特性\n\n桶排序适用于处理体量很大的数据。例如，输入数据包含 100 万个元素，由于空间限制，系统内存无法一次性加载所有数据。此时，可以将数据分成 1000 个桶，然后分别对每个桶进行排序，最后将结果合并。\n\n- **时间复杂度 $O(n + k)$** ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为 $\\frac{n}{k}$ 。假设排序单个桶使用 $O(\\frac{n}{k} \\log\\frac{n}{k})$ 时间，则排序所有桶使用 $O(n \\log\\frac{n}{k})$ 时间。**当桶数量 $k$ 比较大时，时间复杂度则趋向于 $O(n)$** 。合并结果时需要遍历所有桶和元素，花费 $O(n + k)$ 时间。\n- **自适应排序**：在最坏情况下，所有数据被分配到一个桶中，且排序该桶使用 $O(n^2)$ 时间。\n- **空间复杂度 $O(n + k)$、非原地排序**：需要借助 $k$ 个桶和总共 $n$ 个元素的额外空间。\n- 桶排序是否稳定取决于排序桶内元素的算法是否稳定。\n\n## 如何实现平均分配\n\n桶排序的时间复杂度理论上可以达到 $O(n)$ ，**关键在于将元素均匀分配到各个桶中**，因为实际数据往往不是均匀分布的。例如，我们想要将淘宝上的所有商品按价格范围平均分配到 10 个桶中，但商品价格分布不均，低于 100 元的非常多，高于 1000 元的非常少。若将价格区间平均划分为 10 份，各个桶中的商品数量差距会非常大。\n\n为实现平均分配，我们可以先设定一个大致的分界线，将数据粗略地分到 3 个桶中。**分配完毕后，再将商品较多的桶继续划分为 3 个桶，直至所有桶中的元素数量大致相等**。\n\n如下图所示，这种方法本质上是创建一个递归树，目标是让叶节点的值尽可能平均。当然，不一定要每轮将数据划分为 3 个桶，具体划分方式可根据数据特点灵活选择。\n\n![递归划分桶](bucket_sort.assets/scatter_in_buckets_recursively.png)\n\n如果我们提前知道商品价格的概率分布，**则可以根据数据概率分布设置每个桶的价格分界线**。值得注意的是，数据分布并不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似。\n\n如下图所示，我们假设商品价格服从正态分布，这样就可以合理地设定价格区间，从而将商品平均分配到各个桶中。\n\n![根据概率分布划分桶](bucket_sort.assets/scatter_in_buckets_distribution.png)",
          "questions": [
            "桶排序的时间复杂度可以达到多少？",
            "桶排序适用于处理什么样的数据？",
            "桶排序是否稳定？取决于什么因素？",
            "桶排序的空间复杂度是多少？是否原地排序？",
            "如何实现平均分配元素到各个桶中？",
            "桶排序的流程是怎样的？",
            "桶排序中，如何对每个桶进行排序？",
            "桶排序中，如何合并所有桶的结果？",
            "桶排序中，如何处理最坏情况下所有数据被分配到一个桶中的情况？",
            "桶排序中，如何根据数据概率分布设置每个桶的价格分界线？"
          ]
        }
      ]
    },
    {
      "file_name": "binary_search.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 二分查找\n\n「二分查找 binary search」是一种基于分治策略的高效搜索算法。它利用数据的有序性，每轮减少一半搜索范围，直至找到目标元素或搜索区间为空为止。\n\n!!! question\n\n    给定一个长度为 $n$ 的数组 `nums` ，元素按从小到大的顺序排列，数组不包含重复元素。请查找并返回元素 `target` 在该数组中的索引。若数组不包含该元素，则返回 $-1$ 。\n\n![二分查找示例数据](binary_search.assets/binary_search_example.png)\n\n如下图所示，我们先初始化指针 $i = 0$ 和 $j = n - 1$ ，分别指向数组首元素和尾元素，代表搜索区间 $[0, n - 1]$ 。请注意，中括号表示闭区间，其包含边界值本身。\n\n接下来，循环执行以下两步。\n\n1. 计算中点索引 $m = \\lfloor {(i + j) / 2} \\rfloor$ ，其中 $\\lfloor \\: \\rfloor$ 表示向下取整操作。\n2. 判断 `nums[m]` 和 `target` 的大小关系，分为以下三种情况。\n    1. 当 `nums[m] < target` 时，说明 `target` 在区间 $[m + 1, j]$ 中，因此执行 $i = m + 1$ 。\n    2. 当 `nums[m] > target` 时，说明 `target` 在区间 $[i, m - 1]$ 中，因此执行 $j = m - 1$ 。\n    3. 当 `nums[m] = target` 时，说明找到 `target` ，因此返回索引 $m$ 。\n\n若数组不包含目标元素，搜索区间最终会缩小为空。此时返回 $-1$ 。\n\n=== \"<1>\"\n    ![二分查找流程](binary_search.assets/binary_search_step1.png)\n\n=== \"<2>\"\n    ![binary_search_step2](binary_search.assets/binary_search_step2.png)\n\n=== \"<3>\"\n    ![binary_search_step3](binary_search.assets/binary_search_step3.png)\n\n=== \"<4>\"\n    ![binary_search_step4](binary_search.assets/binary_search_step4.png)\n\n=== \"<5>\"\n    ![binary_search_step5](binary_search.assets/binary_search_step5.png)\n\n=== \"<6>\"\n    ![binary_search_step6](binary_search.assets/binary_search_step6.png)\n\n=== \"<7>\"\n    ![binary_search_step7](binary_search.assets/binary_search_step7.png)\n\n值得注意的是，由于 $i$ 和 $j$ 都是 `int` 类型，**因此 $i + j$ 可能会超出 `int` 类型的取值范围**。为了避免大数越界，我们通常采用公式 $m = \\lfloor {i + (j - i) / 2} \\rfloor$ 来计算中点。\n\n```src\n[file]{binary_search}-[class]{}-[func]{binary_search}\n```\n\n**时间复杂度 $O(\\log n)$** ：在二分循环中，区间每轮缩小一半，循环次数为 $\\log_2 n$ 。\n\n**空间复杂度 $O(1)$** ：指针 $i$ 和 $j$ 使用常数大小空间。\n\n## 区间表示方法\n\n除了上述的双闭区间外，常见的区间表示还有“左闭右开”区间，定义为 $[0, n)$ ，即左边界包含自身，右边界不包含自身。在该表示下，区间 $[i, j]$ 在 $i = j$ 时为空。\n\n我们可以基于该表示实现具有相同功能的二分查找算法。\n\n```src\n[file]{binary_search}-[class]{}-[func]{binary_search_lcro}\n```\n\n如下图所示，在两种区间表示下，二分查找算法的初始化、循环条件和缩小区间操作皆有所不同。\n\n由于“双闭区间”表示中的左右边界都被定义为闭区间，因此指针 $i$ 和 $j$ 缩小区间操作也是对称的。这样更不容易出错，**因此一般建议采用“双闭区间”的写法**。\n\n![两种区间定义](binary_search.assets/binary_search_ranges.png)\n\n## 优点与局限性\n\n二分查找在时间和空间方面都有较好的性能。\n\n- 二分查找的时间效率高。在大数据量下，对数阶的时间复杂度具有显著优势。例如，当数据大小 $n = 2^{20}$ 时，线性查找需要 $2^{20} = 1048576$ 轮循环，而二分查找仅需 $\\log_2 2^{20} = 20$ 轮循环。\n- 二分查找无须额外空间。相较于需要借助额外空间的搜索算法（例如哈希查找），二分查找更加节省空间。\n\n然而，二分查找并非适用于所有情况，主要有以下原因。\n\n- 二分查找仅适用于有序数据。若输入数据无序，为了使用二分查找而专门进行排序，得不偿失。因为排序算法的时间复杂度通常为 $O(n \\log n)$ ，比线性查找和二分查找都更高。对于频繁插入元素的场景，为保持数组有序性，需要将元素插入到特定位置，时间复杂度为 $O(n)$ ，也是非常昂贵的。\n- 二分查找仅适用于数组。二分查找需要跳跃式（非连续地）访问元素，而在链表中执行跳跃式访问的效率较低，因此不适合应用在链表或基于链表实现的数据结构。\n- 小数据量下，线性查找性能更佳。在线性查找中，每轮只需要 1 次判断操作；而在二分查找中，需要 1 次加法、1 次除法、1 ~ 3 次判断操作、1 次加法（减法），共 4 ~ 6 个单元操作；因此，当数据量 $n$ 较小时，线性查找反而比二分查找更快。",
          "questions": [
            "二分查找算法的时间复杂度和空间复杂度分别是多少？",
            "为什么二分查找算法只适用于有序数据，而不适用于无序数据？",
            "在什么情况下，线性查找比二分查找更快？",
            "二分查找算法的区间表示方法有哪些？它们之间有什么区别？",
            "为什么在二分查找算法中，计算中点索引时要使用公式 $m = \\lfloor {i + (j - i) / 2} \\rfloor$ 而不是 $m = \\lfloor {(i + j) / 2} \\rfloor$ ？",
            "二分查找算法在链表中的效率为什么较低？",
            "二分查找算法的循环条件和缩小区间操作在不同的区间表示方法下有何不同？",
            "二分查找算法的优点和局限性分别有哪些？",
            "为什么在二分查找算法中，指针 $i$ 和 $j$ 的类型为 int 时可能会出现大数越界的问题？",
            "二分查找算法中，当数组不包含目标元素时，搜索区间最终会缩小到什么程度？"
          ]
        }
      ]
    },
    {
      "file_name": "build_heap.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 建堆操作\n\n在某些情况下，我们希望使用一个列表的所有元素来构建一个堆，这个过程被称为“建堆操作”。\n\n## 借助入堆操作实现\n\n我们首先创建一个空堆，然后遍历列表，依次对每个元素执行“入堆操作”，即先将元素添加至堆的尾部，再对该元素执行“从底至顶”堆化。\n\n每当一个元素入堆，堆的长度就加一。由于节点是从顶到底依次被添加进二叉树的，因此堆是“自上而下”地构建的。\n\n设元素数量为 $n$ ，每个元素的入堆操作使用 $O(\\log{n})$ 时间，因此该建堆方法的时间复杂度为 $O(n \\log n)$ 。\n\n## 通过遍历堆化实现\n\n实际上，我们可以实现一种更为高效的建堆方法，共分为两步。\n\n1. 将列表所有元素原封不动添加到堆中，此时堆的性质尚未得到满足。\n2. 倒序遍历堆（即层序遍历的倒序），依次对每个非叶节点执行“从顶至底堆化”。\n\n**每当堆化一个节点后，以该节点为根节点的子树就形成一个合法的子堆**。而由于是倒序遍历，因此堆是“自下而上”地被构建的。\n\n之所以选择倒序遍历，是因为这样能够保证当前节点之下的子树已经是合法的子堆，这样堆化当前节点才是有效的。\n\n值得说明的是，**叶节点没有子节点，天然就是合法的子堆，因此无需堆化**。如以下代码所示，最后一个非叶节点是最后一个节点的父节点，我们从它开始倒序遍历并执行堆化。\n\n```src\n[file]{my_heap}-[class]{max_heap}-[func]{__init__}\n```\n\n## 复杂度分析\n\n下面，我们来尝试推算第二种建堆方法的时间复杂度。\n\n- 假设完全二叉树的节点数量为 $n$ ，则叶节点数量为 $(n + 1) / 2$ ，其中 $/$ 为向下整除。因此需要堆化的节点数量为 $(n - 1) / 2$ 。\n- 在从顶至底堆化的过程中，每个节点最多堆化到叶节点，因此最大迭代次数为二叉树高度 $\\log n$ 。\n\n将上述两者相乘，可得到建堆过程的时间复杂度为 $O(n \\log n)$ 。**但这个估算结果并不准确，因为我们没有考虑到二叉树底层节点数量远多于顶层节点的性质**。\n\n接下来我们来进行更为准确的计算。为了减小计算难度，假设给定一个节点数量为 $n$ ，高度为 $h$ 的“完美二叉树”，该假设不会影响计算结果的正确性。\n\n![完美二叉树的各层节点数量](build_heap.assets/heapify_operations_count.png)\n\n如上图所示，节点“从顶至底堆化”的最大迭代次数等于该节点到叶节点的距离，而该距离正是“节点高度”。因此，我们可以将各层的“节点数量 $\\times$ 节点高度”求和，**从而得到所有节点的堆化迭代次数的总和**。\n\n$$\nT(h) = 2^0h + 2^1(h-1) + 2^2(h-2) + \\dots + 2^{(h-1)}\\times1\n$$\n\n化简上式需要借助中学的数列知识，先对 $T(h)$ 乘以 $2$ ，得到：\n\n$$\n\\begin{aligned}\nT(h) & = 2^0h + 2^1(h-1) + 2^2(h-2) + \\dots + 2^{h-1}\\times1 \\newline\n2 T(h) & = 2^1h + 2^2(h-1) + 2^3(h-2) + \\dots + 2^{h}\\times1 \\newline\n\\end{aligned}\n$$\n\n使用错位相减法，用下式 $2 T(h)$ 减去上式 $T(h)$ ，可得：\n\n$$\n2T(h) - T(h) = T(h) = -2^0h + 2^1 + 2^2 + \\dots + 2^{h-1} + 2^h\n$$\n\n观察上式，发现 $T(h)$ 是一个等比数列，可直接使用求和公式，得到时间复杂度为：\n\n$$\n\\begin{aligned}\nT(h) & = 2 \\frac{1 - 2^h}{1 - 2} - h \\newline\n& = 2^{h+1} - h - 2 \\newline\n& = O(2^h)\n\\end{aligned}\n$$\n\n进一步地，高度为 $h$ 的完美二叉树的节点数量为 $n = 2^{h+1} - 1$ ，易得复杂度为 $O(2^h) = O(n)$ 。以上推算表明，**输入列表并建堆的时间复杂度为 $O(n)$ ，非常高效**。",
          "questions": [
            "建堆操作的两种实现方法分别是什么？",
            "第一种建堆方法的时间复杂度是多少？为什么？",
            "第二种建堆方法的时间复杂度是多少？为什么？",
            "为什么第二种建堆方法比第一种更高效？",
            "在第二种建堆方法中，哪些节点需要进行堆化操作？为什么？",
            "为什么倒序遍历能够保证当前节点之下的子树已经是合法的子堆？",
            "叶节点需要进行堆化操作吗？为什么？",
            "什么是完美二叉树？为什么在计算第二种建堆方法的时间复杂度时使用了完美二叉树的假设？",
            "如何计算完美二叉树的节点数量和高度？",
            "第二种建堆方法的时间复杂度为什么是O(n)？"
          ]
        }
      ]
    },
    {
      "file_name": "graph_traversal.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 图的遍历\n\n树代表的是“一对多”的关系，而图则具有更高的自由度，可以表示任意的“多对多”关系。因此，我们可以把树看作是图的一种特例。显然，**树的遍历操作也是图的遍历操作的一种特例**。\n\n图和树都需要应用搜索算法来实现遍历操作。图的遍历方式可分为两种：「广度优先遍历 breadth-first traversal」和「深度优先遍历 depth-first traversal」。它们也常被称为「广度优先搜索 breadth-first search」和「深度优先搜索 depth-first search」，简称 BFS 和 DFS 。\n\n## 广度优先遍历\n\n**广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外扩张**。如下图所示，从左上角顶点出发，先遍历该顶点的所有邻接顶点，然后遍历下一个顶点的所有邻接顶点，以此类推，直至所有顶点访问完毕。\n\n![图的广度优先遍历](graph_traversal.assets/graph_bfs.png)\n\n### 算法实现\n\nBFS 通常借助队列来实现。队列具有“先入先出”的性质，这与 BFS 的“由近及远”的思想异曲同工。\n\n1. 将遍历起始顶点 `startVet` 加入队列，并开启循环。\n2. 在循环的每轮迭代中，弹出队首顶点并记录访问，然后将该顶点的所有邻接顶点加入到队列尾部。\n3. 循环步骤 `2.` ，直到所有顶点被访问完成后结束。\n\n为了防止重复遍历顶点，我们需要借助一个哈希表 `visited` 来记录哪些节点已被访问。\n\n```src\n[file]{graph_bfs}-[class]{}-[func]{graph_bfs}\n```\n\n代码相对抽象，建议对照下图来加深理解。\n\n=== \"<1>\"\n    ![图的广度优先遍历步骤](graph_traversal.assets/graph_bfs_step1.png)\n\n=== \"<2>\"\n    ![graph_bfs_step2](graph_traversal.assets/graph_bfs_step2.png)\n\n=== \"<3>\"\n    ![graph_bfs_step3](graph_traversal.assets/graph_bfs_step3.png)\n\n=== \"<4>\"\n    ![graph_bfs_step4](graph_traversal.assets/graph_bfs_step4.png)\n\n=== \"<5>\"\n    ![graph_bfs_step5](graph_traversal.assets/graph_bfs_step5.png)\n\n=== \"<6>\"\n    ![graph_bfs_step6](graph_traversal.assets/graph_bfs_step6.png)\n\n=== \"<7>\"\n    ![graph_bfs_step7](graph_traversal.assets/graph_bfs_step7.png)\n\n=== \"<8>\"\n    ![graph_bfs_step8](graph_traversal.assets/graph_bfs_step8.png)\n\n=== \"<9>\"\n    ![graph_bfs_step9](graph_traversal.assets/graph_bfs_step9.png)\n\n=== \"<10>\"\n    ![graph_bfs_step10](graph_traversal.assets/graph_bfs_step10.png)\n\n=== \"<11>\"\n    ![graph_bfs_step11](graph_traversal.assets/graph_bfs_step11.png)\n\n!!! question \"广度优先遍历的序列是否唯一？\"\n\n    不唯一。广度优先遍历只要求按“由近及远”的顺序遍历，**而多个相同距离的顶点的遍历顺序是允许被任意打乱的**。以上图为例，顶点 $1$、$3$ 的访问顺序可以交换、顶点 $2$、$4$、$6$ 的访问顺序也可以任意交换。\n\n### 复杂度分析\n\n**时间复杂度：** 所有顶点都会入队并出队一次，使用 $O(|V|)$ 时间；在遍历邻接顶点的过程中，由于是无向图，因此所有边都会被访问 $2$ 次，使用 $O(2|E|)$ 时间；总体使用 $O(|V| + |E|)$ 时间。\n\n**空间复杂度：** 列表 `res` ，哈希表 `visited` ，队列 `que` 中的顶点数量最多为 $|V|$ ，使用 $O(|V|)$ 空间。\n\n## 深度优先遍历\n\n**深度优先遍历是一种优先走到底、无路可走再回头的遍历方式**。如下图所示，从左上角顶点出发，访问当前顶点的某个邻接顶点，直到走到尽头时返回，再继续走到尽头并返回，以此类推，直至所有顶点遍历完成。\n\n![图的深度优先遍历](graph_traversal.assets/graph_dfs.png)\n\n### 算法实现\n\n这种“走到尽头再返回”的算法范式通常基于递归来实现。与广度优先遍历类似，在深度优先遍历中我们也需要借助一个哈希表 `visited` 来记录已被访问的顶点，以避免重复访问顶点。\n\n```src\n[file]{graph_dfs}-[class]{}-[func]{graph_dfs}\n```\n\n深度优先遍历的算法流程如下图所示。\n\n- **直虚线代表向下递推**，表示开启了一个新的递归方法来访问新顶点。\n- **曲虚线代表向上回溯**，表示此递归方法已经返回，回溯到了开启此递归方法的位置。\n\n为了加深理解，建议将图示与代码结合起来，在脑中（或者用笔画下来）模拟整个 DFS 过程，包括每个递归方法何时开启、何时返回。\n\n=== \"<1>\"\n    ![图的深度优先遍历步骤](graph_traversal.assets/graph_dfs_step1.png)\n\n=== \"<2>\"\n    ![graph_dfs_step2](graph_traversal.assets/graph_dfs_step2.png)\n\n=== \"<3>\"\n    ![graph_dfs_step3](graph_traversal.assets/graph_dfs_step3.png)\n\n=== \"<4>\"\n    ![graph_dfs_step4](graph_traversal.assets/graph_dfs_step4.png)\n\n=== \"<5>\"\n    ![graph_dfs_step5](graph_traversal.assets/graph_dfs_step5.png)\n\n=== \"<6>\"\n    ![graph_dfs_step6](graph_traversal.assets/graph_dfs_step6.png)\n\n=== \"<7>\"\n    ![graph_dfs_step7](graph_traversal.assets/graph_dfs_step7.png)\n\n=== \"<8>\"\n    ![graph_dfs_step8](graph_traversal.assets/graph_dfs_step8.png)\n\n=== \"<9>\"\n    ![graph_dfs_step9](graph_traversal.assets/graph_dfs_step9.png)\n\n=== \"<10>\"\n    ![graph_dfs_step10](graph_traversal.assets/graph_dfs_step10.png)\n\n=== \"<11>\"\n    ![graph_dfs_step11](graph_traversal.assets/graph_dfs_step11.png)\n\n!!! question \"深度优先遍历的序列是否唯一？\"\n\n    与广度优先遍历类似，深度优先遍历序列的顺序也不是唯一的。给定某顶点，先往哪个方向探索都可以，即邻接顶点的顺序可以任意打乱，都是深度优先遍历。\n    \n    以树的遍历为例，“根 $\\rightarrow$ 左 $\\rightarrow$ 右”、“左 $\\rightarrow$ 根 $\\rightarrow$ 右”、“左 $\\rightarrow$ 右 $\\rightarrow$ 根”分别对应前序、中序、后序遍历，它们展示了三种不同的遍历优先级，然而这三者都属于深度优先遍历。\n\n### 复杂度分析\n\n**时间复杂度：** 所有顶点都会被访问 $1$ 次，使用 $O(|V|)$ 时间；所有边都会被访问 $2$ 次，使用 $O(2|E|)$ 时间；总体使用 $O(|V| + |E|)$ 时间。\n\n**空间复杂度：** 列表 `res` ，哈希表 `visited` 顶点数量最多为 $|V|$ ，递归深度最大为 $|V|$ ，因此使用 $O(|V|)$ 空间。",
          "questions": [
            "广度优先遍历和深度优先遍历的区别是什么？",
            "图的遍历方式有哪些？",
            "为什么在广度优先遍历中需要使用队列？",
            "为什么在深度优先遍历中需要使用递归？",
            "广度优先遍历和深度优先遍历的时间复杂度分别是多少？",
            "广度优先遍历和深度优先遍历的空间复杂度分别是多少？",
            "在广度优先遍历中，如何避免重复访问顶点？",
            "在深度优先遍历中，如何避免重复访问顶点？",
            "广度优先遍历和深度优先遍历的遍历顺序是否唯一？",
            "图的遍历算法中，如何记录已经访问过的顶点？"
          ]
        }
      ]
    },
    {
      "file_name": "binary_search_edge.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 二分查找边界\n\n## 查找左边界\n\n!!! question\n\n    给定一个长度为 $n$ 的有序数组 `nums` ，数组可能包含重复元素。请返回数组中最左一个元素 `target` 的索引。若数组中不包含该元素，则返回 $-1$ 。\n\n回忆二分查找插入点的方法，搜索完成后 $i$ 指向最左一个 `target` ，**因此查找插入点本质上是在查找最左一个 `target` 的索引**。\n\n考虑通过查找插入点的函数实现查找左边界。请注意，数组中可能不包含 `target` ，这种情况可能导致以下两种结果。\n\n- 插入点的索引 $i$ 越界。\n- 元素 `nums[i]` 与 `target` 不相等。\n\n当遇到以上两种情况时，直接返回 $-1$ 即可。\n\n```src\n[file]{binary_search_edge}-[class]{}-[func]{binary_search_left_edge}\n```\n\n## 查找右边界\n\n那么如何查找最右一个 `target` 呢？最直接的方式是修改代码，替换在 `nums[m] == target` 情况下的指针收缩操作。代码在此省略，有兴趣的同学可以自行实现。\n\n下面我们介绍两种更加取巧的方法。\n\n### 复用查找左边界\n\n实际上，我们可以利用查找最左元素的函数来查找最右元素，具体方法为：**将查找最右一个 `target` 转化为查找最左一个 `target + 1`**。\n\n如下图所示，查找完成后，指针 $i$ 指向最左一个 `target + 1`（如果存在），而 $j$ 指向最右一个 `target` ，**因此返回 $j$ 即可**。\n\n![将查找右边界转化为查找左边界](binary_search_edge.assets/binary_search_right_edge_by_left_edge.png)\n\n请注意，返回的插入点是 $i$ ，因此需要将其减 $1$ ，从而获得 $j$ 。\n\n```src\n[file]{binary_search_edge}-[class]{}-[func]{binary_search_right_edge}\n```\n\n### 转化为查找元素\n\n我们知道，当数组不包含 `target` 时，最终 $i$ 和 $j$ 会分别指向首个大于、小于 `target` 的元素。\n\n因此，如下图所示，我们可以构造一个数组中不存在的元素，用于查找左右边界。\n\n- 查找最左一个 `target` ：可以转化为查找 `target - 0.5` ，并返回指针 $i$ 。\n- 查找最右一个 `target` ：可以转化为查找 `target + 0.5` ，并返回指针 $j$ 。\n\n![将查找边界转化为查找元素](binary_search_edge.assets/binary_search_edge_by_element.png)\n\n代码在此省略，值得注意以下两点。\n\n- 给定数组不包含小数，这意味着我们无须关心如何处理相等的情况。\n- 因为该方法引入了小数，所以需要将函数中的变量 `target` 改为浮点数类型。",
          "questions": [
            "如何利用二分查找插入点的方法查找最左一个元素的索引？",
            "在查找最左一个元素的过程中，可能会遇到哪些情况导致返回-1？",
            "如何利用查找最左元素的函数来查找最右元素？",
            "在利用查找最左元素的函数来查找最右元素时，为什么需要将返回的插入点减1？",
            "如何将查找最右一个元素转化为查找最左一个元素？",
            "在转化为查找最左一个元素时，需要查找哪个元素？",
            "如何将查找边界转化为查找元素？",
            "在转化为查找元素时，需要将函数中的哪个变量改为浮点数类型？",
            "为什么给定数组不包含小数时，无须关心如何处理相等的情况？",
            "在利用转化为查找元素的方法查找最左/右一个元素时，可能会遇到哪些情况导致返回-1？"
          ]
        }
      ]
    },
    {
      "file_name": "max_capacity_problem.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 最大容量问题\n\n!!! question\n\n    输入一个数组 $ht$ ，数组中的每个元素代表一个垂直隔板的高度。数组中的任意两个隔板，以及它们之间的空间可以组成一个容器。\n    \n    容器的容量等于高度和宽度的乘积（即面积），其中高度由较短的隔板决定，宽度是两个隔板的数组索引之差。\n    \n    请在数组中选择两个隔板，使得组成的容器的容量最大，返回最大容量。\n\n![最大容量问题的示例数据](max_capacity_problem.assets/max_capacity_example.png)\n\n容器由任意两个隔板围成，**因此本题的状态为两个隔板的索引，记为 $[i, j]$** 。\n\n根据题意，容量等于高度乘以宽度，其中高度由短板决定，宽度是两隔板的索引之差。设容量为 $cap[i, j]$ ，则可得计算公式：\n\n$$\ncap[i, j] = \\min(ht[i], ht[j]) \\times (j - i)\n$$\n\n设数组长度为 $n$ ，两个隔板的组合数量（即状态总数）为 $C_n^2 = \\frac{n(n - 1)}{2}$ 个。最直接地，**我们可以穷举所有状态**，从而求得最大容量，时间复杂度为 $O(n^2)$ 。\n\n### 贪心策略确定\n\n这道题还有更高效率的解法。如下图所示，现选取一个状态 $[i, j]$ ，其满足索引 $i < j$ 且高度 $ht[i] < ht[j]$ ，即 $i$ 为短板、$j$ 为长板。\n\n![初始状态](max_capacity_problem.assets/max_capacity_initial_state.png)\n\n如下图所示，**若此时将长板 $j$ 向短板 $i$ 靠近，则容量一定变小**。\n\n这是因为在移动长板 $j$ 后，宽度 $j-i$ 肯定变小；而高度由短板决定，因此高度只可能不变（ $i$ 仍为短板）或变小（移动后的 $j$ 成为短板）。\n\n![向内移动长板后的状态](max_capacity_problem.assets/max_capacity_moving_long_board.png)\n\n反向思考，**我们只有向内收缩短板 $i$ ，才有可能使容量变大**。因为虽然宽度一定变小，**但高度可能会变大**（移动后的短板 $i$ 可能会变长）。例如在下图中，移动短板后面积变大。\n\n![向内移动短板后的状态](max_capacity_problem.assets/max_capacity_moving_short_board.png)\n\n由此便可推出本题的贪心策略：初始化两指针分裂容器两端，每轮向内收缩短板对应的指针，直至两指针相遇。\n\n下图展示了贪心策略的执行过程。\n\n1. 初始状态下，指针 $i$ 和 $j$ 分列与数组两端。\n2. 计算当前状态的容量 $cap[i, j]$ ，并更新最大容量。\n3. 比较板 $i$ 和 板 $j$ 的高度，并将短板向内移动一格。\n4. 循环执行第 `2.` 和 `3.` 步，直至 $i$ 和 $j$ 相遇时结束。\n\n=== \"<1>\"\n    ![最大容量问题的贪心过程](max_capacity_problem.assets/max_capacity_greedy_step1.png)\n\n=== \"<2>\"\n    ![max_capacity_greedy_step2](max_capacity_problem.assets/max_capacity_greedy_step2.png)\n\n=== \"<3>\"\n    ![max_capacity_greedy_step3](max_capacity_problem.assets/max_capacity_greedy_step3.png)\n\n=== \"<4>\"\n    ![max_capacity_greedy_step4](max_capacity_problem.assets/max_capacity_greedy_step4.png)\n\n=== \"<5>\"\n    ![max_capacity_greedy_step5](max_capacity_problem.assets/max_capacity_greedy_step5.png)\n\n=== \"<6>\"\n    ![max_capacity_greedy_step6](max_capacity_problem.assets/max_capacity_greedy_step6.png)\n\n=== \"<7>\"\n    ![max_capacity_greedy_step7](max_capacity_problem.assets/max_capacity_greedy_step7.png)\n\n=== \"<8>\"\n    ![max_capacity_greedy_step8](max_capacity_problem.assets/max_capacity_greedy_step8.png)\n\n=== \"<9>\"\n    ![max_capacity_greedy_step9](max_capacity_problem.assets/max_capacity_greedy_step9.png)\n\n### 代码实现\n\n代码循环最多 $n$ 轮，**因此时间复杂度为 $O(n)$** 。\n\n变量 $i$、$j$、$res$ 使用常数大小额外空间，**因此空间复杂度为 $O(1)$** 。\n\n```src\n[file]{max_capacity}-[class]{}-[func]{max_capacity}\n```\n\n### 正确性证明\n\n之所以贪心比穷举更快，是因为每轮的贪心选择都会“跳过”一些状态。\n\n比如在状态 $cap[i, j]$ 下，$i$ 为短板、$j$ 为长板。若贪心地将短板 $i$ 向内移动一格，会导致下图所示的状态被“跳过”。**这意味着之后无法验证这些状态的容量大小**。\n\n$$\ncap[i, i+1], cap[i, i+2], \\dots, cap[i, j-2], cap[i, j-1]\n$$\n\n![移动短板导致被跳过的状态](max_capacity_problem.assets/max_capacity_skipped_states.png)\n\n观察发现，**这些被跳过的状态实际上就是将长板 $j$ 向内移动的所有状态**。而在第二步中，我们已经证明内移长板一定会导致容量变小。也就是说，被跳过的状态都不可能是最优解，**跳过它们不会导致错过最优解**。\n\n以上的分析说明，**移动短板的操作是“安全”的**，贪心策略是有效的。",
          "questions": [
            "在最直接的穷举方法中，状态总数为什么是 $C_n^2$ 个？",
            "在贪心策略中，为什么只能向内收缩短板，而不能向内收缩长板？",
            "贪心策略中，为什么每轮只能移动一个指针？",
            "在贪心策略中，为什么每轮移动短板一格就可以保证不错过最优解？",
            "在代码实现中，为什么要先计算一次容量并更新最大容量？",
            "在代码实现中，为什么要在每轮结束后再次计算一次容量并更新最大容量？",
            "在代码实现中，为什么要在最后返回 res 而不是 cap[i, j]？",
            "在正确性证明中，为什么被跳过的状态都不可能是最优解？",
            "在正确性证明中，为什么移动短板的操作是“安全”的？",
            "在正确性证明中，为什么被跳过的状态都是将长板向内移动的状态？"
          ]
        }
      ]
    },
    {
      "file_name": "bubble_sort.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 冒泡排序\n\n「冒泡排序 bubble sort」通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。\n\n如下图所示，冒泡过程可以利用元素交换操作来模拟：从数组最左端开始向右遍历，依次比较相邻元素大小，如果“左元素 > 右元素”就交换它俩。遍历完成后，最大的元素会被移动到数组的最右端。\n\n=== \"<1>\"\n    ![利用元素交换操作模拟冒泡](bubble_sort.assets/bubble_operation_step1.png)\n\n=== \"<2>\"\n    ![bubble_operation_step2](bubble_sort.assets/bubble_operation_step2.png)\n\n=== \"<3>\"\n    ![bubble_operation_step3](bubble_sort.assets/bubble_operation_step3.png)\n\n=== \"<4>\"\n    ![bubble_operation_step4](bubble_sort.assets/bubble_operation_step4.png)\n\n=== \"<5>\"\n    ![bubble_operation_step5](bubble_sort.assets/bubble_operation_step5.png)\n\n=== \"<6>\"\n    ![bubble_operation_step6](bubble_sort.assets/bubble_operation_step6.png)\n\n=== \"<7>\"\n    ![bubble_operation_step7](bubble_sort.assets/bubble_operation_step7.png)\n\n## 算法流程\n\n设数组的长度为 $n$ ，冒泡排序的步骤如下图所示。\n\n1. 首先，对 $n$ 个元素执行“冒泡”，**将数组的最大元素交换至正确位置**，\n2. 接下来，对剩余 $n - 1$ 个元素执行“冒泡”，**将第二大元素交换至正确位置**。\n3. 以此类推，经过 $n - 1$ 轮“冒泡”后，**前 $n - 1$ 大的元素都被交换至正确位置**。\n4. 仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。\n\n![冒泡排序流程](bubble_sort.assets/bubble_sort_overview.png)\n\n```src\n[file]{bubble_sort}-[class]{}-[func]{bubble_sort}\n```\n\n## 效率优化\n\n我们发现，如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 `flag` 来监测这种情况，一旦出现就立即返回。\n\n经过优化，冒泡排序的最差和平均时间复杂度仍为 $O(n^2)$ ；但当输入数组完全有序时，可达到最佳时间复杂度 $O(n)$ 。\n\n```src\n[file]{bubble_sort}-[class]{}-[func]{bubble_sort_with_flag}\n```\n\n## 算法特性\n\n- **时间复杂度为 $O(n^2)$、自适应排序**：各轮“冒泡”遍历的数组长度依次为 $n - 1$、$n - 2$、$\\dots$、$2$、$1$ ，总和为 $(n - 1) n / 2$ 。在引入 `flag` 优化后，最佳时间复杂度可达到 $O(n)$ 。\n- **空间复杂度为 $O(1)$、原地排序**：指针 $i$ 和 $j$ 使用常数大小的额外空间。\n- **稳定排序**：由于在“冒泡”中遇到相等元素不交换。",
          "questions": [
            "冒泡排序的时间复杂度是多少？为什么？",
            "冒泡排序的空间复杂度是多少？为什么？",
            "冒泡排序是一种稳定排序算法吗？为什么？",
            "冒泡排序的算法流程是怎样的？",
            "冒泡排序中如何判断数组已经完成排序？",
            "冒泡排序的优化方法是什么？如何实现？",
            "冒泡排序的最佳时间复杂度是多少？在什么情况下可以达到？",
            "冒泡排序的最差时间复杂度是多少？在什么情况下会达到？",
            "冒泡排序的自适应性是什么意思？",
            "冒泡排序中如何交换相邻元素？"
          ]
        }
      ]
    },
    {
      "file_name": "performance_evaluation.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 算法效率评估\n\n在算法设计中，我们先后追求以下两个层面的目标。\n\n1. **找到问题解法**：算法需要在规定的输入范围内，可靠地求得问题的正确解。\n2. **寻求最优解法**：同一个问题可能存在多种解法，我们希望找到尽可能高效的算法。\n\n也就是说，在能够解决问题的前提下，算法效率已成为衡量算法优劣的主要评价指标，它包括以下两个维度。\n\n- **时间效率**：算法运行速度的快慢。\n- **空间效率**：算法占用内存空间的大小。\n\n简而言之，**我们的目标是设计“既快又省”的数据结构与算法**。而有效地评估算法效率至关重要，因为只有这样我们才能将各种算法进行对比，从而指导算法设计与优化过程。\n\n效率评估方法主要分为两种：实际测试、理论估算。\n\n## 实际测试\n\n假设我们现在有算法 `A` 和算法 `B` ，它们都能解决同一问题，现在需要对比这两个算法的效率。最直接的方法是找一台计算机，运行这两个算法，并监控记录它们的运行时间和内存占用情况。这种评估方式能够反映真实情况，但也存在较大局限性。\n\n一方面，**难以排除测试环境的干扰因素**。硬件配置会影响算法的性能表现。比如在某台计算机中，算法 `A` 的运行时间比算法 `B` 短；但在另一台配置不同的计算机中，我们可能得到相反的测试结果。这意味着我们需要在各种机器上进行测试，统计平均效率，而这是不现实的。\n\n另一方面，**展开完整测试非常耗费资源**。随着输入数据量的变化，算法会表现出不同的效率。例如，在输入数据量较小时，算法 `A` 的运行时间比算法 `B` 更少；而输入数据量较大时，测试结果可能恰恰相反。因此，为了得到有说服力的结论，我们需要测试各种规模的输入数据，而这需要耗费大量的计算资源。\n\n## 理论估算\n\n由于实际测试具有较大的局限性，我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为「渐近复杂度分析 asymptotic complexity analysis」，简称「复杂度分析」。\n\n复杂度分析体现算法运行所需的时间（空间）资源与输入数据大小之间的关系。**它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势**。这个定义有些拗口，我们可以将其分为三个重点来理解。\n\n- “时间和空间资源”分别对应「时间复杂度 time complexity」和「空间复杂度 space complexity」。\n- “随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。\n- “时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。\n\n**复杂度分析克服了实际测试方法的弊端**，体现在以下两个方面。\n\n- 它独立于测试环境，分析结果适用于所有运行平台。\n- 它可以体现不同数据量下的算法效率，尤其是在大数据量下的算法性能。\n\n!!! tip\n\n    如果你仍对复杂度的概念感到困惑，无须担心，我们会在后续章节中详细介绍。\n\n复杂度分析为我们提供了一把评估算法效率的“标尺”，使我们可以衡量执行某个算法所需的时间和空间资源，对比不同算法之间的效率。\n\n复杂度是个数学概念，对于初学者可能比较抽象，学习难度相对较高。从这个角度看，复杂度分析可能不太适合作为最先介绍的内容。然而，当我们讨论某个数据结构或算法的特点时，难以避免要分析其运行速度和空间使用情况。\n\n综上所述，建议你在深入学习数据结构与算法之前，**先对复杂度分析建立初步的了解，以便能够完成简单算法的复杂度分析**。",
          "questions": [
            "什么是算法效率评估？",
            "算法效率评估包括哪两个维度？",
            "什么是时间效率？",
            "什么是空间效率？",
            "什么是复杂度分析？",
            "复杂度分析有哪些优点？",
            "实际测试方法评估算法效率存在哪些局限性？",
            "复杂度分析体现了什么关系？",
            "复杂度分析关注的是什么？",
            "为什么需要对复杂度分析建立初步的了解？"
          ]
        }
      ]
    },
    {
      "file_name": "binary_search_recur.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 分治搜索策略\n\n我们已经学过，搜索算法分为两大类。\n\n- **暴力搜索**：它通过遍历数据结构实现，时间复杂度为 $O(n)$ 。\n- **自适应搜索**：它利用特有的数据组织形式或先验信息，可达到 $O(\\log n)$ 甚至 $O(1)$ 的时间复杂度。\n\n实际上，**时间复杂度为 $O(\\log n)$ 的搜索算法通常都是基于分治策略实现的**，例如二分查找和树。\n\n- 二分查找的每一步都将问题（在数组中搜索目标元素）分解为一个小问题（在数组的一半中搜索目标元素），这个过程一直持续到数组为空或找到目标元素为止。\n- 树是分治关系的代表，在二叉搜索树、AVL 树、堆等数据结构中，各种操作的时间复杂度皆为 $O(\\log n)$ 。\n\n二分查找的分治策略如下所示。\n\n- **问题可以被分解**：二分查找递归地将原问题（在数组中进行查找）分解为子问题（在数组的一半中进行查找），这是通过比较中间元素和目标元素来实现的。\n- **子问题是独立的**：在二分查找中，每轮只处理一个子问题，它不受另外子问题的影响。\n- **子问题的解无须合并**：二分查找旨在查找一个特定元素，因此不需要将子问题的解进行合并。当子问题得到解决时，原问题也会同时得到解决。\n\n分治能够提升搜索效率，本质上是因为暴力搜索每轮只能排除一个选项，**而分治搜索每轮可以排除一半选项**。\n\n### 基于分治实现二分\n\n在之前的章节中，二分查找是基于递推（迭代）实现的。现在我们基于分治（递归）来实现它。\n\n!!! question\n\n    给定一个长度为 $n$ 的有序数组 `nums` ，数组中所有元素都是唯一的，请查找元素 `target` 。\n\n从分治角度，我们将搜索区间 $[i, j]$ 对应的子问题记为 $f(i, j)$ 。\n\n从原问题 $f(0, n-1)$ 为起始点，通过以下步骤进行二分查找。\n\n1. 计算搜索区间 $[i, j]$ 的中点 $m$ ，根据它排除一半搜索区间。\n2. 递归求解规模减小一半的子问题，可能为 $f(i, m-1)$ 或 $f(m+1, j)$ 。\n3. 循环第 `1.` 和 `2.` 步，直至找到 `target` 或区间为空时返回。\n\n下图展示了在数组中二分查找元素 $6$ 的分治过程。\n\n![二分查找的分治过程](binary_search_recur.assets/binary_search_recur.png)\n\n在实现代码中，我们声明一个递归函数 `dfs()` 来求解问题 $f(i, j)$ 。\n\n```src\n[file]{binary_search_recur}-[class]{}-[func]{binary_search}\n```",
          "questions": [
            "二分查找和树都是基于什么策略实现的？",
            "什么是分治策略？它能提升搜索效率的原因是什么？",
            "二分查找的分治策略是怎样的？",
            "为什么分治搜索每轮可以排除一半选项？",
            "在基于分治实现的二分查找中，如何计算搜索区间的中点？",
            "递归函数 `dfs()` 是用来做什么的？",
            "在二分查找中，子问题是否独立？为什么？",
            "二分查找的时间复杂度是多少？",
            "二分查找的实现方式有哪些？",
            "在二分查找中，子问题的解是否需要合并？为什么？"
          ]
        }
      ]
    },
    {
      "file_name": "binary_tree_traversal.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 二叉树遍历\n\n从物理结构的角度来看，树是一种基于链表的数据结构，因此其遍历方式是通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助搜索算法来实现。\n\n二叉树常见的遍历方式包括层序遍历、前序遍历、中序遍历和后序遍历等。\n\n## 层序遍历\n\n如下图所示，「层序遍历 level-order traversal」从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。\n\n层序遍历本质上属于「广度优先遍历 breadth-first traversal」，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。\n\n![二叉树的层序遍历](binary_tree_traversal.assets/binary_tree_bfs.png)\n\n### 代码实现\n\n广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的。\n\n```src\n[file]{binary_tree_bfs}-[class]{}-[func]{level_order}\n```\n\n### 复杂度分析\n\n- **时间复杂度 $O(n)$** ：所有节点被访问一次，使用 $O(n)$ 时间，其中 $n$ 为节点数量。\n- **空间复杂度 $O(n)$** ：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在 $(n + 1) / 2$ 个节点，占用 $O(n)$ 空间。\n\n## 前序、中序、后序遍历\n\n相应地，前序、中序和后序遍历都属于「深度优先遍历 depth-first traversal」，它体现了一种“先走到尽头，再回溯继续”的遍历方式。\n\n下图展示了对二叉树进行深度优先遍历的工作原理。**深度优先遍历就像是绕着整个二叉树的外围“走”一圈**，在每个节点都会遇到三个位置，分别对应前序遍历、中序遍历和后序遍历。\n\n![二叉搜索树的前、中、后序遍历](binary_tree_traversal.assets/binary_tree_dfs.png)\n\n### 代码实现\n\n深度优先搜索通常基于递归实现：\n\n```src\n[file]{binary_tree_dfs}-[class]{}-[func]{post_order}\n```\n\n!!! note\n\n    深度优先搜索也可以基于迭代实现，有兴趣的同学可以自行研究。\n\n下图展示了前序遍历二叉树的递归过程，其可分为“递”和“归”两个逆向的部分。\n\n1. “递”表示开启新方法，程序在此过程中访问下一个节点。\n2. “归”表示函数返回，代表当前节点已经访问完毕。\n\n=== \"<1>\"\n    ![前序遍历的递归过程](binary_tree_traversal.assets/preorder_step1.png)\n\n=== \"<2>\"\n    ![preorder_step2](binary_tree_traversal.assets/preorder_step2.png)\n\n=== \"<3>\"\n    ![preorder_step3](binary_tree_traversal.assets/preorder_step3.png)\n\n=== \"<4>\"\n    ![preorder_step4](binary_tree_traversal.assets/preorder_step4.png)\n\n=== \"<5>\"\n    ![preorder_step5](binary_tree_traversal.assets/preorder_step5.png)\n\n=== \"<6>\"\n    ![preorder_step6](binary_tree_traversal.assets/preorder_step6.png)\n\n=== \"<7>\"\n    ![preorder_step7](binary_tree_traversal.assets/preorder_step7.png)\n\n=== \"<8>\"\n    ![preorder_step8](binary_tree_traversal.assets/preorder_step8.png)\n\n=== \"<9>\"\n    ![preorder_step9](binary_tree_traversal.assets/preorder_step9.png)\n\n=== \"<10>\"\n    ![preorder_step10](binary_tree_traversal.assets/preorder_step10.png)\n\n=== \"<11>\"\n    ![preorder_step11](binary_tree_traversal.assets/preorder_step11.png)\n\n### 复杂度分析\n\n- **时间复杂度 $O(n)$** ：所有节点被访问一次，使用 $O(n)$ 时间。\n- **空间复杂度 $O(n)$** ：在最差情况下，即树退化为链表时，递归深度达到 $n$ ，系统占用 $O(n)$ 栈帧空间。",
          "questions": [
            "二叉树的遍历方式有哪些？",
            "层序遍历和广度优先遍历有什么关系？",
            "广度优先遍历的时间复杂度和空间复杂度分别是多少？",
            "前序、中序和后序遍历属于哪种遍历方式？",
            "深度优先遍历的时间复杂度和空间复杂度分别是多少？",
            "前序遍历的递归过程是怎样的？",
            "为什么深度优先遍历可以基于递归实现？",
            "深度优先遍历可以基于哪些其他方式实现？",
            "二叉树的遍历方式在什么场景下会被使用？",
            "二叉树的遍历方式有哪些优缺点？"
          ]
        }
      ]
    },
    {
      "file_name": "max_product_cutting_problem.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 最大切分乘积问题\n\n!!! question\n\n    给定一个正整数 $n$ ，将其切分为至少两个正整数的和，求切分后所有整数的乘积最大是多少。\n\n![最大切分乘积的问题定义](max_product_cutting_problem.assets/max_product_cutting_definition.png)\n\n假设我们将 $n$ 切分为 $m$ 个整数因子，其中第 $i$ 个因子记为 $n_i$ ，即\n\n$$\nn = \\sum_{i=1}^{m}n_i\n$$\n\n本题目标是求得所有整数因子的最大乘积，即\n\n$$\n\\max(\\prod_{i=1}^{m}n_i)\n$$\n\n我们需要思考的是：切分数量 $m$ 应该多大，每个 $n_i$ 应该是多少？\n\n### 贪心策略确定\n\n根据经验，两个整数的乘积往往比它们的加和更大。假设从 $n$ 中分出一个因子 $2$ ，则它们的乘积为 $2(n-2)$ 。我们将该乘积与 $n$ 作比较：\n\n$$\n\\begin{aligned}\n2(n-2) & \\geq n \\newline\n2n - n - 4 & \\geq 0 \\newline\nn & \\geq 4\n\\end{aligned}\n$$\n\n如下图所示，当 $n \\geq 4$ 时，切分出一个 $2$ 后乘积会变大，**这说明大于等于 $4$ 的整数都应该被切分**。\n\n**贪心策略一**：如果切分方案中包含 $\\geq 4$ 的因子，那么它就应该被继续切分。最终的切分方案只应出现 $1$、$2$、$3$ 这三种因子。\n\n![切分导致乘积变大](max_product_cutting_problem.assets/max_product_cutting_greedy_infer1.png)\n\n接下来思考哪个因子是最优的。在 $1$、$2$、$3$ 这三个因子中，显然 $1$ 是最差的，因为 $1 \\times (n-1) < n$ 恒成立，即切分出 $1$ 反而会导致乘积减小。\n\n如下图所示，当 $n = 6$ 时，有 $3 \\times 3 > 2 \\times 2 \\times 2$ 。**这意味着切分出 $3$ 比切分出 $2$ 更优**。\n\n**贪心策略二**：在切分方案中，最多只应存在两个 $2$ 。因为三个 $2$ 总是可以被替换为两个 $3$ ，从而获得更大乘积。\n\n![最优切分因子](max_product_cutting_problem.assets/max_product_cutting_greedy_infer2.png)\n\n总结以上，可推出以下贪心策略。\n\n1. 输入整数 $n$ ，从其不断地切分出因子 $3$ ，直至余数为 $0$、$1$、$2$ 。\n2. 当余数为 $0$ 时，代表 $n$ 是 $3$ 的倍数，因此不做任何处理。\n3. 当余数为 $2$ 时，不继续划分，保留之。\n4. 当余数为 $1$ 时，由于 $2 \\times 2 > 1 \\times 3$ ，因此应将最后一个 $3$ 替换为 $2$ 。\n\n### 代码实现\n\n如下图所示，我们无须通过循环来切分整数，而可以利用向下整除运算得到 $3$ 的个数 $a$ ，用取模运算得到余数 $b$ ，此时有：\n\n$$\nn = 3 a + b\n$$\n\n请注意，对于 $n \\leq 3$ 的边界情况，必须拆分出一个 $1$ ，乘积为 $1 \\times (n - 1)$ 。\n\n```src\n[file]{max_product_cutting}-[class]{}-[func]{max_product_cutting}\n```\n\n![最大切分乘积的计算方法](max_product_cutting_problem.assets/max_product_cutting_greedy_calculation.png)\n\n**时间复杂度取决于编程语言的幂运算的实现方法**。以 Python 为例，常用的幂计算函数有三种。\n\n- 运算符 `**` 和函数 `pow()` 的时间复杂度均为 $O(\\log⁡ a)$ 。\n- 函数 `math.pow()` 内部调用 C 语言库的 `pow()` 函数，其执行浮点取幂，时间复杂度为 $O(1)$ 。\n\n变量 $a$ 和 $b$ 使用常数大小的额外空间，**因此空间复杂度为 $O(1)$** 。\n\n### 正确性证明\n\n使用反证法，只分析 $n \\geq 3$ 的情况。\n\n1. **所有因子 $\\leq 3$** ：假设最优切分方案中存在 $\\geq 4$ 的因子 $x$ ，那么一定可以将其继续划分为 $2(x-2)$ ，从而获得更大的乘积。这与假设矛盾。\n2. **切分方案不包含 $1$** ：假设最优切分方案中存在一个因子 $1$ ，那么它一定可以合并入另外一个因子中，以获取更大乘积。这与假设矛盾。\n3. **切分方案最多包含两个 $2$** ：假设最优切分方案中包含三个 $2$ ，那么一定可以替换为两个 $3$ ，乘积更大。这与假设矛盾。",
          "questions": [
            "什么是最大切分乘积问题？",
            "如何定义最大切分乘积问题中的切分方案？",
            "最大切分乘积问题中的目标是什么？",
            "为什么大于等于4的整数都应该被切分？",
            "最优的切分因子是什么？",
            "为什么切分方案中最多只应存在两个2？",
            "最大切分乘积问题的贪心策略是什么？",
            "如何通过向下整除和取模运算来切分整数？",
            "最大切分乘积问题的时间复杂度是多少？",
            "如何证明最大切分乘积问题的贪心策略的正确性？"
          ]
        }
      ]
    },
    {
      "file_name": "hash_algorithm.md",
      "question_count": 30,
      "documents": [
        {
          "content": "# 哈希算法\n\n在上两节中，我们了解了哈希表的工作原理和哈希冲突的处理方法。然而无论是开放寻址还是链地址法，**它们只能保证哈希表可以在发生冲突时正常工作，但无法减少哈希冲突的发生**。\n\n如果哈希冲突过于频繁，哈希表的性能则会急剧劣化。如下图所示，对于链地址哈希表，理想情况下键值对平均分布在各个桶中，达到最佳查询效率；最差情况下所有键值对都被存储到同一个桶中，时间复杂度退化至 $O(n)$ 。\n\n![哈希冲突的最佳与最差情况](hash_algorithm.assets/hash_collision_best_worst_condition.png)\n\n**键值对的分布情况由哈希函数决定**。回忆哈希函数的计算步骤，先计算哈希值，再对数组长度取模：\n\n```shell\nindex = hash(key) % capacity\n```\n\n观察以上公式，当哈希表容量 `capacity` 固定时，**哈希算法 `hash()` 决定了输出值**，进而决定了键值对在哈希表中的分布情况。\n\n这意味着，为了减小哈希冲突的发生概率，我们应当将注意力集中在哈希算法 `hash()` 的设计上。\n\n## 哈希算法的目标\n\n为了实现“既快又稳”的哈希表数据结构，哈希算法应包含以下特点。\n\n- **确定性**：对于相同的输入，哈希算法应始终产生相同的输出。这样才能确保哈希表是可靠的。\n- **效率高**：计算哈希值的过程应该足够快。计算开销越小，哈希表的实用性越高。\n- **均匀分布**：哈希算法应使得键值对平均分布在哈希表中。分布越平均，哈希冲突的概率就越低。\n\n实际上，哈希算法除了可以用于实现哈希表，还广泛应用于其他领域中。\n\n- **密码存储**：为了保护用户密码的安全，系统通常不会直接存储用户的明文密码，而是存储密码的哈希值。当用户输入密码时，系统会对输入的密码计算哈希值，然后与存储的哈希值进行比较。如果两者匹配，那么密码就被视为正确。\n- **数据完整性检查**：数据发送方可以计算数据的哈希值并将其一同发送；接收方可以重新计算接收到的数据的哈希值，并与接收到的哈希值进行比较。如果两者匹配，那么数据就被视为完整的。\n\n对于密码学的相关应用，为了防止从哈希值推导出原始密码等逆向工程，哈希算法需要具备更高等级的安全特性。\n\n- **单向性**：无法通过哈希值反推出关于输入数据的任何信息。\n- **抗碰撞性**：应当极其困难找到两个不同的输入，使得它们的哈希值相同。\n- **雪崩效应**：输入的微小变化应当导致输出的显著且不可预测的变化。\n\n请注意，**“均匀分布”与“抗碰撞性”是两个独立的概念**，满足均匀分布不一定满足抗碰撞性。例如，在随机输入 `key` 下，哈希函数 `key % 100` 可以产生均匀分布的输出。然而该哈希算法过于简单，所有后两位相等的 `key` 的输出都相同，因此我们可以很容易地从哈希值反推出可用的 `key` ，从而破解密码。\n\n## 哈希算法的设计\n\n哈希算法的设计是一个需要考虑许多因素的复杂问题。然而对于某些要求不高的场景，我们也能设计一些简单的哈希算法。\n\n- **加法哈希**：对输入的每个字符的 ASCII 码进行相加，将得到的总和作为哈希值。\n- **乘法哈希**：利用了乘法的不相关性，每轮乘以一个常数，将各个字符的 ASCII 码累积到哈希值中。\n- **异或哈希**：将输入数据的每个元素通过异或操作累积到一个哈希值中。\n- **旋转哈希**：将每个字符的 ASCII 码累积到一个哈希值中，每次累积之前都会对哈希值进行旋转操作。\n\n```src\n[file]{simple_hash}-[class]{}-[func]{rot_hash}\n```\n\n观察发现，每种哈希算法的最后一步都是对大质数 $1000000007$ 取模，以确保哈希值在合适的范围内。值得思考的是，为什么要强调对质数取模，或者说对合数取模的弊端是什么？这是一个有趣的问题。\n\n先抛出结论：**当我们使用大质数作为模数时，可以最大化地保证哈希值的均匀分布**。因为质数不会与其他数字存在公约数，可以减少因取模操作而产生的周期性模式，从而避免哈希冲突。\n\n举个例子，假设我们选择合数 $9$ 作为模数，它可以被 $3$ 整除。那么所有可以被 $3$ 整除的 `key` 都会被映射到 $0$、$3$、$6$ 这三个哈希值。\n\n$$\n\\begin{aligned}\n\\text{modulus} & = 9 \\newline\n\\text{key} & = \\{ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, \\dots \\} \\newline\n\\text{hash} & = \\{ 0, 3, 6, 0, 3, 6, 0, 3, 6, 0, 3, 6,\\dots \\}\n\\end{aligned}\n$$\n\n如果输入 `key` 恰好满足这种等差数列的数据分布，那么哈希值就会出现聚堆，从而加重哈希冲突。现在，假设将 `modulus` 替换为质数 $13$ ，由于 `key` 和 `modulus` 之间不存在公约数，输出的哈希值的均匀性会明显提升。\n\n$$\n\\begin{aligned}\n\\text{modulus} & = 13 \\newline\n\\text{key} & = \\{ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, \\dots \\} \\newline\n\\text{hash} & = \\{ 0, 3, 6, 9, 12, 2, 5, 8, 11, 1, 4, 7, \\dots \\}\n\\end{aligned}\n$$\n\n值得说明的是，如果能够保证 `key` 是随机均匀分布的，那么选择质数或者合数作为模数都是可以的，它们都能输出均匀分布的哈希值。而当 `key` 的分布存在某种周期性时，对合数取模更容易出现聚集现象。\n\n总而言之，我们通常选取质数作为模数，并且这个质数最好足够大，以尽可能消除周期性模式，提升哈希算法的稳健性。",
          "questions": [
            "哈希表中的哈希冲突会对性能产生什么影响？",
            "哈希算法的设计应该具备哪些特点？",
            "哈希算法除了用于实现哈希表，还有哪些应用场景？",
            "什么是密码存储中的哈希值？如何保证密码的安全性？",
            "哈希算法的均匀分布和抗碰撞性是什么？它们之间有什么关系？",
            "什么是哈希算法的单向性和雪崩效应？它们的作用是什么？",
            "有哪些简单的哈希算法？它们的实现原理是什么？",
            "为什么在哈希算法中要选择质数作为模数？合数有什么弊端？",
            "如何选择合适的哈希算法和哈希函数？",
            "哈希算法的设计是一个复杂的问题，有哪些因素需要考虑？"
          ]
        },
        {
          "content": "## 常见哈希算法\n\n不难发现，以上介绍的简单哈希算法都比较“脆弱”，远远没有达到哈希算法的设计目标。例如，由于加法和异或满足交换律，因此加法哈希和异或哈希无法区分内容相同但顺序不同的字符串，这可能会加剧哈希冲突，并引起一些安全问题。\n\n在实际中，我们通常会用一些标准哈希算法，例如 MD5、SHA-1、SHA-2、SHA3 等。它们可以将任意长度的输入数据映射到恒定长度的哈希值。\n\n近一个世纪以来，哈希算法处在不断升级与优化的过程中。一部分研究人员努力提升哈希算法的性能，另一部分研究人员和黑客则致力于寻找哈希算法的安全性问题。下表展示了在实际应用中常见的哈希算法。\n\n- MD5 和 SHA-1 已多次被成功攻击，因此它们被各类安全应用弃用。\n- SHA-2 系列中的 SHA-256 是最安全的哈希算法之一，仍未出现成功的攻击案例，因此常被用在各类安全应用与协议中。\n- SHA-3 相较 SHA-2 的实现开销更低、计算效率更高，但目前使用覆盖度不如 SHA-2 系列。\n\n<p align=\"center\"> 表 <id> &nbsp; 常见的哈希算法 </p>\n\n|          | MD5                            | SHA-1            | SHA-2                        | SHA-3                |\n| -------- | ------------------------------ | ---------------- | ---------------------------- | -------------------- |\n| 推出时间 | 1992                           | 1995             | 2002                         | 2008                 |\n| 输出长度 | 128 bits                       | 160 bits         | 256 / 512 bits               | 224/256/384/512 bits |\n| 哈希冲突 | 较多                           | 较多             | 很少                         | 很少                 |\n| 安全等级 | 低，已被成功攻击               | 低，已被成功攻击 | 高                           | 高                   |\n| 应用     | 已被弃用，仍用于数据完整性检查 | 已被弃用         | 加密货币交易验证、数字签名等 | 可用于替代 SHA-2     |",
          "questions": [
            "哈希算法的设计目标是什么？",
            "简单哈希算法为什么比较“脆弱”？",
            "加法哈希和异或哈希有什么缺陷？",
            "标准哈希算法可以将任意长度的输入数据映射到什么长度的哈希值？",
            "常见的哈希算法有哪些？它们的推出时间和输出长度分别是多少？",
            "SHA-2 系列中的哪个算法是最安全的？为什么？",
            "SHA-3 相较 SHA-2 的实现开销和计算效率有何优势？",
            "哪些哈希算法已被成功攻击？它们的安全等级如何？",
            "MD5 和 SHA-1 还有哪些应用场景？",
            "SHA-3 可以替代哪个哈希算法？"
          ]
        },
        {
          "content": "- 元组的哈希值是对其中每一个元素进行哈希，然后将这些哈希值组合起来，得到单一的哈希值。\n- 对象的哈希值基于其内存地址生成。通过重写对象的哈希方法，可实现基于内容生成哈希值。\n\n!!! tip\n\n    请注意，不同编程语言的内置哈希值计算函数的定义和方法不同。\n\n=== \"Python\"\n\n    ```python title=\"built_in_hash.py\"\n    num = 3\n    hash_num = hash(num)\n    # 整数 3 的哈希值为 3\n\n    bol = True\n    hash_bol = hash(bol)\n    # 布尔量 True 的哈希值为 1\n\n    dec = 3.14159\n    hash_dec = hash(dec)\n    # 小数 3.14159 的哈希值为 326484311674566659\n\n    str = \"Hello 算法\"\n    hash_str = hash(str)\n    # 字符串 Hello 算法 的哈希值为 4617003410720528961\n\n    tup = (12836, \"小哈\")\n    hash_tup = hash(tup)\n    # 元组 (12836, '小哈') 的哈希值为 1029005403108185979\n\n    obj = ListNode(0)\n    hash_obj = hash(obj)\n    # 节点对象 <ListNode object at 0x1058fd810> 的哈希值为 274267521\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"built_in_hash.cpp\"\n    int num = 3;\n    size_t hashNum = hash<int>()(num);\n    // 整数 3 的哈希值为 3\n\n    bool bol = true;\n    size_t hashBol = hash<bool>()(bol);\n    // 布尔量 1 的哈希值为 1\n\n    double dec = 3.14159;\n    size_t hashDec = hash<double>()(dec);\n    // 小数 3.14159 的哈希值为 4614256650576692846\n\n    string str = \"Hello 算法\";\n    size_t hashStr = hash<string>()(str);\n    // 字符串 Hello 算法 的哈希值为 15466937326284535026\n\n    // 在 C++ 中，内置 std:hash() 仅提供基本数据类型的哈希值计算\n    // 数组、对象的哈希值计算需要自行实现\n    ```\n\n=== \"Java\"\n\n    ```java title=\"built_in_hash.java\"\n    int num = 3;\n    int hashNum = Integer.hashCode(num);\n    // 整数 3 的哈希值为 3\n\n    boolean bol = true;\n    int hashBol = Boolean.hashCode(bol);\n    // 布尔量 true 的哈希值为 1231\n\n    double dec = 3.14159;\n    int hashDec = Double.hashCode(dec);\n    // 小数 3.14159 的哈希值为 -1340954729\n\n    String str = \"Hello 算法\";\n    int hashStr = str.hashCode();\n    // 字符串 Hello 算法 的哈希值为 -727081396\n\n    Object[] arr = { 12836, \"小哈\" };\n    int hashTup = Arrays.hashCode(arr);\n    // 数组 [12836, 小哈] 的哈希值为 1151158\n\n    ListNode obj = new ListNode(0);\n    int hashObj = obj.hashCode();\n    // 节点对象 utils.ListNode@7dc5e7b4 的哈希值为 2110121908\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"built_in_hash.cs\"\n    int num = 3;\n    int hashNum = num.GetHashCode();\n    // 整数 3 的哈希值为 3;\n\n    bool bol = true;\n    int hashBol = bol.GetHashCode();\n    // 布尔量 true 的哈希值为 1;\n\n    double dec = 3.14159;\n    int hashDec = dec.GetHashCode();\n    // 小数 3.14159 的哈希值为 -1340954729;\n\n    string str = \"Hello 算法\";\n    int hashStr = str.GetHashCode();\n    // 字符串 Hello 算法 的哈希值为 -586107568;\n\n    object[] arr = { 12836, \"小哈\" };\n    int hashTup = arr.GetHashCode();\n    // 数组 [12836, 小哈] 的哈希值为 42931033;\n\n    ListNode obj = new(0);\n    int hashObj = obj.GetHashCode();\n    // 节点对象 0 的哈希值为 39053774;\n    ```\n\n=== \"Go\"\n\n    ```go title=\"built_in_hash.go\"\n    // Go 未提供内置 hash code 函数\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"built_in_hash.swift\"\n    let num = 3\n    let hashNum = num.hashValue\n    // 整数 3 的哈希值为 9047044699613009734\n\n    let bol = true\n    let hashBol = bol.hashValue\n    // 布尔量 true 的哈希值为 -4431640247352757451\n\n    let dec = 3.14159\n    let hashDec = dec.hashValue\n    // 小数 3.14159 的哈希值为 -2465384235396674631\n\n    let str = \"Hello 算法\"\n    let hashStr = str.hashValue\n    // 字符串 Hello 算法 的哈希值为 -7850626797806988787\n\n    let arr = [AnyHashable(12836), AnyHashable(\"小哈\")]\n    let hashTup = arr.hashValue\n    // 数组 [AnyHashable(12836), AnyHashable(\"小哈\")] 的哈希值为 -2308633508154532996\n\n    let obj = ListNode(x: 0)\n    let hashObj = obj.hashValue\n    // 节点对象 utils.ListNode 的哈希值为 -2434780518035996159\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"built_in_hash.js\"\n    // JavaScript 未提供内置 hash code 函数\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"built_in_hash.ts\"\n    // TypeScript 未提供内置 hash code 函数\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"built_in_hash.dart\"\n    int num = 3;\n    int hashNum = num.hashCode;\n    // 整数 3 的哈希值为 34803\n\n    bool bol = true;\n    int hashBol = bol.hashCode;\n    // 布尔值 true 的哈希值为 1231\n\n    double dec = 3.14159;\n    int hashDec = dec.hashCode;\n    // 小数 3.14159 的哈希值为 2570631074981783\n\n    String str = \"Hello 算法\";\n    int hashStr = str.hashCode;\n    // 字符串 Hello 算法 的哈希值为 468167534\n\n    List arr = [12836, \"小哈\"];\n    int hashArr = arr.hashCode;\n    // 数组 [12836, 小哈] 的哈希值为 976512528\n\n    ListNode obj = new ListNode(0);\n    int hashObj = obj.hashCode;\n    // 节点对象 Instance of 'ListNode' 的哈希值为 1033450432\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"built_in_hash.rs\"\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n    \n    let num = 3;\n    let mut num_hasher = DefaultHasher::new();\n    num.hash(&mut num_hasher);\n    let hash_num = num_hasher.finish();\n    // 整数 3 的哈希值为 568126464209439262\n\n    let bol = true;\n    let mut bol_hasher = DefaultHasher::new();\n    bol.hash(&mut bol_hasher);\n    let hash_bol = bol_hasher.finish();\n    // 布尔量 true 的哈希值为 4952851536318644461\n\n    let dec: f32 = 3.14159;\n    let mut dec_hasher = DefaultHasher::new();\n    dec.to_bits().hash(&mut dec_hasher);\n    let hash_dec = dec_hasher.finish();\n    println!(\"小数 {} 的哈希值为 {}\", dec, hash_dec);\n    // 小数 3.14159 的哈希值为 2566941990314602357\n\n    let str = \"Hello 算法\";\n    let mut str_hasher = DefaultHasher::new();\n    str.hash(&mut str_hasher);\n    let hash_str = str_hasher.finish();\n    // 字符串 Hello 算法 的哈希值为 16092673739211250988\n\n    let arr = (&12836, &\"小哈\");\n    let mut tup_hasher = DefaultHasher::new();\n    arr.hash(&mut tup_hasher);\n    let hash_tup = tup_hasher.finish();\n    // 元组 (12836, \"小哈\") 的哈希值为 1885128010422702749\n\n    let node = ListNode::new(42);\n    let mut hasher = DefaultHasher::new();\n    node.borrow().val.hash(&mut hasher);\n    let hash = hasher.finish();\n    // 节点对象 RefCell { value: ListNode { val: 42, next: None } } 的哈希值为15387811073369036852\n    ```\n\n=== \"C\"\n\n    ```c title=\"built_in_hash.c\"\n    // C 未提供内置 hash code 函数\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"built_in_hash.zig\"\n\n    ```\n\n在许多编程语言中，**只有不可变对象才可作为哈希表的 `key`** 。假如我们将列表（动态数组）作为 `key` ，当列表的内容发生变化时，它的哈希值也随之改变，我们就无法在哈希表中查询到原先的 `value` 了。\n\n虽然自定义对象（比如链表节点）的成员变量是可变的，但它是可哈希的。**这是因为对象的哈希值通常是基于内存地址生成的**，即使对象的内容发生了变化，但它的内存地址不变，哈希值仍然是不变的。\n\n细心的你可能发现在不同控制台中运行程序时，输出的哈希值是不同的。**这是因为 Python 解释器在每次启动时，都会为字符串哈希函数加入一个随机的盐（Salt）值**。这种做法可以有效防止 HashDoS 攻击，提升哈希算法的安全性。",
          "questions": [
            "元组的哈希值是如何计算的？",
            "如何重写对象的哈希方法？",
            "不同编程语言的内置哈希值计算函数的定义和方法有何不同？",
            "为什么只有不可变对象才可作为哈希表的 key？",
            "当列表作为 key 时，为什么列表内容的变化会导致哈希值的改变？",
            "对象的哈希值是基于什么生成的？",
            "Python 解释器为什么会为字符串哈希函数加入一个随机的盐值？",
            "哈希值的改变会对哈希表的查询产生什么影响？",
            "如何防止 HashDoS 攻击？",
            "为什么需要提高哈希算法的安全性？"
          ]
        }
      ]
    },
    {
      "file_name": "top_k.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Top-K 问题\n\n!!! question\n\n    给定一个长度为 $n$ 无序数组 `nums` ，请返回数组中前 $k$ 大的元素。\n\n对于该问题，我们先介绍两种思路比较直接的解法，再介绍效率更高的堆解法。\n\n## 方法一：遍历选择\n\n我们可以进行下图所示的 $k$ 轮遍历，分别在每轮中提取第 $1$、$2$、$\\dots$、$k$ 大的元素，时间复杂度为 $O(nk)$ 。\n\n此方法只适用于 $k \\ll n$ 的情况，因为当 $k$ 与 $n$ 比较接近时，其时间复杂度趋向于 $O(n^2)$ ，非常耗时。\n\n![遍历寻找最大的 k 个元素](top_k.assets/top_k_traversal.png)\n\n!!! tip\n\n    当 $k = n$ 时，我们可以得到完整的有序序列，此时等价于“选择排序”算法。\n\n## 方法二：排序\n\n如下图所示，我们可以先对数组 `nums` 进行排序，再返回最右边的 $k$ 个元素，时间复杂度为 $O(n \\log n)$ 。\n\n显然，该方法“超额”完成任务了，因为我们只需要找出最大的 $k$ 个元素即可，而不需要排序其他元素。\n\n![排序寻找最大的 k 个元素](top_k.assets/top_k_sorting.png)\n\n## 方法三：堆\n\n我们可以基于堆更加高效地解决 Top-K 问题，流程如下图所示。\n\n1. 初始化一个小顶堆，其堆顶元素最小。\n2. 先将数组的前 $k$ 个元素依次入堆。\n3. 从第 $k + 1$ 个元素开始，若当前元素大于堆顶元素，则将堆顶元素出堆，并将当前元素入堆。\n4. 遍历完成后，堆中保存的就是最大的 $k$ 个元素。\n\n=== \"<1>\"\n    ![基于堆寻找最大的 k 个元素](top_k.assets/top_k_heap_step1.png)\n\n=== \"<2>\"\n    ![top_k_heap_step2](top_k.assets/top_k_heap_step2.png)\n\n=== \"<3>\"\n    ![top_k_heap_step3](top_k.assets/top_k_heap_step3.png)\n\n=== \"<4>\"\n    ![top_k_heap_step4](top_k.assets/top_k_heap_step4.png)\n\n=== \"<5>\"\n    ![top_k_heap_step5](top_k.assets/top_k_heap_step5.png)\n\n=== \"<6>\"\n    ![top_k_heap_step6](top_k.assets/top_k_heap_step6.png)\n\n=== \"<7>\"\n    ![top_k_heap_step7](top_k.assets/top_k_heap_step7.png)\n\n=== \"<8>\"\n    ![top_k_heap_step8](top_k.assets/top_k_heap_step8.png)\n\n=== \"<9>\"\n    ![top_k_heap_step9](top_k.assets/top_k_heap_step9.png)\n\n总共执行了 $n$ 轮入堆和出堆，堆的最大长度为 $k$ ，因此时间复杂度为 $O(n \\log k)$ 。该方法的效率很高，当 $k$ 较小时，时间复杂度趋向 $O(n)$ ；当 $k$ 较大时，时间复杂度不会超过 $O(n \\log n)$ 。\n\n另外，该方法适用于动态数据流的使用场景。在不断加入数据时，我们可以持续维护堆内的元素，从而实现最大 $k$ 个元素的动态更新。\n\n```src\n[file]{top_k}-[class]{}-[func]{top_k_heap}\n```",
          "questions": [
            "如何使用遍历选择的方法寻找数组中前k大的元素？其时间复杂度是多少？",
            "什么情况下遍历选择的方法不适用？为什么？",
            "如何使用排序的方法寻找数组中前k大的元素？其时间复杂度是多少？",
            "排序的方法是否超额完成了任务？为什么？",
            "如何使用堆的方法寻找数组中前k大的元素？其时间复杂度是多少？",
            "基于堆的方法的流程是什么？",
            "堆的最大长度是多少？为什么？",
            "基于堆的方法的时间复杂度会随着k的变化而变化吗？为什么？",
            "基于堆的方法适用于哪些场景？",
            "如何在动态数据流的使用场景下使用基于堆的方法实现最大k个元素的动态更新？"
          ]
        }
      ]
    },
    {
      "file_name": "subset_sum_problem.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 子集和问题\n\n## 无重复元素的情况\n\n!!! question\n\n    给定一个正整数数组 `nums` 和一个目标正整数 `target` ，请找出所有可能的组合，使得组合中的元素和等于 `target` 。给定数组无重复元素，每个元素可以被选取多次。请以列表形式返回这些组合，列表中不应包含重复组合。\n\n例如，输入集合 $\\{3, 4, 5\\}$ 和目标整数 $9$ ，解为 $\\{3, 3, 3\\}, \\{4, 5\\}$ 。需要注意以下两点。\n\n- 输入集合中的元素可以被无限次重复选取。\n- 子集是不区分元素顺序的，比如 $\\{4, 5\\}$ 和 $\\{5, 4\\}$ 是同一个子集。\n\n### 参考全排列解法\n\n类似于全排列问题，我们可以把子集的生成过程想象成一系列选择的结果，并在选择过程中实时更新“元素和”，当元素和等于 `target` 时，就将子集记录至结果列表。\n\n而与全排列问题不同的是，**本题集合中的元素可以被无限次选取**，因此无须借助 `selected` 布尔列表来记录元素是否已被选择。我们可以对全排列代码进行小幅修改，初步得到解题代码。\n\n```src\n[file]{subset_sum_i_naive}-[class]{}-[func]{subset_sum_i_naive}\n```\n\n向以上代码输入数组 $[3, 4, 5]$ 和目标元素 $9$ ，输出结果为 $[3, 3, 3], [4, 5], [5, 4]$ 。**虽然成功找出了所有和为 $9$ 的子集，但其中存在重复的子集 $[4, 5]$ 和 $[5, 4]$** 。\n\n这是因为搜索过程是区分选择顺序的，然而子集不区分选择顺序。如下图所示，先选 $4$ 后选 $5$ 与先选 $5$ 后选 $4$ 是两个不同的分支，但两者对应同一个子集。\n\n![子集搜索与越界剪枝](subset_sum_problem.assets/subset_sum_i_naive.png)\n\n为了去除重复子集，**一种直接的思路是对结果列表进行去重**。但这个方法效率很低，有两方面原因。\n\n- 当数组元素较多，尤其是当 `target` 较大时，搜索过程会产生大量的重复子集。\n- 比较子集（数组）的异同非常耗时，需要先排序数组，再比较数组中每个元素的异同。\n\n### 重复子集剪枝\n\n**我们考虑在搜索过程中通过剪枝进行去重**。观察下图，重复子集是在以不同顺序选择数组元素时产生的，例如以下情况。\n\n1. 当第一轮和第二轮分别选择 $3$ 和 $4$ 时，会生成包含这两个元素的所有子集，记为 $[3, 4, \\dots]$ 。\n2. 之后，当第一轮选择 $4$ 时，**则第二轮应该跳过 $3$** ，因为该选择产生的子集 $[4, 3, \\dots]$ 和 `1.` 中生成的子集完全重复。\n\n在搜索中，每一层的选择都是从左到右被逐个尝试的，因此越靠右的分支被剪掉的越多。\n\n1. 前两轮选择 $3$ 和 $5$ ，生成子集 $[3, 5, \\dots]$ 。\n2. 前两轮选择 $4$ 和 $5$ ，生成子集 $[4, 5, \\dots]$ 。\n3. 若第一轮选择 $5$ ，**则第二轮应该跳过 $3$ 和 $4$** ，因为子集 $[5, 3, \\dots]$ 和 $[5, 4, \\dots]$ 与第 `1.` 和 `2.` 步中描述的子集完全重复。\n\n![不同选择顺序导致的重复子集](subset_sum_problem.assets/subset_sum_i_pruning.png)\n\n总结来看，给定输入数组 $[x_1, x_2, \\dots, x_n]$ ，设搜索过程中的选择序列为 $[x_{i_1}, x_{i_2}, \\dots, x_{i_m}]$ ，则该选择序列需要满足 $i_1 \\leq i_2 \\leq \\dots \\leq i_m$ ，**不满足该条件的选择序列都会造成重复，应当剪枝**。\n\n### 代码实现\n\n为实现该剪枝，我们初始化变量 `start` ，用于指示遍历起点。**当做出选择 $x_{i}$ 后，设定下一轮从索引 $i$ 开始遍历**。这样做就可以让选择序列满足 $i_1 \\leq i_2 \\leq \\dots \\leq i_m$ ，从而保证子集唯一。\n\n除此之外，我们还对代码进行了以下两项优化。\n\n- 在开启搜索前，先将数组 `nums` 排序。在遍历所有选择时，**当子集和超过 `target` 时直接结束循环**，因为后边的元素更大，其子集和都一定会超过 `target` 。\n- 省去元素和变量 `total` ，**通过在 `target` 上执行减法来统计元素和**，当 `target` 等于 $0$ 时记录解。\n\n```src\n[file]{subset_sum_i}-[class]{}-[func]{subset_sum_i}\n```\n\n如下图所示，为将数组 $[3, 4, 5]$ 和目标元素 $9$ 输入到以上代码后的整体回溯过程。\n\n![子集和 I 回溯过程](subset_sum_problem.assets/subset_sum_i.png)\n\n## 考虑重复元素的情况\n\n!!! question\n\n    给定一个正整数数组 `nums` 和一个目标正整数 `target` ，请找出所有可能的组合，使得组合中的元素和等于 `target` 。**给定数组可能包含重复元素，每个元素只可被选择一次**。请以列表形式返回这些组合，列表中不应包含重复组合。\n\n相比于上题，**本题的输入数组可能包含重复元素**，这引入了新的问题。例如，给定数组 $[4, \\hat{4}, 5]$ 和目标元素 $9$ ，则现有代码的输出结果为 $[4, 5], [\\hat{4}, 5]$ ，出现了重复子集。\n\n**造成这种重复的原因是相等元素在某轮中被多次选择**。在下图中，第一轮共有三个选择，其中两个都为 $4$ ，会产生两个重复的搜索分支，从而输出重复子集；同理，第二轮的两个 $4$ 也会产生重复子集。\n\n![相等元素导致的重复子集](subset_sum_problem.assets/subset_sum_ii_repeat.png)\n\n### 相等元素剪枝\n\n为解决此问题，**我们需要限制相等元素在每一轮中只被选择一次**。实现方式比较巧妙：由于数组是已排序的，因此相等元素都是相邻的。这意味着在某轮选择中，若当前元素与其左边元素相等，则说明它已经被选择过，因此直接跳过当前元素。\n\n与此同时，**本题规定数组中的每个元素只能被选择一次**。幸运的是，我们也可以利用变量 `start` 来满足该约束：当做出选择 $x_{i}$ 后，设定下一轮从索引 $i + 1$ 开始向后遍历。这样即能去除重复子集，也能避免重复选择元素。\n\n### 代码实现\n\n```src\n[file]{subset_sum_ii}-[class]{}-[func]{subset_sum_ii}\n```\n\n下图展示了数组 $[4, 4, 5]$ 和目标元素 $9$ 的回溯过程，共包含四种剪枝操作。请你将图示与代码注释相结合，理解整个搜索过程，以及每种剪枝操作是如何工作的。\n\n![子集和 II 回溯过程](subset_sum_problem.assets/subset_sum_ii.png)",
          "questions": [
            "如何对子集和问题进行回溯求解？",
            "在子集和问题中，如何处理输入数组中的重复元素？",
            "为什么在子集和问题中需要进行重复元素剪枝？",
            "如何实现重复元素剪枝？",
            "在子集和问题中，如何保证生成的子集不包含重复组合？",
            "为什么在子集和问题中需要对选择序列进行限制？",
            "如何通过剪枝操作去除重复子集？",
            "在子集和问题中，如何处理输入数组中的无重复元素情况？",
            "在子集和问题中，如何处理输入数组中的重复元素情况？",
            "如何在子集和问题中对搜索过程进行优化，提高算法效率？"
          ]
        }
      ]
    },
    {
      "file_name": "greedy_algorithm.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 贪心算法\n\n「贪心算法 greedy algorithm」是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期望获得全局最优解。贪心算法简洁且高效，在许多实际问题中都有着广泛的应用。\n\n贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理是不同的。\n\n- 动态规划会根据之前阶段的所有决策来考虑当前决策，并使用过去子问题的解来构建当前子问题的解。\n- 贪心算法不会重新考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决。\n\n我们先通过例题“零钱兑换”了解贪心算法的工作原理。这道题已经在动态规划章节中介绍过，相信你对它并不陌生。\n\n!!! question\n\n    给定 $n$ 种硬币，第 $i$ 种硬币的面值为 $coins[i - 1]$ ，目标金额为 $amt$ ，每种硬币可以重复选取，问能够凑出目标金额的最少硬币个数。如果无法凑出目标金额则返回 $-1$ 。\n\n本题的贪心策略如下图所示。给定目标金额，**我们贪心地选择不大于且最接近它的硬币**，不断循环该步骤，直至凑出目标金额为止。\n\n![零钱兑换的贪心策略](greedy_algorithm.assets/coin_change_greedy_strategy.png)\n\n实现代码如下所示。你可能会不由地发出感叹：So Clean ！贪心算法仅用十行代码就解决了零钱兑换问题。\n\n```src\n[file]{coin_change_greedy}-[class]{}-[func]{coin_change_greedy}\n```\n\n## 贪心优点与局限性\n\n**贪心算法不仅操作直接、实现简单，而且通常效率也很高**。在以上代码中，记硬币最小面值为 $\\min(coins)$ ，则贪心选择最多循环 $amt / \\min(coins)$ 次，时间复杂度为 $O(amt / \\min(coins))$ 。这比动态规划解法的时间复杂度 $O(n \\times amt)$ 提升了一个数量级。\n\n然而，**对于某些硬币面值组合，贪心算法并不能找到最优解**。下图给出了两个示例。\n\n- **正例 $coins = [1, 5, 10, 20, 50, 100]$**：在该硬币组合下，给定任意 $amt$ ，贪心算法都可以找出最优解。\n- **反例 $coins = [1, 20, 50]$**：假设 $amt = 60$ ，贪心算法只能找到 $50 + 1 \\times 10$ 的兑换组合，共计 $11$ 枚硬币，但动态规划可以找到最优解 $20 + 20 + 20$ ，仅需 $3$ 枚硬币。\n- **反例 $coins = [1, 49, 50]$**：假设 $amt = 98$ ，贪心算法只能找到 $50 + 1 \\times 48$ 的兑换组合，共计 $49$ 枚硬币，但动态规划可以找到最优解 $49 + 49$ ，仅需 $2$ 枚硬币。\n\n![贪心无法找出最优解的示例](greedy_algorithm.assets/coin_change_greedy_vs_dp.png)\n\n也就是说，对于零钱兑换问题，贪心算法无法保证找到全局最优解，并且有可能找到非常差的解。它更适合用动态规划解决。\n\n一般情况下，贪心算法适用于以下两类问题。\n\n1. **可以保证找到最优解**：贪心算法在这种情况下往往是最优选择，因为它往往比回溯、动态规划更高效。\n2. **可以找到近似最优解**：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解是非常困难的，能以较高效率找到次优解也是非常不错的。\n\n## 贪心算法特性\n\n那么问题来了，什么样的问题适合用贪心算法求解呢？或者说，贪心算法在什么情况下可以保证找到最优解？\n\n相较于动态规划，贪心算法的使用条件更加苛刻，其主要关注问题的两个性质。\n\n- **贪心选择性质**：只有当局部最优选择始终可以导致全局最优解时，贪心算法才能保证得到最优解。\n- **最优子结构**：原问题的最优解包含子问题的最优解。\n\n最优子结构已经在动态规划章节中介绍过，不再赘述。值得注意的是，一些问题的最优子结构并不明显，但仍然可使用贪心算法解决。\n\n我们主要探究贪心选择性质的判断方法。虽然它的描述看上去比较简单，**但实际上对于许多问题，证明贪心选择性质不是一件易事**。\n\n例如零钱兑换问题，我们虽然能够容易地举出反例，对贪心选择性质进行证伪，但证实的难度较大。如果问：**满足什么条件的硬币组合可以使用贪心算法求解**？我们往往只能凭借直觉或举例子来给出一个模棱两可的答案，而难以给出严谨的数学证明。\n\n!!! quote\n\n    有一篇论文给出了一个 $O(n^3)$ 时间复杂度的算法，用于判断一个硬币组合是否可以使用贪心算法找出任何金额的最优解。\n\n    Pearson, David. A polynomial-time algorithm for the change-making problem. Operations Research Letters 33.3 (2005): 231-234.\n\n## 贪心解题步骤\n\n贪心问题的解决流程大体可分为以下三步。\n\n1. **问题分析**：梳理与理解问题特性，包括状态定义、优化目标和约束条件等。这一步在回溯和动态规划中都有涉及。\n2. **确定贪心策略**：确定如何在每一步中做出贪心选择。这个策略能够在每一步减小问题的规模，并最终能解决整个问题。\n3. **正确性证明**：通常需要证明问题具有贪心选择性质和最优子结构。这个步骤可能需要使用到数学证明，例如归纳法或反证法等。\n\n确定贪心策略是求解问题的核心步骤，但实施起来可能并不容易，主要包含以下原因。\n\n- **不同问题的贪心策略的差异较大**。对于许多问题来说，贪心策略都比较浅显，我们通过一些大概的思考与尝试就能得出。而对于一些复杂问题，贪心策略可能非常隐蔽，这种情况就非常考验个人的解题经验与算法能力了。\n- **某些贪心策略具有较强的迷惑性**。当我们满怀信心设计好贪心策略，写出解题代码并提交运行，很可能发现部分测试样例无法通过。这是因为设计的贪心策略只是“部分正确”的，上文介绍的零钱兑换就是个典型案例。\n\n为了保证正确性，我们应该对贪心策略进行严谨的数学证明，**通常需要用到反证法或数学归纳法**。\n\n然而，正确性证明也很可能不是一件易事。如若没有头绪，我们通常会选择面向测试用例进行 Debug ，一步步修改与验证贪心策略。",
          "questions": [
            "贪心算法和动态规划的工作原理有何不同？",
            "贪心算法的优点和局限性分别是什么？",
            "什么样的问题适合用贪心算法求解？贪心算法在什么情况下可以保证找到最优解？",
            "贪心问题的解决流程包括哪些步骤？其中哪一步骤最为关键？",
            "贪心算法的正确性证明通常需要用到哪些数学方法？",
            "零钱兑换问题中，为什么贪心算法无法保证找到最优解？",
            "贪心算法的时间复杂度如何计算？与动态规划相比，贪心算法的时间复杂度有何优势？",
            "贪心算法的实现代码通常有哪些特点？",
            "贪心算法的贪心选择性质是什么？如何证明一个问题具有贪心选择性质？",
            "在贪心算法中，如何确定贪心策略？确定贪心策略的过程中可能会遇到哪些困难？"
          ]
        },
        {
          "content": "## 贪心典型例题\n\n贪心算法常常应用在满足贪心选择性质和最优子结构的优化问题中，以下列举了一些典型的贪心算法问题。\n\n- **硬币找零问题**：在某些硬币组合下，贪心算法总是可以得到最优解。\n- **区间调度问题**：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解。\n- **分数背包问题**：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解。\n- **股票买卖问题**：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润。\n- **霍夫曼编码**：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最小的两个节点合并，最后得到的霍夫曼树的带权路径长度（即编码长度）最小。\n- **Dijkstra 算法**：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法。",
          "questions": [
            "硬币找零问题中，为什么贪心算法总是可以得到最优解？",
            "区间调度问题中，为什么每次选择结束时间最早的任务可以得到最优解？",
            "分数背包问题中，为什么每次选择性价比最高的物品可以在一些情况下得到最优解？",
            "股票买卖问题中，如何设计贪心策略来获取最大利润？",
            "霍夫曼编码是一种用于无损数据压缩的贪心算法，它的具体实现过程是怎样的？",
            "在霍夫曼编码中，为什么每次选择出现频率最小的两个节点合并可以得到最小的编码长度？",
            "Dijkstra算法是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法，它的具体实现过程是怎样的？",
            "在Dijkstra算法中，如何设计贪心策略来找到最短路径？",
            "贪心算法在什么情况下可以得到最优解？在什么情况下不能得到最优解？",
            "除了上述列举的问题，还有哪些经典的贪心算法问题？它们的具体实现过程是怎样的？"
          ]
        }
      ]
    },
    {
      "file_name": "insertion_sort.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 插入排序\n\n「插入排序 insertion sort」是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。\n\n具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。\n\n下图展示了数组插入元素的操作流程。设基准元素为 `base` ，我们需要将从目标索引到 `base` 之间的所有元素向右移动一位，然后再将 `base` 赋值给目标索引。\n\n![单次插入操作](insertion_sort.assets/insertion_operation.png)\n\n## 算法流程\n\n插入排序的整体流程如下图所示。\n\n1. 初始状态下，数组的第 1 个元素已完成排序。\n2. 选取数组的第 2 个元素作为 `base` ，将其插入到正确位置后，**数组的前 2 个元素已排序**。\n3. 选取第 3 个元素作为 `base` ，将其插入到正确位置后，**数组的前 3 个元素已排序**。\n4. 以此类推，在最后一轮中，选取最后一个元素作为 `base` ，将其插入到正确位置后，**所有元素均已排序**。\n\n![插入排序流程](insertion_sort.assets/insertion_sort_overview.png)\n\n```src\n[file]{insertion_sort}-[class]{}-[func]{insertion_sort}\n```\n\n## 算法特性\n\n- **时间复杂度 $O(n^2)$、自适应排序**：最差情况下，每次插入操作分别需要循环 $n - 1$、$n-2$、$\\dots$、$2$、$1$ 次，求和得到 $(n - 1) n / 2$ ，因此时间复杂度为 $O(n^2)$ 。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度 $O(n)$ 。\n- **空间复杂度 $O(1)$、原地排序**：指针 $i$ 和 $j$ 使用常数大小的额外空间。\n- **稳定排序**：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。\n\n## 插入排序优势\n\n插入排序的时间复杂度为 $O(n^2)$ ，而我们即将学习的快速排序的时间复杂度为 $O(n \\log n)$ 。尽管插入排序的时间复杂度相比快速排序更高，**但在数据量较小的情况下，插入排序通常更快**。\n\n这个结论与线性查找和二分查找的适用情况的结论类似。快速排序这类 $O(n \\log n)$ 的算法属于基于分治的排序算法，往往包含更多单元计算操作。而在数据量较小时，$n^2$ 和 $n \\log n$ 的数值比较接近，复杂度不占主导作用；每轮中的单元操作数量起到决定性因素。\n\n实际上，许多编程语言（例如 Java）的内置排序函数都采用了插入排序，大致思路为：对于长数组，采用基于分治的排序算法，例如快速排序；对于短数组，直接使用插入排序。\n\n虽然冒泡排序、选择排序和插入排序的时间复杂度都为 $O(n^2)$ ，但在实际情况中，**插入排序的使用频率显著高于冒泡排序和选择排序**，主要有以下原因。\n\n- 冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，**冒泡排序的计算开销通常比插入排序更高**。\n- 选择排序在任何情况下的时间复杂度都为 $O(n^2)$ 。**如果给定一组部分有序的数据，插入排序通常比选择排序效率更高**。\n- 选择排序不稳定，无法应用于多级排序。",
          "questions": [
            "插入排序的时间复杂度是多少？为什么？",
            "插入排序的空间复杂度是多少？为什么？",
            "插入排序是一种稳定排序算法吗？为什么？",
            "插入排序的流程是怎样的？可以用什么图示表示？",
            "插入排序的优势是什么？为什么在数据量较小时，插入排序通常更快？",
            "为什么许多编程语言的内置排序函数采用了插入排序？是什么原因导致了插入排序的使用频率显著高于冒泡排序和选择排序？",
            "插入排序在遇到有序数据时会提前终止，这是为什么？",
            "插入排序的基本思想是什么？与手动整理一副牌的过程有什么相似之处？",
            "插入排序的算法流程中，如何将一个元素插入到正确的位置？",
            "插入排序的时间复杂度与快速排序的时间复杂度相比，哪个更优？为什么？"
          ]
        }
      ]
    },
    {
      "file_name": "linked_list.md",
      "question_count": 40,
      "documents": [
        {
          "content": "# 链表\n\n内存空间是所有程序的公共资源，在一个复杂的系统运行环境下，空闲的内存空间可能散落在内存各处。我们知道，存储数组的内存空间必须是连续的，而当数组非常大时，内存可能无法提供如此大的连续空间。此时链表的灵活性优势就体现出来了。\n\n「链表 linked list」是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。\n\n链表的设计使得各个节点可以被分散存储在内存各处，它们的内存地址是无须连续的。\n\n![链表定义与存储方式](linked_list.assets/linkedlist_definition.png)\n\n观察上图，链表的组成单位是「节点 node」对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”。\n\n- 链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。\n- 尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 $\\text{null}$、$\\text{nullptr}$ 和 $\\text{None}$ 。\n- 在 C、C++、Go 和 Rust 等支持指针的语言中，上述的“引用”应被替换为“指针”。\n\n如以下代码所示，链表节点 `ListNode` 除了包含值，还需额外保存一个引用（指针）。因此在相同数据量下，**链表比数组占用更多的内存空间**。\n\n=== \"Python\"\n\n    ```python title=\"\"\n    class ListNode:\n        \"\"\"链表节点类\"\"\"\n        def __init__(self, val: int):\n            self.val: int = val               # 节点值\n            self.next: ListNode | None = None # 指向下一节点的引用\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"\"\n    /* 链表节点结构体 */\n    struct ListNode {\n        int val;         // 节点值\n        ListNode *next;  // 指向下一节点的指针\n        ListNode(int x) : val(x), next(nullptr) {}  // 构造函数\n    };\n    ```\n\n=== \"Java\"\n\n    ```java title=\"\"\n    /* 链表节点类 */\n    class ListNode {\n        int val;        // 节点值\n        ListNode next;  // 指向下一节点的引用\n        ListNode(int x) { val = x; }  // 构造函数\n    }\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"\"\n    /* 链表节点类 */\n    class ListNode {\n        int val;         // 节点值\n        ListNode next;   // 指向下一节点的引用\n        ListNode(int x) => val = x;  //构造函数\n    }\n    ```\n\n=== \"Go\"\n\n    ```go title=\"\"\n    /* 链表节点结构体 */\n    type ListNode struct {\n        Val  int       // 节点值\n        Next *ListNode // 指向下一节点的指针\n    }\n\n    // NewListNode 构造函数，创建一个新的链表\n    func NewListNode(val int) *ListNode {\n        return &ListNode{\n            Val:  val,\n            Next: nil,\n        }\n    }\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"\"\n    /* 链表节点类 */\n    class ListNode {\n        var val: Int // 节点值\n        var next: ListNode? // 指向下一节点的引用\n\n        init(x: Int) { // 构造函数\n            val = x\n        }\n    }\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"\"\n    /* 链表节点类 */\n    class ListNode {\n        val;\n        next;\n        constructor(val, next) {\n            this.val = (val === undefined ? 0 : val);       // 节点值\n            this.next = (next === undefined ? null : next); // 指向下一节点的引用\n        }\n    }\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"\"\n    /* 链表节点类 */\n    class ListNode {\n        val: number;\n        next: ListNode | null;\n        constructor(val?: number, next?: ListNode | null) {\n            this.val = val === undefined ? 0 : val;        // 节点值\n            this.next = next === undefined ? null : next;  // 指向下一节点的引用\n        }\n    }\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"\"\n    /* 链表节点类 */\n    class ListNode {\n      int val; // 节点值\n      ListNode? next; // 指向下一节点的引用\n      ListNode(this.val, [this.next]); // 构造函数\n    }\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"\"\n    use std::rc::Rc;\n    use std::cell::RefCell;\n    /* 链表节点类 */\n    #[derive(Debug)]\n    struct ListNode {\n        val: i32, // 节点值\n        next: Option<Rc<RefCell<ListNode>>>, // 指向下一节点的指针\n    }\n    ```\n\n=== \"C\"\n\n    ```c title=\"\"\n    /* 链表节点结构体 */\n    typedef struct ListNode {\n        int val;               // 节点值\n        struct ListNode *next; // 指向下一节点的指针\n    } ListNode;\n\n    /* 构造函数 */\n    ListNode *newListNode(int val) {\n        ListNode *node, *next;\n        node = (ListNode *) malloc(sizeof(ListNode));\n        node->val = val;\n        node->next = NULL;\n        return node;\n    }\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"\"\n    // 链表节点类\n    pub fn ListNode(comptime T: type) type {\n        return struct {\n            const Self = @This();\n\n            val: T = 0, // 节点值\n            next: ?*Self = null, // 指向下一节点的指针\n\n            // 构造函数\n            pub fn init(self: *Self, x: i32) void {\n                self.val = x;\n                self.next = null;\n            }\n        };\n    }\n    ```\n\n## 链表常用操作",
          "questions": [
            "链表中每个节点包含哪些信息？",
            "链表中的头节点和尾节点分别是什么？",
            "链表中的空节点在不同编程语言中的表示方式是什么？",
            "链表和数组在内存空间上有什么区别？",
            "链表的灵活性体现在哪些方面？",
            "链表的节点引用在支持指针的语言中应该被替换为什么？",
            "链表节点的构造函数中需要传入哪些参数？",
            "链表的常用操作有哪些？",
            "如何在链表中插入一个节点？",
            "如何在链表中删除一个节点？"
          ]
        },
        {
          "content": "### 初始化链表\n\n建立链表分为两步，第一步是初始化各个节点对象，第二步是构建引用指向关系。初始化完成后，我们就可以从链表的头节点出发，通过引用指向 `next` 依次访问所有节点。\n\n=== \"Python\"\n\n    ```python title=\"linked_list.py\"\n    # 初始化链表 1 -> 3 -> 2 -> 5 -> 4\n    # 初始化各个节点\n    n0 = ListNode(1)\n    n1 = ListNode(3)\n    n2 = ListNode(2)\n    n3 = ListNode(5)\n    n4 = ListNode(4)\n    # 构建引用指向\n    n0.next = n1\n    n1.next = n2\n    n2.next = n3\n    n3.next = n4\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"linked_list.cpp\"\n    /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */\n    // 初始化各个节点\n    ListNode* n0 = new ListNode(1);\n    ListNode* n1 = new ListNode(3);\n    ListNode* n2 = new ListNode(2);\n    ListNode* n3 = new ListNode(5);\n    ListNode* n4 = new ListNode(4);\n    // 构建引用指向\n    n0->next = n1;\n    n1->next = n2;\n    n2->next = n3;\n    n3->next = n4;\n    ```\n\n=== \"Java\"\n\n    ```java title=\"linked_list.java\"\n    /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */\n    // 初始化各个节点\n    ListNode n0 = new ListNode(1);\n    ListNode n1 = new ListNode(3);\n    ListNode n2 = new ListNode(2);\n    ListNode n3 = new ListNode(5);\n    ListNode n4 = new ListNode(4);\n    // 构建引用指向\n    n0.next = n1;\n    n1.next = n2;\n    n2.next = n3;\n    n3.next = n4;\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"linked_list.cs\"\n    /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */\n    // 初始化各个节点\n    ListNode n0 = new(1);\n    ListNode n1 = new(3);\n    ListNode n2 = new(2);\n    ListNode n3 = new(5);\n    ListNode n4 = new(4);\n    // 构建引用指向\n    n0.next = n1;\n    n1.next = n2;\n    n2.next = n3;\n    n3.next = n4;\n    ```\n\n=== \"Go\"\n\n    ```go title=\"linked_list.go\"\n    /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */\n    // 初始化各个节点\n    n0 := NewListNode(1)\n    n1 := NewListNode(3)\n    n2 := NewListNode(2)\n    n3 := NewListNode(5)\n    n4 := NewListNode(4)\n    // 构建引用指向\n    n0.Next = n1\n    n1.Next = n2\n    n2.Next = n3\n    n3.Next = n4\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"linked_list.swift\"\n    /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */\n    // 初始化各个节点\n    let n0 = ListNode(x: 1)\n    let n1 = ListNode(x: 3)\n    let n2 = ListNode(x: 2)\n    let n3 = ListNode(x: 5)\n    let n4 = ListNode(x: 4)\n    // 构建引用指向\n    n0.next = n1\n    n1.next = n2\n    n2.next = n3\n    n3.next = n4\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"linked_list.js\"\n    /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */\n    // 初始化各个节点\n    const n0 = new ListNode(1);\n    const n1 = new ListNode(3);\n    const n2 = new ListNode(2);\n    const n3 = new ListNode(5);\n    const n4 = new ListNode(4);\n    // 构建引用指向\n    n0.next = n1;\n    n1.next = n2;\n    n2.next = n3;\n    n3.next = n4;\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"linked_list.ts\"\n    /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */\n    // 初始化各个节点\n    const n0 = new ListNode(1);\n    const n1 = new ListNode(3);\n    const n2 = new ListNode(2);\n    const n3 = new ListNode(5);\n    const n4 = new ListNode(4);\n    // 构建引用指向\n    n0.next = n1;\n    n1.next = n2;\n    n2.next = n3;\n    n3.next = n4;\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"linked_list.dart\"\n    /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */\\\n    // 初始化各个节点\n    ListNode n0 = ListNode(1);\n    ListNode n1 = ListNode(3);\n    ListNode n2 = ListNode(2);\n    ListNode n3 = ListNode(5);\n    ListNode n4 = ListNode(4);\n    // 构建引用指向\n    n0.next = n1;\n    n1.next = n2;\n    n2.next = n3;\n    n3.next = n4;\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"linked_list.rs\"\n    /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */\n    // 初始化各个节点\n    let n0 = Rc::new(RefCell::new(ListNode { val: 1, next: None }));\n    let n1 = Rc::new(RefCell::new(ListNode { val: 3, next: None }));\n    let n2 = Rc::new(RefCell::new(ListNode { val: 2, next: None }));\n    let n3 = Rc::new(RefCell::new(ListNode { val: 5, next: None }));\n    let n4 = Rc::new(RefCell::new(ListNode { val: 4, next: None }));\n\n    // 构建引用指向\n    n0.borrow_mut().next = Some(n1.clone());\n    n1.borrow_mut().next = Some(n2.clone());\n    n2.borrow_mut().next = Some(n3.clone());\n    n3.borrow_mut().next = Some(n4.clone());\n    ```\n\n=== \"C\"\n\n    ```c title=\"linked_list.c\"\n    /* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */\n    // 初始化各个节点\n    ListNode* n0 = newListNode(1);\n    ListNode* n1 = newListNode(3);\n    ListNode* n2 = newListNode(2);\n    ListNode* n3 = newListNode(5);\n    ListNode* n4 = newListNode(4);\n    // 构建引用指向\n    n0->next = n1;\n    n1->next = n2;\n    n2->next = n3;\n    n3->next = n4;\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"linked_list.zig\"\n    // 初始化链表\n    // 初始化各个节点\n    var n0 = inc.ListNode(i32){.val = 1};\n    var n1 = inc.ListNode(i32){.val = 3};\n    var n2 = inc.ListNode(i32){.val = 2};\n    var n3 = inc.ListNode(i32){.val = 5};\n    var n4 = inc.ListNode(i32){.val = 4};\n    // 构建引用指向\n    n0.next = &n1;\n    n1.next = &n2;\n    n2.next = &n3;\n    n3.next = &n4;\n    ```\n\n数组整体是一个变量，比如数组 `nums` 包含元素 `nums[0]` 和 `nums[1]` 等，而链表是由多个独立的节点对象组成的。**我们通常将头节点当作链表的代称**，比如以上代码中的链表可被记做链表 `n0` 。\n\n### 插入节点\n\n在链表中插入节点非常容易。如下图所示，假设我们想在相邻的两个节点 `n0` 和 `n1` 之间插入一个新节点 `P` ，**则只需要改变两个节点引用（指针）即可**，时间复杂度为 $O(1)$ 。\n\n相比之下，在数组中插入元素的时间复杂度为 $O(n)$ ，在大数据量下的效率较低。\n\n![链表插入节点示例](linked_list.assets/linkedlist_insert_node.png)\n\n```src\n[file]{linked_list}-[class]{}-[func]{insert}\n```\n\n### 删除节点\n\n如下图所示，在链表中删除节点也非常方便，**只需改变一个节点的引用（指针）即可**。\n\n请注意，尽管在删除操作完成后节点 `P` 仍然指向 `n1` ，但实际上遍历此链表已经无法访问到 `P` ，这意味着 `P` 已经不再属于该链表了。\n\n![链表删除节点](linked_list.assets/linkedlist_remove_node.png)\n\n```src\n[file]{linked_list}-[class]{}-[func]{remove}\n```\n\n### 访问节点\n\n**在链表访问节点的效率较低**。如上节所述，我们可以在 $O(1)$ 时间下访问数组中的任意元素。链表则不然，程序需要从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第 $i$ 个节点需要循环 $i - 1$ 轮，时间复杂度为 $O(n)$ 。\n\n```src\n[file]{linked_list}-[class]{}-[func]{access}\n```\n\n### 查找节点\n\n遍历链表，查找链表内值为 `target` 的节点，输出节点在链表中的索引。此过程也属于线性查找。\n\n```src\n[file]{linked_list}-[class]{}-[func]{find}\n```",
          "questions": [
            "如何初始化链表？",
            "链表的节点对象是独立的还是整体的？",
            "在链表中插入节点的时间复杂度是多少？",
            "在链表中删除节点的时间复杂度是多少？",
            "链表访问节点的效率如何？",
            "查找链表中值为target的节点的时间复杂度是多少？",
            "数组和链表在插入元素时的时间复杂度有何区别？",
            "如何访问链表中的第i个节点？",
            "链表的头节点是什么？",
            "链表中的节点对象有哪些属性？"
          ]
        },
        {
          "content": "## 数组 VS 链表\n\n下表总结对比了数组和链表的各项特点与操作效率。由于它们采用两种相反的存储策略，因此各种性质和操作效率也呈现对立的特点。\n\n<p align=\"center\"> 表 <id> &nbsp; 数组与链表的效率对比 </p>\n\n|            | 数组                     | 链表         |\n| ---------- | ------------------------ | ------------ |\n| 存储方式   | 连续内存空间             | 分散内存空间 |\n| 缓存局部性 | 友好                     | 不友好       |\n| 容量扩展   | 长度不可变               | 可灵活扩展   |\n| 内存效率   | 占用内存少、浪费部分空间 | 占用内存多   |\n| 访问元素   | $O(1)$                   | $O(n)$       |\n| 添加元素   | $O(n)$                   | $O(1)$       |\n| 删除元素   | $O(n)$                   | $O(1)$       |\n\n## 常见链表类型\n\n如下图所示，常见的链表类型包括三种。\n\n- **单向链表**：即上述介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 $\\text{None}$ 。\n- **环形链表**：如果我们令单向链表的尾节点指向头节点（即首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。\n- **双向链表**：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。\n\n=== \"Python\"\n\n    ```python title=\"\"\n    class ListNode:\n        \"\"\"双向链表节点类\"\"\"\n        def __init__(self, val: int):\n            self.val: int = val                # 节点值\n            self.next: ListNode | None = None  # 指向后继节点的引用\n            self.prev: ListNode | None = None  # 指向前驱节点的引用\n    ```\n\n=== \"C++\"\n\n    ```cpp title=\"\"\n    /* 双向链表节点结构体 */\n    struct ListNode {\n        int val;         // 节点值\n        ListNode *next;  // 指向后继节点的指针\n        ListNode *prev;  // 指向前驱节点的指针\n        ListNode(int x) : val(x), next(nullptr), prev(nullptr) {}  // 构造函数\n    };\n    ```\n\n=== \"Java\"\n\n    ```java title=\"\"\n    /* 双向链表节点类 */\n    class ListNode {\n        int val;        // 节点值\n        ListNode next;  // 指向后继节点的引用\n        ListNode prev;  // 指向前驱节点的引用\n        ListNode(int x) { val = x; }  // 构造函数\n    }\n    ```\n\n=== \"C#\"\n\n    ```csharp title=\"\"\n    /* 双向链表节点类 */\n    class ListNode {\n        int val;        // 节点值\n        ListNode next;  // 指向后继节点的引用\n        ListNode prev;  // 指向前驱节点的引用\n        ListNode(int x) => val = x;  // 构造函数\n    }\n    ```\n\n=== \"Go\"\n\n    ```go title=\"\"\n    /* 双向链表节点结构体 */\n    type DoublyListNode struct {\n        Val  int             // 节点值\n        Next *DoublyListNode // 指向后继节点的指针\n        Prev *DoublyListNode // 指向前驱节点的指针\n    }\n\n    // NewDoublyListNode 初始化\n    func NewDoublyListNode(val int) *DoublyListNode {\n        return &DoublyListNode{\n            Val:  val,\n            Next: nil,\n            Prev: nil,\n        }\n    }\n    ```\n\n=== \"Swift\"\n\n    ```swift title=\"\"\n    /* 双向链表节点类 */\n    class ListNode {\n        var val: Int // 节点值\n        var next: ListNode? // 指向后继节点的引用\n        var prev: ListNode? // 指向前驱节点的引用\n\n        init(x: Int) { // 构造函数\n            val = x\n        }\n    }\n    ```\n\n=== \"JS\"\n\n    ```javascript title=\"\"\n    /* 双向链表节点类 */\n    class ListNode {\n        val;\n        next;\n        prev;\n        constructor(val, next, prev) {\n            this.val = val  ===  undefined ? 0 : val;        // 节点值\n            this.next = next  ===  undefined ? null : next;  // 指向后继节点的引用\n            this.prev = prev  ===  undefined ? null : prev;  // 指向前驱节点的引用\n        }\n    }\n    ```\n\n=== \"TS\"\n\n    ```typescript title=\"\"\n    /* 双向链表节点类 */\n    class ListNode {\n        val: number;\n        next: ListNode | null;\n        prev: ListNode | null;\n        constructor(val?: number, next?: ListNode | null, prev?: ListNode | null) {\n            this.val = val  ===  undefined ? 0 : val;        // 节点值\n            this.next = next  ===  undefined ? null : next;  // 指向后继节点的引用\n            this.prev = prev  ===  undefined ? null : prev;  // 指向前驱节点的引用\n        }\n    }\n    ```\n\n=== \"Dart\"\n\n    ```dart title=\"\"\n    /* 双向链表节点类 */\n    class ListNode {\n        int val;        // 节点值\n        ListNode next;  // 指向后继节点的引用\n        ListNode prev;  // 指向前驱节点的引用\n        ListNode(this.val, [this.next, this.prev]);  // 构造函数\n    }\n    ```\n\n=== \"Rust\"\n\n    ```rust title=\"\"\n    use std::rc::Rc;\n    use std::cell::RefCell;\n\n    /* 双向链表节点类型 */\n    #[derive(Debug)]\n    struct ListNode {\n        val: i32, // 节点值\n        next: Option<Rc<RefCell<ListNode>>>, // 指向后继节点的指针\n        prev: Option<Rc<RefCell<ListNode>>>, // 指向前驱节点的指针\n    }\n\n    /* 构造函数 */\n    impl ListNode {\n        fn new(val: i32) -> Self {\n            ListNode {\n                val,\n                next: None,\n                prev: None,\n            }\n        }\n    }\n    ```\n\n=== \"C\"\n\n    ```c title=\"\"\n    /* 双向链表节点结构体 */\n    typedef struct ListNode {\n        int val;               // 节点值\n        struct ListNode *next; // 指向后继节点的指针\n        struct ListNode *prev; // 指向前驱节点的指针\n    } ListNode;\n\n    /* 构造函数 */\n    ListNode *newListNode(int val) {\n        ListNode *node, *next;\n        node = (ListNode *) malloc(sizeof(ListNode));\n        node->val = val;\n        node->next = NULL;\n        node->prev = NULL;\n        return node;\n    }\n    ```\n\n=== \"Zig\"\n\n    ```zig title=\"\"\n    // 双向链表节点类\n    pub fn ListNode(comptime T: type) type {\n        return struct {\n            const Self = @This();\n\n            val: T = 0, // 节点值\n            next: ?*Self = null, // 指向后继节点的指针\n            prev: ?*Self = null, // 指向前驱节点的指针\n\n            // 构造函数\n            pub fn init(self: *Self, x: i32) void {\n                self.val = x;\n                self.next = null;\n                self.prev = null;\n            }\n        };\n    }\n    ```\n\n![常见链表种类](linked_list.assets/linkedlist_common_types.png)",
          "questions": [
            "数组和链表的存储方式有什么区别？",
            "数组和链表的缓存局部性有什么区别？",
            "数组和链表的容量扩展方式有什么区别？",
            "数组和链表的内存效率有什么区别？",
            "数组和链表访问元素的时间复杂度分别是多少？",
            "数组和链表添加元素的时间复杂度分别是多少？",
            "数组和链表删除元素的时间复杂度分别是多少？",
            "什么是单向链表？它的节点包含哪些数据？",
            "什么是环形链表？它的节点包含哪些数据？",
            "什么是双向链表？它的节点包含哪些数据？"
          ]
        },
        {
          "content": "## 链表典型应用\n\n单向链表通常用于实现栈、队列、哈希表和图等数据结构。\n\n- **栈与队列**：当插入和删除操作都在链表的一端进行时，它表现出先进后出的的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。\n- **哈希表**：链地址法是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。\n- **图**：邻接表是表示图的一种常用方式，在其中，图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。\n\n双向链表常被用于需要快速查找前一个和下一个元素的场景。\n\n- **高级数据结构**：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。\n- **浏览器历史**：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。\n- **LRU 算法**：在缓存淘汰算法（LRU）中，我们需要快速找到最近最少使用的数据，以及支持快速地添加和删除节点。这时候使用双向链表就非常合适。\n\n循环链表常被用于需要周期性操作的场景，比如操作系统的资源调度。\n\n- **时间片轮转调度算法**：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环的操作就可以通过循环链表来实现。\n- **数据缓冲区**：在某些数据缓冲区的实现中，也可能会使用到循环链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个循环链表，以便实现无缝播放。",
          "questions": [
            "单向链表通常用于哪些数据结构的实现？",
            "链地址法是解决哈希冲突的哪种方案？",
            "双向链表常被用于哪些需要快速查找前一个和下一个元素的场景？",
            "在红黑树、B 树中，为什么需要访问节点的父节点？",
            "在网页浏览器中，为什么需要使用双向链表？",
            "LRU 算法中，为什么需要快速找到最近最少使用的数据？",
            "循环链表常被用于哪些需要周期性操作的场景？",
            "时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环，如何实现这种循环的操作？",
            "在某些数据缓冲区的实现中，为什么会使用到循环链表？",
            "邻接表是表示图的一种常用方式，它与链表相关联，链表中的每个元素都代表什么？"
          ]
        }
      ]
    },
    {
      "file_name": "graph.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 图\n\n「图 graph」是一种非线性数据结构，由「顶点 vertex」和「边 edge」组成。我们可以将图 $G$ 抽象地表示为一组顶点 $V$ 和一组边 $E$ 的集合。以下示例展示了一个包含 5 个顶点和 7 条边的图。\n\n$$\n\\begin{aligned}\nV & = \\{ 1, 2, 3, 4, 5 \\} \\newline\nE & = \\{ (1,2), (1,3), (1,5), (2,3), (2,4), (2,5), (4,5) \\} \\newline\nG & = \\{ V, E \\} \\newline\n\\end{aligned}\n$$\n\n如果将顶点看作节点，将边看作连接各个节点的引用（指针），我们就可以将图看作是一种从链表拓展而来的数据结构。如下图所示，**相较于线性关系（链表）和分治关系（树），网络关系（图）的自由度更高**，从而更为复杂。\n\n![链表、树、图之间的关系](graph.assets/linkedlist_tree_graph.png)\n\n## 图常见类型与术语\n\n根据边是否具有方向，可分为下图所示的「无向图 undirected graph」和「有向图 directed graph」。\n\n- 在无向图中，边表示两顶点之间的“双向”连接关系，例如微信或 QQ 中的“好友关系”。\n- 在有向图中，边具有方向性，即 $A \\rightarrow B$ 和 $A \\leftarrow B$ 两个方向的边是相互独立的，例如微博或抖音上的“关注”与“被关注”关系。\n\n![有向图与无向图](graph.assets/directed_graph.png)\n\n根据所有顶点是否连通，可分为下图所示的「连通图 connected graph」和「非连通图 disconnected graph」。\n\n- 对于连通图，从某个顶点出发，可以到达其余任意顶点。\n- 对于非连通图，从某个顶点出发，至少有一个顶点无法到达。\n\n![连通图与非连通图](graph.assets/connected_graph.png)\n\n我们还可以为边添加“权重”变量，从而得到下图所示的「有权图 weighted graph」。例如在王者荣耀等手游中，系统会根据共同游戏时间来计算玩家之间的“亲密度”，这种亲密度网络就可以用有权图来表示。\n\n![有权图与无权图](graph.assets/weighted_graph.png)\n\n图数据结构包含以下常用术语。\n\n- 「邻接 adjacency」：当两顶点之间存在边相连时，称这两顶点“邻接”。在上图中，顶点 1 的邻接顶点为顶点 2、3、5。\n- 「路径 path」：从顶点 A 到顶点 B 经过的边构成的序列被称为从 A 到 B 的“路径”。在上图中，边序列 1-5-2-4 是顶点 1 到顶点 4 的一条路径。\n- 「度 degree」：一个顶点拥有的边数。对于有向图，「入度 In-Degree」表示有多少条边指向该顶点，「出度 Out-Degree」表示有多少条边从该顶点指出。\n\n## 图的表示\n\n图的常用表示方式包括“邻接矩阵”和“邻接表”。以下使用无向图进行举例。\n\n### 邻接矩阵\n\n设图的顶点数量为 $n$ ，「邻接矩阵 adjacency matrix」使用一个 $n \\times n$ 大小的矩阵来表示图，每一行（列）代表一个顶点，矩阵元素代表边，用 $1$ 或 $0$ 表示两个顶点之间是否存在边。\n\n如下图所示，设邻接矩阵为 $M$、顶点列表为 $V$ ，那么矩阵元素 $M[i, j] = 1$ 表示顶点 $V[i]$ 到顶点 $V[j]$ 之间存在边，反之 $M[i, j] = 0$ 表示两顶点之间无边。\n\n![图的邻接矩阵表示](graph.assets/adjacency_matrix.png)\n\n邻接矩阵具有以下特性。\n\n- 顶点不能与自身相连，因此邻接矩阵主对角线元素没有意义。\n- 对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称。\n- 将邻接矩阵的元素从 $1$ 和 $0$ 替换为权重，则可表示有权图。\n\n使用邻接矩阵表示图时，我们可以直接访问矩阵元素以获取边，因此增删查操作的效率很高，时间复杂度均为 $O(1)$ 。然而，矩阵的空间复杂度为 $O(n^2)$ ，内存占用较多。\n\n### 邻接表\n\n「邻接表 adjacency list」使用 $n$ 个链表来表示图，链表节点表示顶点。第 $i$ 条链表对应顶点 $i$ ，其中存储了该顶点的所有邻接顶点（即与该顶点相连的顶点）。下图展示了一个使用邻接表存储的图的示例。\n\n![图的邻接表表示](graph.assets/adjacency_list.png)\n\n邻接表仅存储实际存在的边，而边的总数通常远小于 $n^2$ ，因此它更加节省空间。然而，在邻接表中需要通过遍历链表来查找边，因此其时间效率不如邻接矩阵。\n\n观察上图，**邻接表结构与哈希表中的“链式地址”非常相似，因此我们也可以采用类似方法来优化效率**。比如当链表较长时，可以将链表转化为 AVL 树或红黑树，从而将时间效率从 $O(n)$ 优化至 $O(\\log n)$ ；还可以把链表转换为哈希表，从而将时间复杂度降低至 $O(1)$ 。\n\n## 图常见应用\n\n如下表所示，许多现实系统都可以用图来建模，相应的问题也可以约化为图计算问题。\n\n<p align=\"center\"> 表 <id> &nbsp; 现实生活中常见的图 </p>\n\n|        | 顶点 | 边               | 图计算问题   |\n| ------ | ---- | --------------- | ------------ |\n| 社交网络 | 用户 | 好友关系           | 潜在好友推荐 |\n| 地铁线路 | 站点 | 站点间的连通性      | 最短路线推荐 |\n| 太阳系  | 星体 | 星体间的万有引力作用  | 行星轨道计算 |",
          "questions": [
            "图的定义是什么？由什么组成？",
            "图的类型有哪些？它们有何区别？",
            "什么是邻接？什么是路径？",
            "什么是度？有向图和无向图的度有何区别？",
            "图的常用表示方式有哪些？它们的优缺点分别是什么？",
            "邻接矩阵和邻接表的时间和空间复杂度分别是多少？",
            "现实生活中哪些系统可以用图来建模？它们的应用场景是什么？",
            "社交网络中的潜在好友推荐问题可以转化为什么样的图计算问题？",
            "地铁线路中的最短路线推荐问题可以转化为什么样的图计算问题？",
            "太阳系中的行星轨道计算问题可以转化为什么样的图计算问题？"
          ]
        }
      ]
    },
    {
      "file_name": "binary_search_tree.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 二叉搜索树\n\n如下图所示，「二叉搜索树 binary search tree」满足以下条件。\n\n1. 对于根节点，左子树中所有节点的值 $<$ 根节点的值 $<$ 右子树中所有节点的值。\n2. 任意节点的左、右子树也是二叉搜索树，即同样满足条件 `1.` 。\n\n![二叉搜索树](binary_search_tree.assets/binary_search_tree.png)\n\n## 二叉搜索树的操作\n\n我们将二叉搜索树封装为一个类 `ArrayBinaryTree` ，并声明一个成员变量 `root` ，指向树的根节点。\n\n### 查找节点\n\n给定目标节点值 `num` ，可以根据二叉搜索树的性质来查找。如下图所示，我们声明一个节点 `cur` ，从二叉树的根节点 `root` 出发，循环比较节点值 `cur.val` 和 `num` 之间的大小关系。\n\n- 若 `cur.val < num` ，说明目标节点在 `cur` 的右子树中，因此执行 `cur = cur.right` 。\n- 若 `cur.val > num` ，说明目标节点在 `cur` 的左子树中，因此执行 `cur = cur.left` 。\n- 若 `cur.val = num` ，说明找到目标节点，跳出循环并返回该节点。\n\n=== \"<1>\"\n    ![二叉搜索树查找节点示例](binary_search_tree.assets/bst_search_step1.png)\n\n=== \"<2>\"\n    ![bst_search_step2](binary_search_tree.assets/bst_search_step2.png)\n\n=== \"<3>\"\n    ![bst_search_step3](binary_search_tree.assets/bst_search_step3.png)\n\n=== \"<4>\"\n    ![bst_search_step4](binary_search_tree.assets/bst_search_step4.png)\n\n二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况。循环次数最多为二叉树的高度，当二叉树平衡时，使用 $O(\\log n)$ 时间。\n\n```src\n[file]{binary_search_tree}-[class]{binary_search_tree}-[func]{search}\n```\n\n### 插入节点\n\n给定一个待插入元素 `num` ，为了保持二叉搜索树“左子树 < 根节点 < 右子树”的性质，插入操作流程如下图所示。\n\n1. **查找插入位置**：与查找操作相似，从根节点出发，根据当前节点值和 `num` 的大小关系循环向下搜索，直到越过叶节点（遍历至 $\\text{None}$ ）时跳出循环。\n2. **在该位置插入节点**：初始化节点 `num` ，将该节点置于 $\\text{None}$ 的位置。\n\n![在二叉搜索树中插入节点](binary_search_tree.assets/bst_insert.png)\n\n在代码实现中，需要注意以下两点。\n\n- 二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回。\n- 为了实现插入节点，我们需要借助节点 `pre` 保存上一轮循环的节点。这样在遍历至 $\\text{None}$ 时，我们可以获取到其父节点，从而完成节点插入操作。\n\n```src\n[file]{binary_search_tree}-[class]{binary_search_tree}-[func]{insert}\n```\n\n与查找节点相同，插入节点使用 $O(\\log n)$ 时间。\n\n### 删除节点\n\n先在二叉树中查找到目标节点，再将其从二叉树中删除。\n\n与插入节点类似，我们需要保证在删除操作完成后，二叉搜索树的“左子树 < 根节点 < 右子树”的性质仍然满足。\n\n因此，我们需要根据目标节点的子节点数量，共分为 0、1 和 2 这三种情况，执行对应的删除节点操作。\n\n如下图所示，当待删除节点的度为 $0$ 时，表示该节点是叶节点，可以直接删除。\n\n![在二叉搜索树中删除节点（度为 0 ）](binary_search_tree.assets/bst_remove_case1.png)\n\n如下图所示，当待删除节点的度为 $1$ 时，将待删除节点替换为其子节点即可。\n\n![在二叉搜索树中删除节点（度为 1 ）](binary_search_tree.assets/bst_remove_case2.png)\n\n当待删除节点的度为 $2$ 时，我们无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树“左 $<$ 根 $<$ 右”的性质，**因此这个节点可以是右子树的最小节点或左子树的最大节点**。\n\n假设我们选择右子树的最小节点（即中序遍历的下一个节点），则删除操作流程如下图所示。\n\n1. 找到待删除节点在“中序遍历序列”中的下一个节点，记为 `tmp` 。\n2. 将 `tmp` 的值覆盖待删除节点的值，并在树中递归删除节点 `tmp` 。\n\n=== \"<1>\"\n    ![在二叉搜索树中删除节点（度为 2 ）](binary_search_tree.assets/bst_remove_case3_step1.png)\n\n=== \"<2>\"\n    ![bst_remove_case3_step2](binary_search_tree.assets/bst_remove_case3_step2.png)\n\n=== \"<3>\"\n    ![bst_remove_case3_step3](binary_search_tree.assets/bst_remove_case3_step3.png)\n\n=== \"<4>\"\n    ![bst_remove_case3_step4](binary_search_tree.assets/bst_remove_case3_step4.png)\n\n删除节点操作同样使用 $O(\\log n)$ 时间，其中查找待删除节点需要 $O(\\log n)$ 时间，获取中序遍历后继节点需要 $O(\\log n)$ 时间。\n\n```src\n[file]{binary_search_tree}-[class]{binary_search_tree}-[func]{remove}\n```\n\n### 中序遍历有序\n\n如下图所示，二叉树的中序遍历遵循“左 $\\rightarrow$ 根 $\\rightarrow$ 右”的遍历顺序，而二叉搜索树满足“左子节点 $<$ 根节点 $<$ 右子节点”的大小关系。\n\n这意味着在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：**二叉搜索树的中序遍历序列是升序的**。\n\n利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需 $O(n)$ 时间，无须进行额外的排序操作，非常高效。\n\n![二叉搜索树的中序遍历序列](binary_search_tree.assets/bst_inorder_traversal.png)\n\n## 二叉搜索树的效率\n\n给定一组数据，我们考虑使用数组或二叉搜索树存储。观察下表，二叉搜索树的各项操作的时间复杂度都是对数阶，具有稳定且高效的性能表现。只有在高频添加、低频查找删除的数据适用场景下，数组比二叉搜索树的效率更高。\n\n<p align=\"center\"> 表 <id> &nbsp; 数组与搜索树的效率对比 </p>\n\n|          | 无序数组 | 二叉搜索树  |\n| -------- | -------- | ----------- |\n| 查找元素 | $O(n)$   | $O(\\log n)$ |\n| 插入元素 | $O(1)$   | $O(\\log n)$ |\n| 删除元素 | $O(n)$   | $O(\\log n)$ |\n\n在理想情况下，二叉搜索树是“平衡”的，这样就可以在 $\\log n$ 轮循环内查找任意节点。\n\n然而，如果我们在二叉搜索树中不断地插入和删除节点，可能导致二叉树退化为下图所示的链表，这时各种操作的时间复杂度也会退化为 $O(n)$ 。\n\n![二叉搜索树的退化](binary_search_tree.assets/bst_degradation.png)\n\n## 二叉搜索树常见应用\n\n- 用作系统中的多级索引，实现高效的查找、插入、删除操作。\n- 作为某些搜索算法的底层数据结构。\n- 用于存储数据流，以保持其有序状态。",
          "questions": [
            "二叉搜索树的定义是什么？",
            "二叉搜索树的查找操作的时间复杂度是多少？",
            "二叉搜索树的插入操作的时间复杂度是多少？",
            "二叉搜索树的删除操作的时间复杂度是多少？",
            "二叉搜索树的中序遍历序列有什么特点？",
            "二叉搜索树的中序遍历序列是升序的，这个性质有什么应用？",
            "什么情况下使用数组比使用二叉搜索树更高效？",
            "二叉搜索树可能会退化为什么样的结构？",
            "二叉搜索树有哪些常见应用？",
            "二叉搜索树的操作中，如何保证不会出现重复节点？"
          ]
        }
      ]
    },
    {
      "file_name": "hanota_problem.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 汉诺塔问题\n\n在归并排序和构建二叉树中，我们都是将原问题分解为两个规模为原问题一半的子问题。然而对于汉诺塔问题，我们采用不同的分解策略。\n\n!!! question\n\n    给定三根柱子，记为 `A`、`B` 和 `C` 。起始状态下，柱子 `A` 上套着 $n$ 个圆盘，它们从上到下按照从小到大的顺序排列。我们的任务是要把这 $n$ 个圆盘移到柱子 `C` 上，并保持它们的原有顺序不变。在移动圆盘的过程中，需要遵守以下规则。\n    \n    1. 圆盘只能从一个柱子顶部拿出，从另一个柱子顶部放入。\n    2. 每次只能移动一个圆盘。\n    3. 小圆盘必须时刻位于大圆盘之上。\n\n![汉诺塔问题示例](hanota_problem.assets/hanota_example.png)\n\n**我们将规模为 $i$ 的汉诺塔问题记做 $f(i)$** 。例如 $f(3)$ 代表将 $3$ 个圆盘从 `A` 移动至 `C` 的汉诺塔问题。\n\n### 考虑基本情况\n\n如下图所示，对于问题 $f(1)$ ，即当只有一个圆盘时，我们将它直接从 `A` 移动至 `C` 即可。\n\n=== \"<1>\"\n    ![规模为 1 问题的解](hanota_problem.assets/hanota_f1_step1.png)\n\n=== \"<2>\"\n    ![hanota_f1_step2](hanota_problem.assets/hanota_f1_step2.png)\n\n如下图所示，对于问题 $f(2)$ ，即当有两个圆盘时，**由于要时刻满足小圆盘在大圆盘之上，因此需要借助 `B` 来完成移动**。\n\n1. 先将上面的小圆盘从 `A` 移至 `B` 。\n2. 再将大圆盘从 `A` 移至 `C` 。\n3. 最后将小圆盘从 `B` 移至 `C` 。\n\n=== \"<1>\"\n    ![规模为 2 问题的解](hanota_problem.assets/hanota_f2_step1.png)\n\n=== \"<2>\"\n    ![hanota_f2_step2](hanota_problem.assets/hanota_f2_step2.png)\n\n=== \"<3>\"\n    ![hanota_f2_step3](hanota_problem.assets/hanota_f2_step3.png)\n\n=== \"<4>\"\n    ![hanota_f2_step4](hanota_problem.assets/hanota_f2_step4.png)\n\n解决问题 $f(2)$ 的过程可总结为：**将两个圆盘借助 `B` 从 `A` 移至 `C`** 。其中，`C` 称为目标柱、`B` 称为缓冲柱。\n\n### 子问题分解\n\n对于问题 $f(3)$ ，即当有三个圆盘时，情况变得稍微复杂了一些。\n\n因为已知 $f(1)$ 和 $f(2)$ 的解，所以我们可从分治角度思考，**将 `A` 顶部的两个圆盘看做一个整体**，执行下图所示的步骤。这样三个圆盘就被顺利地从 `A` 移动至 `C` 了。\n\n1. 令 `B` 为目标柱、`C` 为缓冲柱，将两个圆盘从 `A` 移动至 `B` 。\n2. 将 `A` 中剩余的一个圆盘从 `A` 直接移动至 `C` 。\n3. 令 `C` 为目标柱、`A` 为缓冲柱，将两个圆盘从 `B` 移动至 `C` 。\n\n=== \"<1>\"\n    ![规模为 3 问题的解](hanota_problem.assets/hanota_f3_step1.png)\n\n=== \"<2>\"\n    ![hanota_f3_step2](hanota_problem.assets/hanota_f3_step2.png)\n\n=== \"<3>\"\n    ![hanota_f3_step3](hanota_problem.assets/hanota_f3_step3.png)\n\n=== \"<4>\"\n    ![hanota_f3_step4](hanota_problem.assets/hanota_f3_step4.png)\n\n本质上看，**我们将问题 $f(3)$ 划分为两个子问题 $f(2)$ 和子问题 $f(1)$** 。按顺序解决这三个子问题之后，原问题随之得到解决。这说明子问题是独立的，而且解是可以合并的。\n\n至此，我们可总结出下图所示的汉诺塔问题的分治策略：将原问题 $f(n)$ 划分为两个子问题 $f(n-1)$ 和一个子问题 $f(1)$ ，并按照以下顺序解决这三个子问题。\n\n1. 将 $n-1$ 个圆盘借助 `C` 从 `A` 移至 `B` 。\n2. 将剩余 $1$ 个圆盘从 `A` 直接移至 `C` 。\n3. 将 $n-1$ 个圆盘借助 `A` 从 `B` 移至 `C` 。\n\n对于这两个子问题 $f(n-1)$ ，**可以通过相同的方式进行递归划分**，直至达到最小子问题 $f(1)$ 。而 $f(1)$ 的解是已知的，只需一次移动操作即可。\n\n![汉诺塔问题的分治策略](hanota_problem.assets/hanota_divide_and_conquer.png)\n\n### 代码实现\n\n在代码中，我们声明一个递归函数 `dfs(i, src, buf, tar)` ，它的作用是将柱 `src` 顶部的 $i$ 个圆盘借助缓冲柱 `buf` 移动至目标柱 `tar` 。\n\n```src\n[file]{hanota}-[class]{}-[func]{solve_hanota}\n```\n\n如下图所示，汉诺塔问题形成一个高度为 $n$ 的递归树，每个节点代表一个子问题、对应一个开启的 `dfs()` 函数，**因此时间复杂度为 $O(2^n)$ ，空间复杂度为 $O(n)$** 。\n\n![汉诺塔问题的递归树](hanota_problem.assets/hanota_recursive_tree.png)\n\n!!! quote\n\n    汉诺塔问题源自一种古老的传说故事。在古印度的一个寺庙里，僧侣们有三根高大的钻石柱子，以及 $64$ 个大小不一的金圆盘。僧侣们不断地移动原盘，他们相信在最后一个圆盘被正确放置的那一刻，这个世界就会结束。\n\n    然而，即使僧侣们每秒钟移动一次，总共需要大约 $2^{64} \\approx 1.84×10^{19}$ 秒，合约 $5850$ 亿年，远远超过了现在对宇宙年龄的估计。所以，倘若这个传说是真的，我们应该不需要担心世界末日的到来。",
          "questions": [
            "汉诺塔问题的起源和传说是什么？",
            "汉诺塔问题的规则是什么？",
            "如何解决汉诺塔问题？",
            "汉诺塔问题的时间复杂度和空间复杂度是多少？",
            "汉诺塔问题的分治策略是什么？",
            "汉诺塔问题的递归树长什么样？",
            "汉诺塔问题的子问题是如何划分的？",
            "汉诺塔问题的解决过程中需要借助哪些柱子？",
            "汉诺塔问题的解决过程中，每次只能移动几个圆盘？",
            "汉诺塔问题的解决过程中，小圆盘必须位于哪个位置？"
          ]
        }
      ]
    }
  ]
}
