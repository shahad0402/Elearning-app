{
  "question_type": "short",
  "designated_role": "examiner",
  "icon": "mdi-vuejs",
  "description": "Vue 组件是 Vue.js 的基本组成部分，用于构建用户界面",
  "link": "https://cn.vuejs.org/guide/components/registration.html",
  "total_question_count": 170,
  "files": [
    {
      "file_name": "async.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 异步组件 {#async-components}\n\n## 基本用法 {#basic-usage}\n\n在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 [`defineAsyncComponent`](/api/general#defineasynccomponent) 方法来实现此功能：\n\n```js\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComp = defineAsyncComponent(() => {\n  return new Promise((resolve, reject) => {\n    // ...从服务器获取组件\n    resolve(/* 获取到的组件 */)\n  })\n})\n// ... 像使用其他一般组件一样使用 `AsyncComp`\n```\n\n如你所见，`defineAsyncComponent` 方法接收一个返回 Promise 的加载函数。这个 Promise 的 `resolve` 回调方法应该在从服务器获得组件定义时调用。你也可以调用 `reject(reason)` 表明加载失败。\n\n[ES 模块动态导入](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import)也会返回一个 Promise，所以多数情况下我们会将它和 `defineAsyncComponent` 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue 单文件组件：\n\n```js\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComp = defineAsyncComponent(() =>\n  import('./components/MyComponent.vue')\n)\n```\n\n最后得到的 `AsyncComp` 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。\n\n与普通组件一样，异步组件可以使用 `app.component()` [全局注册](/guide/components/registration#global-registration)：\n\n```js\napp.component('MyComponent', defineAsyncComponent(() =>\n  import('./components/MyComponent.vue')\n))\n```\n\n<div class=\"options-api\">\n\n你也可以在[局部注册组件](/guide/components/registration#local-registration)时使用 `defineAsyncComponent`：\n\n```vue\n<script>\nimport { defineAsyncComponent } from 'vue'\n\nexport default {\n  components: {\n    AdminPage: defineAsyncComponent(() =>\n      import('./components/AdminPageComponent.vue')\n    )\n  }\n}\n</script>\n\n<template>\n  <AdminPage />\n</template>\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n也可以直接在父组件中直接定义它们：\n\n```vue\n<script setup>\nimport { defineAsyncComponent } from 'vue'\n\nconst AdminPage = defineAsyncComponent(() =>\n  import('./components/AdminPageComponent.vue')\n)\n</script>\n\n<template>\n  <AdminPage />\n</template>\n```\n\n</div>\n\n## 加载与错误状态 {#loading-and-error-states}\n\n异步操作不可避免地会涉及到加载和错误状态，因此 `defineAsyncComponent()` 也支持在高级选项中处理这些状态：\n\n```js\nconst AsyncComp = defineAsyncComponent({\n  // 加载函数\n  loader: () => import('./Foo.vue'),\n\n  // 加载异步组件时使用的组件\n  loadingComponent: LoadingComponent,\n  // 展示加载组件前的延迟时间，默认为 200ms\n  delay: 200,\n\n  // 加载失败后展示的组件\n  errorComponent: ErrorComponent,\n  // 如果提供了一个 timeout 时间限制，并超时了\n  // 也会显示这里配置的报错组件，默认值是：Infinity\n  timeout: 3000\n})\n```\n\n如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。\n\n如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。\n\n## 搭配 Suspense 使用 {#using-with-suspense}\n\n异步组件可以搭配内置的 `<Suspense>` 组件一起使用，若想了解 `<Suspense>` 和异步组件之间交互，请参阅 [`<Suspense>`](/guide/built-ins/suspense) 章节。",
          "questions": [
            "`defineAsyncComponent` 方法的作用是什么？",
            "`defineAsyncComponent` 方法接收什么参数？",
            "`defineAsyncComponent` 方法返回的是什么？",
            "在使用 `defineAsyncComponent` 方法时，加载函数应该返回什么？",
            "如何使用 `defineAsyncComponent` 方法导入 Vue 单文件组件？",
            "异步组件可以使用哪些方式进行全局注册？",
            "在局部注册组件时，如何使用 `defineAsyncComponent`？",
            "在父组件中如何直接定义异步组件？",
            "`defineAsyncComponent` 方法支持哪些加载和错误状态的处理？",
            "异步组件可以搭配哪个内置组件一起使用？"
          ]
        }
      ]
    },
    {
      "file_name": "props.md",
      "question_count": 30,
      "documents": [
        {
          "content": "# Props {#props}\n\n> 此章节假设你已经看过了[组件基础](/guide/essentials/component-basics)。若你还不了解组件是什么，请先阅读该章节。\n\n## Props 声明 {#props-declaration}\n\n一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute (关于透传 attribute，我们会在[专门的章节](/guide/components/attrs)中讨论)。\n\n<div class=\"composition-api\">\n\n在使用 `<script setup>` 的单文件组件中，props 可以使用 `defineProps()` 宏来声明：\n\n```vue\n<script setup>\nconst props = defineProps(['foo'])\n\nconsole.log(props.foo)\n</script>\n```\n\n在没有使用 `<script setup>` 的组件中，prop 可以使用 [`props`](/api/options-state#props) 选项来声明：\n\n```js\nexport default {\n  props: ['foo'],\n  setup(props) {\n    // setup() 接收 props 作为第一个参数\n    console.log(props.foo)\n  }\n}\n```\n\n注意传递给 `defineProps()` 的参数和提供给 `props` 选项的值是相同的，两种声明方式背后其实使用的都是 prop 选项。\n\n</div>\n\n<div class=\"options-api\">\n\nprops 需要使用 [`props`](/api/options-state#props) 选项来定义：\n\n```js\nexport default {\n  props: ['foo'],\n  created() {\n    // props 会暴露到 `this` 上\n    console.log(this.foo)\n  }\n}\n```\n\n</div>\n\n除了使用字符串数组来声明 prop 外，还可以使用对象的形式：\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}\n```\n\n</div>\n<div class=\"composition-api\">\n\n```js\n// 使用 <script setup>\ndefineProps({\n  title: String,\n  likes: Number\n})\n```\n\n```js\n// 非 <script setup>\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}\n```\n\n</div>\n\n对于以对象形式声明中的每个属性，key 是 prop 的名称，而值则是该 prop 预期类型的构造函数。比如，如果要求一个 prop 的值是 `number` 类型，则可使用 `Number` 构造函数作为其声明的值。\n\n对象形式的 props 声明不仅可以一定程度上作为组件的文档，而且如果其他开发者在使用你的组件时传递了错误的类型，也会在浏览器控制台中抛出警告。我们将在本章节稍后进一步讨论有关 [prop 校验](#prop-validation)的更多细节。\n\n<div class=\"options-api\">\n\nTypeScript 用户请参考：[为组件 Props 标注类型](/guide/typescript/options-api#typing-component-props) <sup class=\"vt-badge ts\" />\n\n</div>\n\n<div class=\"composition-api\">\n\n如果你正在搭配 TypeScript 使用 `<script setup>`，也可以使用类型标注来声明 props：\n\n```vue\n<script setup lang=\"ts\">\ndefineProps<{\n  title?: string\n  likes?: number\n}>()\n</script>\n```\n\n更多关于基于类型的声明的细节请参考[组件 props 类型标注](/guide/typescript/composition-api#typing-component-props)。<sup class=\"vt-badge ts\" />\n\n</div>\n\n## 传递 prop 的细节 {#prop-passing-details}\n\n### Prop 名字格式 {#prop-name-casing}\n\n如果一个 prop 的名字很长，应使用 camelCase 形式，因为它们是合法的 JavaScript 标识符，可以直接在模板的表达式中使用，也可以避免在作为属性 key 名时必须加上引号。\n\n<div class=\"composition-api\">\n\n```js\ndefineProps({\n  greetingMessage: String\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    greetingMessage: String\n  }\n}\n```\n\n</div>\n\n```vue-html\n<span>{{ greetingMessage }}</span>\n```\n\n虽然理论上你也可以在向子组件传递 props 时使用 camelCase 形式 (使用 [DOM 内模板](/guide/essentials/component-basics#in-dom-template-parsing-caveats)时例外)，但实际上为了和 HTML attribute 对齐，我们通常会将其写为 kebab-case 形式：\n\n```vue-html\n<MyComponent greeting-message=\"hello\" />\n```\n\n对于组件名我们推荐使用 [PascalCase](/guide/components/registration#component-name-casing)，因为这提高了模板的可读性，能帮助我们区分 Vue 组件和原生 HTML 元素。然而对于传递 props 来说，使用 camelCase 并没有太多优势，因此我们推荐更贴近 HTML 的书写风格。\n\n### 静态 vs. 动态 Prop {#static-vs-dynamic-props}\n\n至此，你已经见过了很多像这样的静态值形式的 props：\n\n```vue-html\n<BlogPost title=\"My journey with Vue\" />\n```\n\n相应地，还有使用 `v-bind` 或缩写 `:` 来进行动态绑定的 props：\n\n```vue-html\n<!-- 根据一个变量的值动态传入 -->\n<BlogPost :title=\"post.title\" />\n\n<!-- 根据一个更复杂表达式的值动态传入 -->\n<BlogPost :title=\"post.title + ' by ' + post.author.name\" />\n```\n\n### 传递不同的值类型 {#passing-different-value-types}\n\n在上述的两个例子中，我们只传入了字符串值，但实际上**任何**类型的值都可以作为 props 的值被传递。\n\n#### Number {#number}\n\n```vue-html\n<!-- 虽然 `42` 是个常量，我们还是需要使用 v-bind -->\n<!-- 因为这是一个 JavaScript 表达式而不是一个字符串 -->\n<BlogPost :likes=\"42\" />\n\n<!-- 根据一个变量的值动态传入 -->\n<BlogPost :likes=\"post.likes\" />\n```\n\n#### Boolean {#boolean}\n\n```vue-html\n<!-- 仅写上 prop 但不传值，会隐式转换为 `true` -->\n<BlogPost is-published />\n\n<!-- 虽然 `false` 是静态的值，我们还是需要使用 v-bind -->\n<!-- 因为这是一个 JavaScript 表达式而不是一个字符串 -->\n<BlogPost :is-published=\"false\" />\n\n<!-- 根据一个变量的值动态传入 -->\n<BlogPost :is-published=\"post.isPublished\" />\n```\n\n#### Array {#array}\n\n```vue-html\n<!-- 虽然这个数组是个常量，我们还是需要使用 v-bind -->\n<!-- 因为这是一个 JavaScript 表达式而不是一个字符串 -->\n<BlogPost :comment-ids=\"[234, 266, 273]\" />\n\n<!-- 根据一个变量的值动态传入 -->\n<BlogPost :comment-ids=\"post.commentIds\" />\n```\n\n#### Object {#object}\n\n```vue-html\n<!-- 虽然这个对象字面量是个常量，我们还是需要使用 v-bind -->\n<!-- 因为这是一个 JavaScript 表达式而不是一个字符串 -->\n<BlogPost\n  :author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n />\n\n<!-- 根据一个变量的值动态传入 -->\n<BlogPost :author=\"post.author\" />\n```\n\n### 使用一个对象绑定多个 prop {#binding-multiple-properties-using-an-object}\n\n如果你想要将一个对象的所有属性都当作 props 传入，你可以使用[没有参数的 `v-bind`](/guide/essentials/template-syntax#dynamically-binding-multiple-attributes)，即只使用 `v-bind` 而非 `:prop-name`。例如，这里有一个 `post` 对象：\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  data() {\n    return {\n      post: {\n        id: 1,\n        title: 'My Journey with Vue'\n      }\n    }\n  }\n}\n```\n\n</div>\n<div class=\"composition-api\">\n\n```js\nconst post = {\n  id: 1,\n  title: 'My Journey with Vue'\n}\n```\n\n</div>\n\n以及下面的模板：\n\n```vue-html\n<BlogPost v-bind=\"post\" />\n```\n\n而这实际上等价于：\n\n```vue-html\n<BlogPost :id=\"post.id\" :title=\"post.title\" />\n```",
          "questions": [
            "在使用 `<script setup>` 的单文件组件中，如何声明 props？",
            "在没有使用 `<script setup>` 的组件中，如何声明 props？",
            "除了使用字符串数组来声明 prop 外，还可以使用什么形式？",
            "对于以对象形式声明中的每个属性，key 是什么？值是什么？",
            "为什么推荐使用 camelCase 形式来命名 prop？",
            "什么是静态值形式的 props？什么是动态绑定的 props？",
            "除了字符串值，还可以传递哪些类型的值作为 props 的值？",
            "如何将一个对象的所有属性都当作 props 传入？",
            "在使用一个对象绑定多个 prop 时，使用 `v-bind` 而非 `:prop-name` 有什么作用？",
            "如何在组件中校验 prop 的值？"
          ]
        },
        {
          "content": "## 单向数据流 {#one-way-data-flow}\n\n所有的 props 都遵循着**单向绑定**原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。\n\n另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你**不应该**在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告：\n\n<div class=\"composition-api\">\n\n```js\nconst props = defineProps(['foo'])\n\n// ❌ 警告！prop 是只读的！\nprops.foo = 'bar'\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: ['foo'],\n  created() {\n    // ❌ 警告！prop 是只读的！\n    this.foo = 'bar'\n  }\n}\n```\n\n</div>\n\n导致你想要更改一个 prop 的需求通常来源于以下两种场景：\n\n1. **prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性**。在这种情况下，最好是新定义一个局部数据属性，从 props 上获取初始值即可：\n\n   <div class=\"composition-api\">\n\n   ```js\n   const props = defineProps(['initialCounter'])\n\n   // 计数器只是将 props.initialCounter 作为初始值\n   // 像下面这样做就使 prop 和后续更新无关了\n   const counter = ref(props.initialCounter)\n   ```\n\n   </div>\n   <div class=\"options-api\">\n\n   ```js\n   export default {\n     props: ['initialCounter'],\n     data() {\n       return {\n         // 计数器只是将 this.initialCounter 作为初始值\n         // 像下面这样做就使 prop 和后续更新无关了\n         counter: this.initialCounter\n       }\n     }\n   }\n   ```\n\n   </div>\n\n2. **需要对传入的 prop 值做进一步的转换**。在这种情况中，最好是基于该 prop 值定义一个计算属性：\n\n   <div class=\"composition-api\">\n\n   ```js\n   const props = defineProps(['size'])\n\n   // 该 prop 变更时计算属性也会自动更新\n   const normalizedSize = computed(() => props.size.trim().toLowerCase())\n   ```\n\n   </div>\n   <div class=\"options-api\">\n\n   ```js\n   export default {\n     props: ['size'],\n     computed: {\n       // 该 prop 变更时计算属性也会自动更新\n       normalizedSize() {\n         return this.size.trim().toLowerCase()\n       }\n     }\n   }\n   ```\n\n   </div>\n\n### 更改对象 / 数组类型的 props {#mutating-object-array-props}\n\n当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然**可以**更改对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，而对 Vue 来说，禁止这样的改动，虽然可能生效，但有很大的性能损耗，比较得不偿失。\n\n这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。在大多数场景下，子组件应该[抛出一个事件](/guide/components/events)来通知父组件做出改变。\n\n## Prop 校验 {#prop-validation}\n\nVue 组件可以更细致地声明对传入的 props 的校验要求。比如我们上面已经看到过的类型声明，如果传入的值不满足类型要求，Vue 会在浏览器控制台中抛出警告来提醒使用者。这在开发给其他开发者使用的组件时非常有用。\n\n要声明对 props 的校验，你可以向 <span class=\"composition-api\">`defineProps()` 宏</span><span class=\"options-api\">`props` 选项</span>提供一个带有 props 校验选项的对象，例如：\n\n<div class=\"composition-api\">\n\n```js\ndefineProps({\n  // 基础类型检查\n  // （给出 `null` 和 `undefined` 值则会跳过任何类型检查）\n  propA: Number,\n  // 多种可能的类型\n  propB: [String, Number],\n  // 必传，且为 String 类型\n  propC: {\n    type: String,\n    required: true\n  },\n  // Number 类型的默认值\n  propD: {\n    type: Number,\n    default: 100\n  },\n  // 对象类型的默认值\n  propE: {\n    type: Object,\n    // 对象或数组的默认值\n    // 必须从一个工厂函数返回。\n    // 该函数接收组件所接收到的原始 prop 作为参数。\n    default(rawProps) {\n      return { message: 'hello' }\n    }\n  },\n  // 自定义类型校验函数\n  propF: {\n    validator(value) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // 函数类型的默认值\n  propG: {\n    type: Function,\n    // 不像对象或数组的默认，这不是一个\n    // 工厂函数。这会是一个用来作为默认值的函数\n    default() {\n      return 'Default function'\n    }\n  }\n})\n```\n\n:::tip\n`defineProps()` 宏中的参数**不可以访问 `<script setup>` 中定义的其他变量**，因为在编译时整个表达式都会被移到外部的函数中。\n:::\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    // 基础类型检查\n    //（给出 `null` 和 `undefined` 值则会跳过任何类型检查）\n    propA: Number,\n    // 多种可能的类型\n    propB: [String, Number],\n    // 必传，且为 String 类型\n    propC: {\n      type: String,\n      required: true\n    },\n    // Number 类型的默认值\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // 对象类型的默认值\n    propE: {\n      type: Object,\n      // 对象或者数组应当用工厂函数返回。\n      // 工厂函数会收到组件所接收的原始 props\n      // 作为参数\n      default(rawProps) {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义类型校验函数\n    propF: {\n      validator(value) {\n        // The value must match one of these strings\n        return ['success', 'warning', 'danger'].includes(value)\n      }\n    },\n    // 函数类型的默认值\n    propG: {\n      type: Function,\n      // 不像对象或数组的默认，这不是一个\n      // 工厂函数。这会是一个用来作为默认值的函数\n      default() {\n        return 'Default function'\n      }\n    }\n  }\n}\n```\n\n</div>\n\n一些补充细节：\n\n- 所有 prop 默认都是可选的，除非声明了 `required: true`。\n\n- 除 `Boolean` 外的未传递的可选 prop 将会有一个默认值 `undefined`。\n\n- `Boolean` 类型的未传递 prop 将被转换为 `false`。这可以通过为它设置 `default` 来更改——例如：设置为 `default: undefined` 将与非布尔类型的 prop 的行为保持一致。\n\n- 如果声明了 `default` 值，那么在 prop 的值被解析为 `undefined` 时，无论 prop 是未被传递还是显式指明的 `undefined`，都会改为 `default` 值。\n\n当 prop 的校验失败后，Vue 会抛出一个控制台警告 (在开发模式下)。\n\n<div class=\"composition-api\">\n\n如果使用了[基于类型的 prop 声明](/api/sfc-script-setup#type-only-props-emit-declarations) <sup class=\"vt-badge ts\" />，Vue 会尽最大努力在运行时按照 prop 的类型标注进行编译。举例来说，`defineProps<{ msg: string }>` 会被编译为 `{ msg: { type: String, required: true }}`。\n\n</div>\n<div class=\"options-api\">\n\n::: tip 注意\n注意 prop 的校验是在组件实例被创建**之前**，所以实例的属性 (比如 `data`、`computed` 等) 将在 `default` 或 `validator` 函数中不可用。\n:::\n\n</div>\n\n### 运行时类型检查 {#runtime-type-checks}\n\n校验选项中的 `type` 可以是下列这些原生构造函数：\n\n- `String`\n- `Number`\n- `Boolean`\n- `Array`\n- `Object`\n- `Date`\n- `Function`\n- `Symbol`\n\n另外，`type` 也可以是自定义的类或构造函数，Vue 将会通过 `instanceof` 来检查类型是否匹配。例如下面这个类：\n\n```js\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n  }\n}\n```\n\n你可以将其作为一个 prop 的类型：\n\n<div class=\"composition-api\">\n\n```js\ndefineProps({\n  author: Person\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    author: Person\n  }\n}\n```\n\n</div>\n\nVue 会通过 `instanceof Person` 来校验 `author` prop 的值是否是 `Person` 类的一个实例。",
          "questions": [
            "什么是单向数据流？为什么要遵循单向数据流原则？",
            "子组件能否逆向传递数据给父组件？为什么？",
            "当父组件更新后，子组件中的props会发生什么变化？",
            "在子组件中更改一个prop会发生什么？Vue会有什么警告？",
            "什么情况下需要将prop作为局部数据属性使用？应该如何实现？",
            "什么情况下需要对传入的prop值做进一步的转换？应该如何实现？",
            "当对象或数组作为props被传入时，子组件能否更改对象或数组内部的值？为什么？",
            "对于传入的props，Vue组件可以如何声明对其的校验要求？请举例说明。",
            "除了基本类型之外，prop的type还可以是哪些类型？如何进行校验？",
            "在运行时，Vue会如何进行类型检查？"
          ]
        },
        {
          "content": "## Boolean 类型转换 {#boolean-casting}\n\n为了更贴近原生 boolean attributes 的行为，声明为 `Boolean` 类型的 props 有特别的类型转换规则。以带有如下声明的 `<MyComponent>` 组件为例：\n\n<div class=\"composition-api\">\n\n```js\ndefineProps({\n  disabled: Boolean\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    disabled: Boolean\n  }\n}\n```\n\n</div>\n\n该组件可以被这样使用：\n\n```vue-html\n<!-- 等同于传入 :disabled=\"true\" -->\n<MyComponent disabled />\n\n<!-- 等同于传入 :disabled=\"false\" -->\n<MyComponent />\n```\n\n当一个 prop 被声明为允许多种类型时，`Boolean` 的转换规则也将被应用。然而，当同时允许 `String` 和 `Boolean` 时，有一种边缘情况——只有当 `Boolean` 出现在 `String` 之前时，`Boolean` 转换规则才适用：\n\n<div class=\"composition-api\">\n\n```js\n// disabled 将被转换为 true\ndefineProps({\n  disabled: [Boolean, Number]\n})\n  \n// disabled 将被转换为 true\ndefineProps({\n  disabled: [Boolean, String]\n})\n  \n// disabled 将被转换为 true\ndefineProps({\n  disabled: [Number, Boolean]\n})\n  \n// disabled 将被解析为空字符串 (disabled=\"\")\ndefineProps({\n  disabled: [String, Boolean]\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\n// disabled 将被转换为 true\nexport default {\n  props: {\n    disabled: [Boolean, Number]\n  }\n}\n  \n// disabled 将被转换为 true\nexport default {\n  props: {\n    disabled: [Boolean, String]\n  }\n}\n  \n// disabled 将被转换为 true\nexport default {\n  props: {\n    disabled: [Number, Boolean]\n  }\n}\n  \n// disabled 将被解析为空字符串 (disabled=\"\")\nexport default {\n  props: {\n    disabled: [String, Boolean]\n  }\n}\n```\n\n</div>",
          "questions": [
            "在Vue中，声明为Boolean类型的props有什么特别的类型转换规则？",
            "以带有如下声明的<MyComponent>组件为例，该组件可以被如何使用？",
            "当一个prop被声明为允许多种类型时，Boolean的转换规则也将被应用吗？",
            "在同时允许String和Boolean时，有哪种边缘情况？",
            "只有当Boolean出现在String之前时，Boolean转换规则才适用吗？",
            "在Vue中，如何声明一个prop为允许多种类型？",
            "在Vue中，如何声明一个prop为Boolean类型？",
            "在Vue中，如何声明一个prop为String类型？",
            "在Vue中，如何声明一个prop为Number类型？",
            "在Vue中，如何声明一个组件的props？"
          ]
        }
      ]
    },
    {
      "file_name": "provide-inject.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 依赖注入 {#provide-inject}\n\n> 此章节假设你已经看过了[组件基础](/guide/essentials/component-basics)。若你还不了解组件是什么，请先阅读该章节。\n\n## Prop 逐级透传问题 {#prop-drilling}\n\n通常情况下，当我们需要从父组件向子组件传递数据时，会使用 [props](/guide/components/props)。想象一下这样的结构：有一些多层级嵌套的组件，形成了一颗巨大的组件树，而某个深层的子组件需要一个较远的祖先组件中的部分数据。在这种情况下，如果仅使用 props 则必须将其沿着组件链逐级传递下去，这会非常麻烦：\n\n![Prop 逐级透传的过程图示](./images/prop-drilling.png)\n\n<!-- https://www.figma.com/file/yNDTtReM2xVgjcGVRzChss/prop-drilling -->\n\n注意，虽然这里的 `<Footer>` 组件可能根本不关心这些 props，但为了使 `<DeepChild>` 能访问到它们，仍然需要定义并向下传递。如果组件链路非常长，可能会影响到更多这条路上的组件。这一问题被称为“prop 逐级透传”，显然是我们希望尽量避免的情况。\n\n`provide` 和 `inject` 可以帮助我们解决这一问题。 <sup>[[1]](#footnote-1)</sup> 一个父组件相对于其所有的后代组件，会作为**依赖提供者**。任何后代的组件树，无论层级有多深，都可以**注入**由父组件提供给整条链路的依赖。\n\n![Provide/inject 模式](./images/provide-inject.png)\n\n<!-- https://www.figma.com/file/PbTJ9oXis5KUawEOWdy2cE/provide-inject -->\n\n## Provide (提供) {#provide}\n\n<div class=\"composition-api\">\n\n要为组件后代提供数据，需要使用到 [`provide()`](/api/composition-api-dependency-injection#provide) 函数：\n\n```vue\n<script setup>\nimport { provide } from 'vue'\n\nprovide(/* 注入名 */ 'message', /* 值 */ 'hello!')\n</script>\n```\n\n如果不使用 `<script setup>`，请确保 `provide()` 是在 `setup()` 同步调用的：\n\n```js\nimport { provide } from 'vue'\n\nexport default {\n  setup() {\n    provide(/* 注入名 */ 'message', /* 值 */ 'hello!')\n  }\n}\n```\n\n`provide()` 函数接收两个参数。第一个参数被称为**注入名**，可以是一个字符串或是一个 `Symbol`。后代组件会用注入名来查找期望注入的值。一个组件可以多次调用 `provide()`，使用不同的注入名，注入不同的依赖值。\n\n第二个参数是提供的值，值可以是任意类型，包括响应式的状态，比如一个 ref：\n\n```js\nimport { ref, provide } from 'vue'\n\nconst count = ref(0)\nprovide('key', count)\n```\n\n提供的响应式状态使后代组件可以由此和提供者建立响应式的联系。\n\n</div>\n\n<div class=\"options-api\">\n\n要为组件后代提供数据，需要使用到 [`provide`](/api/options-composition#provide) 选项：\n\n```js\nexport default {\n  provide: {\n    message: 'hello!'\n  }\n}\n```\n\n对于 `provide` 对象上的每一个属性，后代组件会用其 key 为注入名查找期望注入的值，属性的值就是要提供的数据。\n\n如果我们需要提供依赖当前组件实例的状态 (比如那些由 `data()` 定义的数据属性)，那么可以以函数形式使用 `provide`：\n\n```js{7-12}\nexport default {\n  data() {\n    return {\n      message: 'hello!'\n    }\n  },\n  provide() {\n    // 使用函数的形式，可以访问到 `this`\n    return {\n      message: this.message\n    }\n  }\n}\n```\n\n然而，请注意这**不会**使注入保持响应性。我们会在后续小节中讨论如何[让注入转变为响应式](#working-with-reactivity)。\n\n</div>\n\n## 应用层 Provide {#app-level-provide}\n\n除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖：\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n\napp.provide(/* 注入名 */ 'message', /* 值 */ 'hello!')\n```\n\n在应用级别提供的数据在该应用内的所有组件中都可以注入。这在你编写[插件](/guide/reusability/plugins)时会特别有用，因为插件一般都不会使用组件形式来提供值。\n\n## Inject (注入) {#inject}\n\n<div class=\"composition-api\">\n\n要注入上层组件提供的数据，需使用 [`inject()`](/api/composition-api-dependency-injection#inject) 函数：\n\n```vue\n<script setup>\nimport { inject } from 'vue'\n\nconst message = inject('message')\n</script>\n```\n\n如果提供的值是一个 ref，注入进来的会是该 ref 对象，而**不会**自动解包为其内部的值。这使得注入方组件能够通过 ref 对象保持了和供给方的响应性链接。\n\n[带有响应性的 provide + inject 完整示例](https://play.vuejs.org/#eNqFUUFugzAQ/MrKF1IpxfeIVKp66Kk/8MWFDXYFtmUbpArx967BhURRU9/WOzO7MzuxV+fKcUB2YlWovXYRAsbBvQije2d9hAk8Xo7gvB11gzDDxdseCuIUG+ZN6a7JjZIvVRIlgDCcw+d3pmvTglz1okJ499I0C3qB1dJQT9YRooVaSdNiACWdQ5OICj2WwtTWhAg9hiBbhHNSOxQKu84WT8LkNQ9FBhTHXyg1K75aJHNUROxdJyNSBVBp44YI43NvG+zOgmWWYGt7dcipqPhGZEe2ef07wN3lltD+lWN6tNkV/37+rdKjK2rzhRTt7f3u41xhe37/xJZGAL2PLECXa9NKdD/a6QTTtGnP88LgiXJtYv4BaLHhvg==)\n\n同样的，如果没有使用 `<script setup>`，`inject()` 需要在 `setup()` 内同步调用：\n\n```js\nimport { inject } from 'vue'\n\nexport default {\n  setup() {\n    const message = inject('message')\n    return { message }\n  }\n}\n```\n\n</div>\n\n<div class=\"options-api\">\n\n要注入上层组件提供的数据，需使用 [`inject`](/api/options-composition#inject) 选项来声明：\n\n```js\nexport default {\n  inject: ['message'],\n  created() {\n    console.log(this.message) // injected value\n  }\n}\n```\n\n注入会在组件自身的状态**之前**被解析，因此你可以在 `data()` 中访问到注入的属性：\n\n```js\nexport default {\n  inject: ['message'],\n  data() {\n    return {\n      // 基于注入值的初始数据\n      fullMessage: this.message\n    }\n  }\n}\n```\n\n[完整的 provide + inject 示例](https://play.vuejs.org/#eNqNkcFqwzAQRH9l0EUthOhuRKH00FO/oO7B2JtERZaEvA4F43+vZCdOTAIJCImRdpi32kG8h7A99iQKobs6msBvpTNt8JHxcTC2wS76FnKrJpVLZelKR39TSUO7qreMoXRA7ZPPkeOuwHByj5v8EqI/moZeXudCIBL30Z0V0FLXVXsqIA9krU8R+XbMR9rS0mqhS4KpDbZiSgrQc5JKQqvlRWzEQnyvuc9YuWbd4eXq+TZn0IvzOeKr8FvsNcaK/R6Ocb9Uc4FvefpE+fMwP0wH8DU7wB77nIo6x6a2hvNEME5D0CpbrjnHf+8excI=)\n\n### 注入别名 \\* {#injection-aliasing}\n\n当以数组形式使用 `inject`，注入的属性会以同名的 key 暴露到组件实例上。在上面的例子中，提供的属性名为 `\"message\"`，注入后以 `this.message` 的形式暴露。访问的本地属性名和注入名是相同的。\n\n如果我们想要用一个不同的本地属性名注入该属性，我们需要在 `inject` 选项的属性上使用对象的形式：\n\n```js\nexport default {\n  inject: {\n    /* 本地属性名 */ localMessage: {\n      from: /* 注入来源名 */ 'message'\n    }\n  }\n}\n```\n\n这里，组件本地化了原注入名 `\"message\"` 所提供的属性，并将其暴露为 `this.localMessage`。\n\n</div>",
          "questions": [
            "`provide` 和 `inject` 可以解决什么问题？",
            "在组件中如何使用 `provide`？",
            "`provide` 函数接收几个参数？分别是什么？",
            "`provide` 可以提供哪些类型的值？",
            "如何在应用层面提供依赖？",
            "在组件中如何使用 `inject`？",
            "`inject` 函数接收几个参数？分别是什么？",
            "如果提供的值是一个 ref，注入进来的是什么？",
            "如何在 `inject` 中使用别名？",
            "`inject` 会在组件自身的状态之前被解析，这意味着什么？"
          ]
        },
        {
          "content": "### 注入默认值 {#injection-default-values}\n\n默认情况下，`inject` 假设传入的注入名会被某个祖先链上的组件提供。如果该注入名的确没有任何组件提供，则会抛出一个运行时警告。\n\n如果在注入一个值时不要求必须有提供者，那么我们应该声明一个默认值，和 props 类似：\n\n<div class=\"composition-api\">\n\n```js\n// 如果没有祖先组件提供 \"message\"\n// `value` 会是 \"这是默认值\"\nconst value = inject('message', '这是默认值')\n```\n\n在一些场景中，默认值可能需要通过调用一个函数或初始化一个类来取得。为了避免在用不到默认值的情况下进行不必要的计算或产生副作用，我们可以使用工厂函数来创建默认值：\n\n```js\nconst value = inject('key', () => new ExpensiveClass(), true)\n```\n\n第三个参数表示默认值应该被当作一个工厂函数。\n\n</div>\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  // 当声明注入的默认值时\n  // 必须使用对象形式\n  inject: {\n    message: {\n      from: 'message', // 当与原注入名同名时，这个属性是可选的\n      default: 'default value'\n    },\n    user: {\n      // 对于非基础类型数据，如果创建开销比较大，或是需要确保每个组件实例\n      // 需要独立数据的，请使用工厂函数\n      default: () => ({ name: 'John' })\n    }\n  }\n}\n```\n\n</div>\n\n## 和响应式数据配合使用 {#working-with-reactivity}\n\n<div class=\"composition-api\">\n\n当提供 / 注入响应式的数据时，**建议尽可能将任何对响应式状态的变更都保持在供给方组件中**。这样可以确保所提供状态的声明和变更操作都内聚在同一个组件内，使其更容易维护。\n\n有的时候，我们可能需要在注入方组件中更改数据。在这种情况下，我们推荐在供给方组件内声明并提供一个更改数据的方法函数：\n\n```vue{7-9,13}\n<!-- 在供给方组件内 -->\n<script setup>\nimport { provide, ref } from 'vue'\n\nconst location = ref('North Pole')\n\nfunction updateLocation() {\n  location.value = 'South Pole'\n}\n\nprovide('location', {\n  location,\n  updateLocation\n})\n</script>\n```\n\n```vue{5}\n<!-- 在注入方组件 -->\n<script setup>\nimport { inject } from 'vue'\n\nconst { location, updateLocation } = inject('location')\n</script>\n\n<template>\n  <button @click=\"updateLocation\">{{ location }}</button>\n</template>\n```\n\n最后，如果你想确保提供的数据不能被注入方的组件更改，你可以使用 [`readonly()`](/api/reactivity-core#readonly) 来包装提供的值。\n\n```vue\n<script setup>\nimport { ref, provide, readonly } from 'vue'\n\nconst count = ref(0)\nprovide('read-only-count', readonly(count))\n</script>\n```\n\n</div>\n\n<div class=\"options-api\">\n\n为保证注入方和供给方之间的响应性链接，我们需要使用 [computed()](/api/reactivity-core#computed) 函数提供一个计算属性：\n\n```js{10}\nimport { computed } from 'vue'\n\nexport default {\n  data() {\n    return {\n      message: 'hello!'\n    }\n  },\n  provide() {\n    return {\n      // 显式提供一个计算属性\n      message: computed(() => this.message)\n    }\n  }\n}\n```\n\n[带有响应性的 provide + inject 完整示例](https://play.vuejs.org/#eNqNUctqwzAQ/JVFFyeQxnfjBEoPPfULqh6EtYlV9EKWTcH43ytZtmPTQA0CsdqZ2dlRT16tPXctkoKUTeWE9VeqhbLGeXirheRwc0ZBds7HKkKzBdBDZZRtPXIYJlzqU40/I4LjjbUyIKmGEWw0at8UgZrUh1PscObZ4ZhQAA596/RcAShsGnbHArIapTRBP74O8Up060wnOO5QmP0eAvZyBV+L5jw1j2tZqsMp8yWRUHhUVjKPoQIohQ460L0ow1FeKJlEKEnttFweijJfiORElhCf5f3umObb0B9PU/I7kk17PJj7FloN/2t7a2Pj/Zkdob+x8gV8ZlMs2de/8+14AXwkBngD9zgVqjg2rNXPvwjD+EdlHilrn8MvtvD1+Q==)\n\n`computed()` 函数常用于组合式 API 风格的组件中，但它同样还可以用于补充选项式 API 风格的某些用例。你可以通过阅读[响应式系统基础](/guide/essentials/reactivity-fundamentals)和[计算属性](/guide/essentials/computed)两个章节了解更多组合式的 API 风格。\n\n:::warning 临时配置要求\n上面的用例需要设置 `app.config.unwrapInjectedRef = true` 以保证注入会自动解包这个计算属性。这将会在 Vue 3.3 后成为一个默认行为，而我们暂时在此告知此项配置以避免后续升级对代码的破坏性。在 3.3 后就不需要这样做了。\n:::\n\n</div>\n\n## 使用 Symbol 作注入名 {#working-with-symbol-keys}\n\n至此，我们已经了解了如何使用字符串作为注入名。但如果你正在构建大型的应用，包含非常多的依赖提供，或者你正在编写提供给其他开发者使用的组件库，建议最好使用 Symbol 来作为注入名以避免潜在的冲突。\n\n我们通常推荐在一个单独的文件中导出这些注入名 Symbol：\n\n```js\n// keys.js\nexport const myInjectionKey = Symbol()\n```\n\n<div class=\"composition-api\">\n\n```js\n// 在供给方组件中\nimport { provide } from 'vue'\nimport { myInjectionKey } from './keys.js'\n\nprovide(myInjectionKey, { /*\n  要提供的数据\n*/ });\n```\n\n```js\n// 注入方组件\nimport { inject } from 'vue'\nimport { myInjectionKey } from './keys.js'\n\nconst injected = inject(myInjectionKey)\n```\n\nTypeScript 用户请参考：[为 Provide / Inject 标注类型](/guide/typescript/composition-api#typing-provide-inject) <sup class=\"vt-badge ts\" />\n\n</div>\n\n<div class=\"options-api\">\n\n```js\n// 在供给方组件中\nimport { myInjectionKey } from './keys.js'\n\nexport default {\n  provide() {\n    return {\n      [myInjectionKey]: {\n        /* 要提供的数据 */\n      }\n    }\n  }\n}\n```\n\n```js\n// 注入方组件\nimport { myInjectionKey } from './keys.js'\n\nexport default {\n  inject: {\n    injected: { from: myInjectionKey }\n  }\n}\n```\n\n</div>\n\n<small>\n\n__译者注__\n\n<a id=\"footnote-1\"></a>[1] 在本章及后续章节中，“**提供**”将成为对应 Provide 的一个专有概念\n\n</small>",
          "questions": [
            "`inject` 默认情况下假设传入的注入名会被哪个组件提供？",
            "如果注入一个值时不要求必须有提供者，应该如何声明默认值？",
            "在一些场景中，默认值可能需要通过什么方式来取得？",
            "为什么建议尽可能将任何对响应式状态的变更都保持在供给方组件中？",
            "如果需要在注入方组件中更改数据，应该如何做？",
            "如何确保提供的数据不能被注入方的组件更改？",
            "在使用响应式数据时，为保证注入方和供给方之间的响应性链接，需要使用什么函数提供一个计算属性？",
            "在构建大型的应用或编写提供给其他开发者使用的组件库时，为什么建议使用 Symbol 来作为注入名？",
            "如何使用 Symbol 作为注入名？",
            "TypeScript 用户在使用 Provide / Inject 时需要注意什么？"
          ]
        }
      ]
    },
    {
      "file_name": "attrs.md",
      "question_count": 10,
      "documents": [
        {
          "content": "---\noutline: deep\n---\n\n# 透传 Attributes {#fallthrough-attributes}\n\n> 此章节假设你已经看过了[组件基础](/guide/essentials/component-basics)。若你还不了解组件是什么，请先阅读该章节。\n\n## Attributes 继承 {#attribute-inheritance}\n\n“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 [props](./props) 或 [emits](./events#defining-custom-events) 的 attribute 或者 `v-on` 事件监听器。最常见的例子就是 `class`、`style` 和 `id`。\n\n当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上。举例来说，假如我们有一个 `<MyButton>` 组件，它的模板长这样：\n\n```vue-html\n<!-- <MyButton> 的模板 -->\n<button>click me</button>\n```\n\n一个父组件使用了这个组件，并且传入了 `class`：\n\n```vue-html\n<MyButton class=\"large\" />\n```\n\n最后渲染出的 DOM 结果是：\n\n```html\n<button class=\"large\">click me</button>\n```\n\n这里，`<MyButton>` 并没有将 `class` 声明为一个它所接受的 prop，所以 `class` 被视作透传 attribute，自动透传到了 `<MyButton>` 的根元素上。\n\n### 对 `class` 和 `style` 的合并 {#class-and-style-merging}\n\n如果一个子组件的根元素已经有了 `class` 或 `style` attribute，它会和从父组件上继承的值合并。如果我们将之前的 `<MyButton>` 组件的模板改成这样：\n\n```vue-html\n<!-- <MyButton> 的模板 -->\n<button class=\"btn\">click me</button>\n```\n\n则最后渲染出的 DOM 结果会变成：\n\n```html\n<button class=\"btn large\">click me</button>\n```\n\n### `v-on` 监听器继承 {#v-on-listener-inheritance}\n\n同样的规则也适用于 `v-on` 事件监听器：\n\n```vue-html\n<MyButton @click=\"onClick\" />\n```\n\n`click` 监听器会被添加到 `<MyButton>` 的根元素，即那个原生的 `<button>` 元素之上。当原生的 `<button>` 被点击，会触发父组件的 `onClick` 方法。同样的，如果原生 `button` 元素自身也通过 `v-on` 绑定了一个事件监听器，则这个监听器和从父组件继承的监听器都会被触发。\n\n### 深层组件继承 {#nested-component-inheritance}\n\n有些情况下一个组件会在根节点上渲染另一个组件。例如，我们重构一下 `<MyButton>`，让它在根节点上渲染 `<BaseButton>`：\n\n```vue-html\n<!-- <MyButton/> 的模板，只是渲染另一个组件 -->\n<BaseButton />\n```\n\n此时 `<MyButton>` 接收的透传 attribute 会直接继续传给 `<BaseButton>`。\n\n请注意：\n\n1. 透传的 attribute 不会包含 `<MyButton>` 上声明过的 props 或是针对 `emits` 声明事件的 `v-on` 侦听函数，换句话说，声明过的 props 和侦听函数被 `<MyButton>`“消费”了。\n\n2. 透传的 attribute 若符合声明，也可以作为 props 传入 `<BaseButton>`。\n\n## 禁用 Attributes 继承 {#disabling-attribute-inheritance}\n\n如果你**不想要**一个组件自动地继承 attribute，你可以在组件选项中设置 `inheritAttrs: false`。\n\n<div class=\"composition-api\">\n\n 从 3.3 开始你也可以直接在 `<script setup>` 中使用 [`defineOptions`](/api/sfc-script-setup#defineoptions)：\n\n```vue\n<script setup>\ndefineOptions({\n  inheritAttrs: false\n})\n// ...setup 逻辑\n</script>\n```\n\n</div>\n\n最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 `inheritAttrs` 选项为 `false`，你可以完全控制透传进来的 attribute 被如何使用。\n\n这些透传进来的 attribute 可以在模板的表达式中直接用 `$attrs` 访问到。\n\n```vue-html\n<span>Fallthrough attribute: {{ $attrs }}</span>\n```\n\n这个 `$attrs` 对象包含了除组件所声明的 `props` 和 `emits` 之外的所有其他 attribute，例如 `class`，`style`，`v-on` 监听器等等。\n\n有几点需要注意：\n\n- 和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 `foo-bar` 这样的一个 attribute 需要通过 `$attrs['foo-bar']` 来访问。\n\n- 像 `@click` 这样的一个 `v-on` 事件监听器将在此对象下被暴露为一个函数 `$attrs.onClick`。\n\n现在我们要再次使用一下[之前小节](#attribute-inheritance)中的 `<MyButton>` 组件例子。有时候我们可能为了样式，需要在 `<button>` 元素外包装一层 `<div>`：\n\n```vue-html\n<div class=\"btn-wrapper\">\n  <button class=\"btn\">click me</button>\n</div>\n```\n\n我们想要所有像 `class` 和 `v-on` 监听器这样的透传 attribute 都应用在内部的 `<button>` 上而不是外层的 `<div>` 上。我们可以通过设定 `inheritAttrs: false` 和使用 `v-bind=\"$attrs\"` 来实现：\n\n```vue-html{2}\n<div class=\"btn-wrapper\">\n  <button class=\"btn\" v-bind=\"$attrs\">click me</button>\n</div>\n```\n\n小提示：[没有参数的 `v-bind`](/guide/essentials/template-syntax#dynamically-binding-multiple-attributes) 会将一个对象的所有属性都作为 attribute 应用到目标元素上。\n\n## 多根节点的 Attributes 继承 {#attribute-inheritance-on-multiple-root-nodes}\n\n和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 `$attrs` 没有被显式绑定，将会抛出一个运行时警告。\n\n```vue-html\n<CustomLayout id=\"custom-layout\" @click=\"changeValue\" />\n```\n\n如果 `<CustomLayout>` 有下面这样的多根节点模板，由于 Vue 不知道要将 attribute 透传到哪里，所以会抛出一个警告。\n\n```vue-html\n<header>...</header>\n<main>...</main>\n<footer>...</footer>\n```\n\n如果 `$attrs` 被显式绑定，则不会有警告：\n\n```vue-html{2}\n<header>...</header>\n<main v-bind=\"$attrs\">...</main>\n<footer>...</footer>\n```\n\n## 在 JavaScript 中访问透传 Attributes {#accessing-fallthrough-attributes-in-javascript}\n\n<div class=\"composition-api\">\n\n如果需要，你可以在 `<script setup>` 中使用 `useAttrs()` API 来访问一个组件的所有透传 attribute：\n\n```vue\n<script setup>\nimport { useAttrs } from 'vue'\n\nconst attrs = useAttrs()\n</script>\n```\n\n如果没有使用 `<script setup>`，`attrs` 会作为 `setup()` 上下文对象的一个属性暴露：\n\n```js\nexport default {\n  setup(props, ctx) {\n    // 透传 attribute 被暴露为 ctx.attrs\n    console.log(ctx.attrs)\n  }\n}\n```\n\n需要注意的是，虽然这里的 `attrs` 对象总是反映为最新的透传 attribute，但它并不是响应式的 (考虑到性能因素)。你不能通过侦听器去监听它的变化。如果你需要响应性，可以使用 prop。或者你也可以使用 `onUpdated()` 使得在每次更新时结合最新的 `attrs` 执行副作用。\n\n</div>\n\n<div class=\"options-api\">\n\n如果需要，你可以通过 `$attrs` 这个实例属性来访问组件的所有透传 attribute：\n\n```js\nexport default {\n  created() {\n    console.log(this.$attrs)\n  }\n}\n```\n\n</div>",
          "questions": [
            "什么是透传 attribute？",
            "透传 attribute 会被自动添加到哪个元素上？",
            "什么情况下会发生透传 attribute 的合并？",
            "透传 attribute 是否包含组件声明的 props 和 emits？",
            "如果不想让组件自动继承 attribute，应该如何设置组件选项？",
            "如何在模板中访问透传 attribute？",
            "有多个根节点的组件是否会自动继承 attribute？",
            "如果一个组件有多个根节点，如何让透传 attribute 正确地应用到目标元素上？",
            "在 JavaScript 中如何访问透传 attribute？",
            "透传 attribute 是否是响应式的？"
          ]
        }
      ]
    },
    {
      "file_name": "slots.md",
      "question_count": 50,
      "documents": [
        {
          "content": "# 插槽 Slots {#slots}\n\n> 此章节假设你已经看过了[组件基础](/guide/essentials/component-basics)。若你还不了解组件是什么，请先阅读该章节。\n\n## 插槽内容与出口 {#slot-content-and-outlet}\n\n在之前的章节中，我们已经了解到组件能够接收任意类型的 JavaScript 值作为 props，但组件要如何接收模板内容呢？在某些场景中，我们可能想要为子组件传递一些模板片段，让子组件在它们的组件中渲染这些片段。\n\n举例来说，这里有一个 `<FancyButton>` 组件，可以像这样使用：\n\n```vue-html{2}\n<FancyButton>\n  Click me! <!-- 插槽内容 -->\n</FancyButton>\n```\n\n而 `<FancyButton>` 的模板是这样的：\n\n```vue-html{2}\n<button class=\"fancy-btn\">\n  <slot></slot> <!-- 插槽出口 -->\n</button>\n```\n\n`<slot>` 元素是一个**插槽出口** (slot outlet)，标示了父元素提供的**插槽内容** (slot content) 将在哪里被渲染。\n\n![插槽图示](./images/slots.png)\n\n<!-- https://www.figma.com/file/LjKTYVL97Ck6TEmBbstavX/slot -->\n\n最终渲染出的 DOM 是这样：\n\n```html\n<button class=\"fancy-btn\">Click me!</button>\n```\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpdUdlqAyEU/ZVbQ0kLMdNsXabTQFvoV8yLcRkkjopLSQj596oTwqRvnuM9y9UT+rR2/hs5qlHjqZM2gOch2m2rZW+NC/BDND1+xRCMBuFMD9N5NeKyeNrqphrUSZdA4L1VJPCEAJrRdCEAvpWke+g5NHcYg1cmADU6cB0A4zzThmYckqimupqiGfpXILe/zdwNhaki3n+0SOR5vAu6ReU++efUajtqYGJQ/FIg5w8Wt9FlOx+OKh/nV1c4ZVNqlHE1TIQQ7xnvCN13zkTNalBSc+Jw5wiTac2H1WLDeDeDyXrJVm9LWG7uE3hev3AhHge1cYwnO200L4QljEnd1bCxB1g82UNhe+I6qQs5kuGcE30NrxeaRudzOWtkemeXuHP5tLIKOv8BN+mw3w==)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpdUdtOwzAM/RUThAbSurIbl1ImARJf0ZesSapoqROlKdo07d9x0jF1SHmIT+xzcY7sw7nZTy9Zwcqu9tqFTYW6ddYH+OZYHz77ECyC8raFySwfYXFsUiFAhXKfBoRUvDcBjhGtLbGgxNAVcLziOlVIp8wvelQE2TrDg6QKoBx1JwDgy+h6B62E8ibLoDM2kAAGoocsiz1VKMfmCCrzCymbsn/GY95rze1grja8694rpmJ/tg1YsfRO/FE134wc2D4YeTYQ9QeKa+mUrgsHE6+zC+vfjoz1Bdwqpd5iveX1rvG2R1GA0Si5zxrPhaaY98v5WshmCrerhVi+LmCxvqPiafUslXoYpq0XkuiQ1p4Ax4XQ2BSwdnuYP7p9QlvuG40JHI1lUaenv3o5w3Xvu2jOWU179oQNn5aisNMvLBvDOg==)\n\n</div>\n\n通过使用插槽，`<FancyButton>` 仅负责渲染外层的 `<button>` (以及相应的样式)，而其内部的内容由父组件提供。\n\n理解插槽的另一种方式是和下面的 JavaScript 函数作类比，其概念是类似的：\n\n```js\n// 父元素传入插槽内容\nFancyButton('Click me!')\n\n// FancyButton 在自己的模板中渲染插槽内容\nfunction FancyButton(slotContent) {\n  return `<button class=\"fancy-btn\">\n      ${slotContent}\n    </button>`\n}\n```\n\n插槽内容可以是任意合法的模板内容，不局限于文本。例如我们可以传入多个元素，甚至是组件：\n\n```vue-html\n<FancyButton>\n  <span style=\"color:red\">Click me!</span>\n  <AwesomeIcon name=\"plus\" />\n</FancyButton>\n```\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp1UmtOwkAQvspQYtCEgrx81EqCJibeoX+W7bRZaHc3+1AI4QyewH8ewvN4Aa/gbgtNIfFf5+vMfI/ZXbCQcvBmMYiCWFPFpAGNxsp5wlkphTLwQjjdPlljBIdMiRJ6g2EL88O9pnnxjlqU+EpbzS3s0BwPaypH4gqDpSyIQVcBxK3VFQDwXDC6hhJdlZi4zf3fRKwl4aDNtsDHJKCiECqiW8KTYH5c1gEnwnUdJ9rCh/XeM6Z42AgN+sFZAj6+Ux/LOjFaEK2diMz3h0vjNfj/zokuhPFU3lTdfcpShVOZcJ+DZgHs/HxtCrpZlj34eknoOlfC8jSCgnEkKswVSRlyczkZzVLM+9CdjtPJ/RjGswtX3ExvMcuu6mmhUnTruOBYAZKkKeN5BDO5gdG13FRoSVTOeAW2xkLPY3UEdweYWqW9OCkYN6gctq9uXllx2Z09CJ9dJwzBascI7nBYihWDldUGMqEgdTVIq6TQqCEMfUpNSD+fX7/fH+3b7P8AdGP6wA==)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNptUltu2zAQvMpGQZEWsOzGiftQ1QBpgQK9g35oaikwkUiCj9aGkTPkBPnLIXKeXCBXyJKKBdoIoA/tYGd3doa74tqY+b+ARVXUjltp/FWj5GC09fCHKb79FbzXCoTVA5zNFxkWaWdT8/V/dHrAvzxrzrC3ZoBG4SYRWhQs9B52EeWapihU3lWwyxfPDgbfNYq+ejEppcLjYHrmkSqAOqMmAOB3L/ktDEhV4+v8gMR/l1M7wxQ4v+3xZ1Nw3Wtb8S1TTXG1H3cCJIO69oxc5mLUcrSrXkxSi1lxZGT0//CS9Wg875lzJELE/nLto4bko69dr31cFc8auw+3JHvSEfQ7nwbsHY9HwakQ4kes14zfdlYH1VbQS4XMlp1lraRMPl6cr1rsZnB6uWwvvi9hufpAxZfLryjEp5GtbYs0TlGICTCsbaXqKliZDZx/NpuEDsx2UiUwo5VxT6Dkv73BPFgXxRktlUdL2Jh6OoW8O3pX0buTsoTgaCNQcDjoGwk3wXkQ2tJLGzSYYI126KAso0uTSc8Pjy9P93k2d6+NyRKa)\n\n</div>\n\n通过使用插槽，`<FancyButton>` 组件更加灵活和具有可复用性。现在组件可以用在不同的地方渲染各异的内容，但同时还保证都具有相同的样式。\n\nVue 组件的插槽机制是受[原生 Web Component `<slot>` 元素](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot)的启发而诞生，同时还做了一些功能拓展，这些拓展的功能我们后面会学习到。\n\n## 渲染作用域 {#render-scope}\n\n插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。举例来说：\n\n```vue-html\n<span>{{ message }}</span>\n<FancyButton>{{ message }}</FancyButton>\n```\n\n这里的两个 <span v-pre>`{{ message }}`</span> 插值表达式渲染的内容都是一样的。\n\n插槽内容**无法访问**子组件的数据。Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则是一致的。换言之：\n\n> 父组件模板中的表达式只能访问父组件的作用域；子组件模板中的表达式只能访问子组件的作用域。",
          "questions": [
            "插槽出口和插槽内容分别是什么？",
            "插槽内容可以是什么类型的内容？",
            "插槽的作用是什么？",
            "插槽内容可以访问到哪些作用域？",
            "插槽内容能否访问子组件的数据？",
            "插槽的机制是受什么启发而诞生的？",
            "插槽的机制相比原生 Web Component `<slot>` 元素有哪些拓展功能？",
            "为什么使用插槽可以使组件更加灵活和具有可复用性？",
            "插槽的使用场景有哪些？",
            "Vue 模板中的表达式只能访问其定义时所处的作用域，这句话的含义是什么？"
          ]
        },
        {
          "content": "## 默认内容 {#fallback-content}\n\n在外部没有提供任何内容的情况下，可以为插槽指定默认内容。比如有这样一个 `<SubmitButton>` 组件：\n\n```vue-html\n<button type=\"submit\">\n  <slot></slot>\n</button>\n```\n\n如果我们想在父组件没有提供任何插槽内容时在 `<button>` 内渲染“Submit”，只需要将“Submit”写在 `<slot>` 标签之间来作为默认内容：\n\n```vue-html{3}\n<button type=\"submit\">\n  <slot>\n    Submit <!-- 默认内容 -->\n  </slot>\n</button>\n```\n\n现在，当我们在父组件中使用 `<SubmitButton>` 且没有提供任何插槽内容时：\n\n```vue-html\n<SubmitButton />\n```\n\n“Submit”将会被作为默认内容渲染：\n\n```html\n<button type=\"submit\">Submit</button>\n```\n\n但如果我们提供了插槽内容：\n\n```vue-html\n<SubmitButton>Save</SubmitButton>\n```\n\n那么被显式提供的内容会取代默认内容：\n\n```html\n<button type=\"submit\">Save</button>\n```\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp1kMsKwjAQRX9lzMaNbfcSC/oL3WbT1ikU8yKZFEX8d5MGgi2YVeZxZ86dN7taWy8B2ZlxP7rZEnikYFuhZ2WNI+jCoGa6BSKjYXJGwbFufpNJfhSaN1kflTEgVFb2hDEC4IeqguARpl7KoR8fQPgkqKpc3Wxo1lxRWWeW+Y4wBk9x9V9d2/UL8g1XbOJN4WAntodOnrecQ2agl8WLYH7tFyw5olj10iR3EJ+gPCxDFluj0YS6EAqKR8mi9M3Td1ifLxWShcU=)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp1UEEOwiAQ/MrKxYu1d4Mm+gWvXChuk0YKpCyNxvh3lxIb28SEA8zuDDPzEucQ9mNCcRAymqELdFKu64MfCK6p6Tu6JCLvoB18D9t9/Qtm4lY5AOXwMVFu2OpkCV4ZNZ51HDqKhwLAQjIjb+X4yHr+mh+EfbCakF8AclNVkCJCq61ttLkD4YOgqsp0YbGesJkVBj92NwSTIrH3v7zTVY8oF8F4SdazD7ET69S5rqXPpnigZ8CjEnHaVyInIp5G63O6XIGiIlZMzrGMd8RVfR0q4lIKKV+L+srW+wNTTZq3)\n\n</div>\n\n## 具名插槽 {#named-slots}\n\n有时在一个组件中包含多个插槽出口是很有用的。举例来说，在一个 `<BaseLayout>` 组件中，有如下模板：\n\n```vue-html\n<div class=\"container\">\n  <header>\n    <!-- 标题内容放这里 -->\n  </header>\n  <main>\n    <!-- 主要内容放这里 -->\n  </main>\n  <footer>\n    <!-- 底部内容放这里 -->\n  </footer>\n</div>\n```\n\n对于这种场景，`<slot>` 元素可以有一个特殊的 attribute `name`，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容：\n\n```vue-html\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n\n这类带 `name` 的插槽被称为具名插槽 (named slots)。没有提供 `name` 的 `<slot>` 出口会隐式地命名为“default”。\n\n在父组件中使用 `<BaseLayout>` 时，我们需要一种方式将多个插槽内容传入到各自目标插槽的出口。此时就需要用到**具名插槽**了：\n\n要为具名插槽传入内容，我们需要使用一个含 `v-slot` 指令的 `<template>` 元素，并将目标插槽的名字传给该指令：\n\n```vue-html\n<BaseLayout>\n  <template v-slot:header>\n    <!-- header 插槽的内容放这里 -->\n  </template>\n</BaseLayout>\n```\n\n`v-slot` 有对应的简写 `#`，因此 `<template v-slot:header>` 可以简写为 `<template #header>`。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。\n\n![具名插槽图示](./images/named-slots.png)\n\n<!-- https://www.figma.com/file/2BhP8gVZevttBu9oUmUUyz/named-slot -->\n\n下面我们给出完整的、向 `<BaseLayout>` 传递插槽内容的代码，指令均使用的是缩写形式：\n\n```vue-html\n<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <template #default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>\n```\n\n当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非 `<template>` 节点都被隐式地视为默认插槽的内容。所以上面也可以写成：\n\n```vue-html\n<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <!-- 隐式的默认插槽 -->\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>\n```\n\n现在 `<template>` 元素中的所有内容都将被传递到相应的插槽。最终渲染出的 HTML 如下：\n\n```html\n<div class=\"container\">\n  <header>\n    <h1>Here might be a page title</h1>\n  </header>\n  <main>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </main>\n  <footer>\n    <p>Here's some contact info</p>\n  </footer>\n</div>\n```\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9UsFuwjAM/RWrHLgMOi5o6jIkdtphn9BLSF0aKU2ixEVjiH+fm8JoQdvRfu/5xS8+ZVvvl4cOsyITUQXtCSJS5zel1a13geBdRvyUR9cR1MG1MF/mt1YvnZdW5IOWVVwQtt5IQq4AxI2cau5ccZg1KCsMlz4jzWrzgQGh1fuGYIcgwcs9AmkyKHKGLyPykcfD1Apr2ZmrHUN+s+U5Qe6D9A3ULgA1bCK1BeUsoaWlyPuVb3xbgbSOaQGcxRH8v3XtHI0X8mmfeYToWkxmUhFoW7s/JvblJLERmj1l0+T7T5tqK30AZWSMb2WW3LTFUGZXp/u8o3EEVrbI9AFjLn8mt38fN9GIPrSp/p4/Yoj7OMZ+A/boN9KInPeZZpAOLNLRDAsPZDgN4p0L/NQFOV/Ayn9x6EZXMFNKvQ4E5YwLBczW6/WlU3NIi6i/sYDn5Qu2qX1OF51MsvMPkrIEHg==)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9UkFuwjAQ/MoqHLiUpFxQlaZI9NRDn5CLSTbEkmNb9oKgiL934wRwQK3ky87O7njGPicba9PDHpM8KXzlpKV1qWVnjSP4FB6/xcnsCRpnOpin2R3qh+alBig1HgO9xkbsFcG5RyvDOzRq8vkAQLSury+l5lNkN1EuCDurBCFXAMWdH2pGrn2YtShqdCPOnXa5/kKH0MldS7BFEGDFDoEkKSwybo8rskjjaevo4L7Wrje8x4mdE7aFxjiglkWE1GxQE9tLi8xO+LoGoQ3THLD/qP2/dGMMxYZs8DP34E2HQUxUBFI35o+NfTlJLOomL8n04frXns7W8gCVEt5/lElQkxpdmVyVHvP2yhBo0SHThx5z+TEZvl1uMlP0oU3nH/kRo3iMI9Ybes960UyRsZ9pBuGDeTqpwfBAvn7NrXF81QUZm8PSHjl0JWuYVVX1PhAqo4zLYbZarUak4ZAWXv5gDq/pG3YBHn50EEkuv5irGBk=)\n\n</div>\n\n使用 JavaScript 函数来类比可能更有助于你来理解具名插槽：\n\n```js\n// 传入不同的内容给不同名字的插槽\nBaseLayout({\n  header: `...`,\n  default: `...`,\n  footer: `...`\n})\n\n// <BaseLayout> 渲染插槽内容到对应位置\nfunction BaseLayout(slots) {\n  return `<div class=\"container\">\n      <header>${slots.header}</header>\n      <main>${slots.default}</main>\n      <footer>${slots.footer}</footer>\n    </div>`\n}\n```",
          "questions": [
            "什么是默认内容？如何为插槽指定默认内容？",
            "什么是具名插槽？如何为具名插槽传入内容？",
            "插槽有哪些特殊的属性？它们分别有什么作用？",
            "如果一个组件同时接收默认插槽和具名插槽，它们的渲染顺序是怎样的？",
            "在父组件中使用 `<template>` 元素传递插槽内容时，`v-slot` 指令有哪些缩写形式？",
            "如果一个组件中有多个插槽，但父组件只传递了部分插槽内容，未传递的插槽会如何渲染？",
            "除了使用 `<template>` 元素传递插槽内容，还有哪些方式可以传递？",
            "如果一个组件中有多个具名插槽，但父组件只传递了部分插槽内容，未传递的插槽会如何渲染？",
            "在具名插槽中，是否可以使用默认插槽？反之亦然？",
            "在使用具名插槽时，是否可以省略 `v-slot` 指令？"
          ]
        },
        {
          "content": "## 动态插槽名 {#dynamic-slot-names}\n\n[动态指令参数](/guide/essentials/template-syntax.md#dynamic-arguments)在 `v-slot` 上也是有效的，即可以定义下面这样的动态插槽名：\n\n```vue-html\n<base-layout>\n  <template v-slot:[dynamicSlotName]>\n    ...\n  </template>\n\n  <!-- 缩写为 -->\n  <template #[dynamicSlotName]>\n    ...\n  </template>\n</base-layout>\n```\n\n注意这里的表达式和动态指令参数受相同的[语法限制](/guide/essentials/template-syntax#directives)。\n\n## 作用域插槽 {#scoped-slots}\n\n在上面的[渲染作用域](#render-scope)中我们讨论到，插槽的内容无法访问到子组件的状态。\n\n然而在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。\n\n我们也确实有办法这么做！可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes：\n\n```vue-html\n<!-- <MyComponent> 的模板 -->\n<div>\n  <slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>\n```\n\n当需要接收插槽 props 时，默认插槽和具名插槽的使用方式有一些小区别。下面我们将先展示默认插槽如何接受 props，通过子组件标签上的 `v-slot` 指令，直接接收到了一个插槽 props 对象：\n\n```vue-html\n<MyComponent v-slot=\"slotProps\">\n  {{ slotProps.text }} {{ slotProps.count }}\n</MyComponent>\n```\n\n![scoped slots diagram](./images/scoped-slots.svg)\n\n<!-- https://www.figma.com/file/QRneoj8eIdL1kw3WQaaEyc/scoped-slot -->\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9kMEKgzAMhl8l9OJlU3aVOhg7C3uAXsRlTtC2tFE2pO++dA5xMnZqk+b/8/2dxMnadBxQ5EL62rWWwCMN9qh021vjCMrn2fBNoya4OdNDkmarXhQnSstsVrOOC8LedhVhrEiuHca97wwVSsTj4oz1SvAUgKJpgqWZEj4IQoCvZm0Gtgghzss1BDvIbFkqdmID+CNdbbQnaBwitbop0fuqQSgguWPXmX+JePe1HT/QMtJBHnE51MZOCcjfzPx04JxsydPzp2Szxxo7vABY1I/p)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqFkNFqxCAQRX9l8CUttAl9DbZQ+rzQD/AlJLNpwKjoJGwJ/nvHpAnusrAg6FzHO567iE/nynlCUQsZWj84+lBmGJ31BKffL8sng4bg7O0IRVllWnpWKAOgDF7WBx2em0kTLElt975QbwLkhkmIyvCS1TGXC8LR6YYwVSTzH8yvQVt6VyJt3966oAR38XhaFjjEkvBCECNcia2d2CLyOACZQ7CDrI6h4kXcAF7lcg+za6h5et4JPdLkzV4B9B6RBtOfMISmxxqKH9TarrGtATxMgf/bDfM/qExEUCdEDuLGXAmoV06+euNs2JK7tyCrzSNHjX9aurQf)\n\n</div>\n\n子组件传入插槽的 props 作为了 `v-slot` 指令的值，可以在插槽内的表达式中访问。\n\n你可以将作用域插槽类比为一个传入子组件的函数。子组件会将相应的 props 作为参数传给它：\n\n```js\nMyComponent({\n  // 类比默认插槽，将其想成一个函数\n  default: (slotProps) => {\n    return `${slotProps.text} ${slotProps.count}`\n  }\n})\n\nfunction MyComponent(slots) {\n  const greetingMessage = 'hello'\n  return `<div>${\n    // 在插槽函数调用时传入 props\n    slots.default({ text: greetingMessage, count: 1 })\n  }</div>`\n}\n```\n\n实际上，这已经和作用域插槽的最终代码编译结果、以及手动编写[渲染函数](/guide/extras/render-function)时使用作用域插槽的方式非常类似了。\n\n`v-slot=\"slotProps\"` 可以类比这里的函数签名，和函数的参数类似，我们也可以在 `v-slot` 中使用解构：\n\n```vue-html\n<MyComponent v-slot=\"{ text, count }\">\n  {{ text }} {{ count }}\n</MyComponent>\n```\n\n### 具名作用域插槽 {#named-scoped-slots}\n\n具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 `v-slot` 指令的值被访问到：`v-slot:name=\"slotProps\"`。当使用缩写时是这样：\n\n```vue-html\n<MyComponent>\n  <template #header=\"headerProps\">\n    {{ headerProps }}\n  </template>\n\n  <template #default=\"defaultProps\">\n    {{ defaultProps }}\n  </template>\n\n  <template #footer=\"footerProps\">\n    {{ footerProps }}\n  </template>\n</MyComponent>\n```\n\n向具名插槽中传入 props：\n\n```vue-html\n<slot name=\"header\" message=\"hello\"></slot>\n```\n\n注意插槽上的 `name` 是一个 Vue 特别保留的 attribute，不会作为 props 传递给插槽。因此最终 `headerProps` 的结果是 `{ message: 'hello' }`。\n\n如果你同时使用了具名插槽与默认插槽，则需要为默认插槽使用显式的 `<template>` 标签。尝试直接为组件添加 `v-slot` 指令将导致编译错误。这是为了避免因默认插槽的 props 的作用域而困惑。举例：\n\n```vue-html\n<!-- 该模板无法编译 -->\n<template>\n  <MyComponent v-slot=\"{ message }\">\n    <p>{{ message }}</p>\n    <template #footer>\n      <!-- message 属于默认插槽，此处不可用 -->\n      <p>{{ message }}</p>\n    </template>\n  </MyComponent>\n</template>\n```\n\n为默认插槽使用显式的 `<template>` 标签有助于更清晰地指出 `message` 属性在其他插槽中不可用：\n\n```vue-html\n<template>\n  <MyComponent>\n    <!-- 使用显式的默认插槽 -->\n    <template #default=\"{ message }\">\n      <p>{{ message }}</p>\n    </template>\n\n    <template #footer>\n      <p>Here's some contact info</p>\n    </template>\n  </MyComponent>\n</template>\n```",
          "questions": [
            "动态指令参数在`v-slot`上是否有效？",
            "如何定义动态插槽名？",
            "为什么在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据？",
            "如何让子组件在渲染时将一部分数据提供给插槽？",
            "插槽的内容无法访问到子组件的状态，这个说法正确吗？",
            "作用域插槽和传入子组件的函数有什么类比？",
            "作用域插槽的最终代码编译结果和手动编写渲染函数时使用作用域插槽的方式有何相似之处？",
            "具名作用域插槽的工作方式是什么？",
            "插槽上的`name`是否会作为props传递给插槽？",
            "如果同时使用了具名插槽与默认插槽，需要为默认插槽使用什么标签？为什么？"
          ]
        },
        {
          "content": "### 高级列表组件示例 {#fancy-list-example}\n\n你可能想问什么样的场景才适合用到作用域插槽，这里我们来看一个 `<FancyList>` 组件的例子。它会渲染一个列表，并同时会封装一些加载远端数据的逻辑、使用数据进行列表渲染、或者是像分页或无限滚动这样更进阶的功能。然而我们希望它能够保留足够的灵活性，将对单个列表元素内容和样式的控制权留给使用它的父组件。我们期望的用法可能是这样的：\n\n```vue-html\n<FancyList :api-url=\"url\" :per-page=\"10\">\n  <template #item=\"{ body, username, likes }\">\n    <div class=\"item\">\n      <p>{{ body }}</p>\n      <p>by {{ username }} | {{ likes }} likes</p>\n    </div>\n  </template>\n</FancyList>\n```\n\n在 `<FancyList>` 之中，我们可以多次渲染 `<slot>` 并每次都提供不同的数据 (注意我们这里使用了 `v-bind` 来传递插槽的 props)：\n\n```vue-html\n<ul>\n  <li v-for=\"item in items\">\n    <slot name=\"item\" v-bind=\"item\"></slot>\n  </li>\n</ul>\n```\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqFU2Fv0zAQ/StHJtROapNuZTBCNwnQQKBpTGxCQss+uMml8+bYlu2UlZL/zjlp0lQa40sU3/nd3Xv3vA7eax0uSwziYGZTw7UDi67Up4nkhVbGwScm09U5tw5yowoYhFEX8cBBImdRgyQMHRwWWjCHdAKYbdFM83FpxEkS0DcJINZoxpotkCIHkySo7xOixcMep19KrmGustUISotGsgJHIPgDWqg6DKEyvoRUMGsJ4HG9HGX16bqpAlU1izy5baqDFegYweYroMttMwLAHx/Y9Kyan36RWUTN2+mjXfpbrei8k6SjdSuBYFOlMaNI6AeAtcflSrqx5b8xhkl4jMU7H0yVUCaGvVeH8+PjKYWqWnpf5DQYBTtb+fc612Awh2qzzGaBiUyVpBVpo7SFE8gw5xIv/Wl4M9gsbjCCQbuywe3+FuXl9iiqO7xpElEEhUofKFQo2mTGiFiOLr3jcpFImuiaF6hKNxzuw8lpw7kuEy6ZKJGK3TR6NluLYXBVqwRXQjkLn0ueIc3TLonyZ0sm4acqKVovKIbDCVQjGsb1qvyg2telU4Yzz6eHv6ARBWdwjVqUNCbbFjqgQn6aW1J8RKfJhDg+5/lStG4QHJZjnpO5XjT0BMqFu+uZ81yxjEQJw7A1kOA76FyZjaWBy0akvu8tCQKeQ+d7wsy5zLpz1FlzU3kW1QP+x40ApWgWAySEJTv6/NitNMkllcTakwCaZZ5ADEf6cROas/RhYVQps5igEpkZLwzRROmG04OjDBcj7+Js+vYQDo9e0uH1qzeY5/s1vtaaqG969+vTTrsmBTMLLv12nuy7l+d5W673SBzxkzlfhPdWSXokdZMkSFWhuUDzTTtOnk6CuG2fBEwI9etrHXOmRLJUE0/vMH14In5vH30sCS4Nkr+WmARdztHQ6Jr02dUFPtJ/lyxUVgq6/UzyO1olSj9jc+0DcaWxe/fqab/UT51Uu7Znjw6lbUn5QWtR6vtJQM//4zPUt+NOw+lGzCqo/gLm1QS8)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqNVNtq20AQ/ZWpQnECujhO0qaqY+hD25fQl4RCifKwllbKktXushcT1/W/d1bSSnYJNCCEZmbPmcuZ1S76olS6cTTKo6UpNVN2VQjWKqktfCOi3N4yY6HWsoVZmo0eD5kVAqAQ9KU7XNGaOG5h572lRAZBhTV574CJzJv7QuCzzMaMaFjaKk4sRQtgOeUmiiVO85siwncRQa6oThRpKHrO50XUnUdEwMMJw08M7mAtq20MzlAtSEtj4OyZGkweMIiq2AZKToxBgMcdxDCqVrueBfb7ZaaOQiOspZYgbL0FPBySIQD+eMeQc99/HJIsM0weqs+O258mjfZREE1jt5yCKaWiFXpSX0A/5loKmxj2m+YwT69p+7kXg0udw8nlYn19fYGufvSeZBXF0ZGmR2vwmrJKS4WiPswGWWYxzIIgs8fYH6mIJadnQXdNrdMiWAB+yJ7gsXdgLfjqcK10wtJqgmYZ+spnpGgl6up5oaa2fGKi6U8Yau9ZS6Wzpwi7WU1p7BMzaZcLbuBh0q2XM4fZXTc+uOPSGvjuWEWxlaAexr9uiIBf0qG3Uy6HxXwo9B+mn47CvbNSM+LHccDxAyvmjMA9Vdxh1WQiO0eywBVGEaN3Pj972wVxPKwOZ7BJWI2b+K5rOOVUNPbpYJNvJalwZmmahm3j7AhdSz3sPzDRS3R4SQwOCXxP4yVBzJqJarSzcY8H5mXWFfif1QVwPGjGcQWTLp7YrcLxCfyDdAuMW0cq30AOV+plcK1J+dxoXJkqR6igRCeNxjbxp3N6cX5V0Sb2K19dfFrA4uo9Gh8uP9K6Puvw3eyx9SH3IT/qPCZpiW6Y8Gq9mvekrutAN96o/V99ALPj)\n\n</div>",
          "questions": [
            "作用域插槽的使用场景是什么？",
            "在示例中，`<FancyList>` 组件封装了哪些功能？",
            "在示例中，为什么要将对单个列表元素内容和样式的控制权留给使用它的父组件？",
            "在示例中，`<FancyList>` 组件是如何渲染列表的？",
            "在示例中，`<FancyList>` 组件如何提供不同的数据给每个插槽？",
            "在示例中，`<FancyList>` 组件中的 `v-bind` 有什么作用？",
            "在示例中，`<slot>` 标签的作用是什么？",
            "在示例中，`<template>` 标签的作用是什么？",
            "在示例中，`<ul>` 和 `<li>` 标签的作用是什么？",
            "在示例中，如何使用 `v-for` 渲染列表？"
          ]
        },
        {
          "content": "### 无渲染组件 {#renderless-components}\n\n上面的 `<FancyList>` 案例同时封装了可重用的逻辑 (数据获取、分页等) 和视图输出，但也将部分视图输出通过作用域插槽交给了消费者组件来管理。\n\n如果我们将这个概念拓展一下，可以想象的是，一些组件可能只包括了逻辑而不需要自己渲染内容，视图输出通过作用域插槽全权交给了消费者组件。我们将这种类型的组件称为**无渲染组件**。\n\n这里有一个无渲染组件的例子，一个封装了追踪当前鼠标位置逻辑的组件：\n\n```vue-html\n<MouseTracker v-slot=\"{ x, y }\">\n  Mouse is at: {{ x }}, {{ y }}\n</MouseTracker>\n```\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqNUcFqhDAQ/ZUhF12w2rO4Cz301t5aaCEX0dki1SQko6uI/96J7i4qLPQQmHmZ9+Y9ZhQvxsRdiyIVmStsZQgcUmtOUlWN0ZbgXbcOP2xe/KKFs9UNBHGyBj09kCpLFj4zuSFsTJ0T+o6yjUb35GpNRylG6CMYYJKCpwAkzWNQOcgphZG/YZoiX/DQNAttFjMrS+6LRCT2rh6HGsHiOQKtmKIIS19+qmZpYLrmXIKxM1Vo5Yj9HD0vfD7ckGGF3LDWlOyHP/idYPQCfdzldTtjscl/8MuDww78lsqHVHdTYXjwCpdKlfoS52X52qGit8oRKrRhwHYdNrrDILouPbCNVZCtgJ1n/6Xx8JYAmT8epD3fr5cC0oGLQYpkd4zpD27R0vA=)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqVUU1rwzAM/SvCl7SQJTuHdLDDbttthw18MbW6hjW2seU0oeS/T0lounQfUDBGepaenvxO4tG5rIkoClGGra8cPUhT1c56ghcbA756tf1EDztva0iy/Ds4NCbSAEiD7diicafigeA0oFvLPAYNhWICYEE5IL00fMp8Hs0JYe0OinDIqFyIaO7CwdJGihO0KXTcLriK59NYBlUARTyMn6Hv0yHgIp7ARAvl3FXm8yCRiuu1Fv/x23JakVqtz3t5pOjNOQNoC7hPz0nHyRSzEr7Ghxppb/XlZ6JjRlzhTAlA+ypkLWwAM6c+8G2BdzP+/pPbRkOoL/KOldH2mCmtnxr247kKhAb9KuHKgLVtMEkn2knG+sIVzV9sfmy8hfB/swHKwV0oWja4lQKKjoNOivzKrf4L/JPqaQ==)\n\n</div>\n\n虽然这个模式很有趣，但大部分能用无渲染组件实现的功能都可以通过组合式 API 以另一种更高效的方式实现，并且还不会带来额外组件嵌套的开销。之后我们会在[组合式函数](/guide/reusability/composables)一章中介绍如何更高效地实现追踪鼠标位置的功能。\n\n尽管如此，作用域插槽在需要**同时**封装逻辑、组合视图界面时还是很有用，就像上面的 `<FancyList>` 组件那样。",
          "questions": [
            "什么是无渲染组件？",
            "无渲染组件的视图输出是如何处理的？",
            "什么是作用域插槽？",
            "作用域插槽在什么情况下很有用？",
            "除了无渲染组件，还有哪些能用组合式 API 实现的功能？",
            "为什么组合式 API 更高效？",
            "什么是组合式函数？",
            "作用域插槽和组合式函数有什么区别？",
            "在什么情况下需要同时封装逻辑和组合视图界面？",
            "为什么作用域插槽在需要同时封装逻辑和组合视图界面时很有用？"
          ]
        }
      ]
    },
    {
      "file_name": "registration.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 组件注册 {#component-registration}\n\n> 此章节假设你已经看过了[组件基础](/guide/essentials/component-basics)。若你还不了解组件是什么，请先阅读该章节。\n\n<VueSchoolLink href=\"https://vueschool.io/lessons/vue-3-global-vs-local-vue-components\" title=\"免费的 Vue.js 组件注册课程\"/>\n\n一个 Vue 组件在使用前需要先被“注册”，这样 Vue 才能在渲染模板时找到其对应的实现。组件注册有两种方式：全局注册和局部注册。\n\n## 全局注册 {#global-registration}\n\n我们可以使用 [Vue 应用实例](/guide/essentials/application)的 `app.component()` 方法，让组件在当前 Vue 应用中全局可用。\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n\napp.component(\n  // 注册的名字\n  'MyComponent',\n  // 组件的实现\n  {\n    /* ... */\n  }\n)\n```\n\n如果使用单文件组件，你可以注册被导入的 `.vue` 文件：\n\n```js\nimport MyComponent from './App.vue'\n\napp.component('MyComponent', MyComponent)\n```\n\n`app.component()` 方法可以被链式调用：\n\n```js\napp\n  .component('ComponentA', ComponentA)\n  .component('ComponentB', ComponentB)\n  .component('ComponentC', ComponentC)\n```\n\n全局注册的组件可以在此应用的任意组件的模板中使用：\n\n```vue-html\n<!-- 这在当前应用的任意组件中都可用 -->\n<ComponentA/>\n<ComponentB/>\n<ComponentC/>\n```\n\n所有的子组件也可以使用全局注册的组件，这意味着这三个组件也都可以在*彼此内部*使用。\n\n## 局部注册 {#local-registration}\n\n全局注册虽然很方便，但有以下几个问题：\n\n1. 全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。\n\n2. 全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。\n\n相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。\n\n<div class=\"composition-api\">\n\n在使用 `<script setup>` 的单文件组件中，导入的组件可以直接在模板中使用，无需注册：\n\n```vue\n<script setup>\nimport ComponentA from './ComponentA.vue'\n</script>\n\n<template>\n  <ComponentA />\n</template>\n```\n\n如果没有使用 `<script setup>`，则需要使用 `components` 选项来显式注册：\n\n```js\nimport ComponentA from './ComponentA.js'\n\nexport default {\n  components: {\n    ComponentA\n  },\n  setup() {\n    // ...\n  }\n}\n```\n\n</div>\n<div class=\"options-api\">\n\n局部注册需要使用 `components` 选项：\n\n```vue\n<script>\nimport ComponentA from './ComponentA.vue'\n\nexport default {\n  components: {\n    ComponentA\n  }\n}\n</script>\n\n<template>\n  <ComponentA />\n</template>\n```\n\n</div>\n\n对于每个 `components` 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于：\n\n```js\nexport default {\n  components: {\n    ComponentA: ComponentA\n  }\n  // ...\n}\n```\n\n请注意：**局部注册的组件在后代组件中并<i>不</i>可用**。在这个例子中，`ComponentA` 注册后仅在当前组件可用，而在任何的子组件或更深层的子组件中都不可用。\n\n## 组件名格式 {#component-name-casing}\n\n在整个指引中，我们都使用 PascalCase 作为组件名的注册格式，这是因为：\n\n1. PascalCase 是合法的 JavaScript 标识符。这使得在 JavaScript 中导入和注册组件都很容易，同时 IDE 也能提供较好的自动补全。\n\n2. `<PascalCase />` 在模板中更明显地表明了这是一个 Vue 组件，而不是原生 HTML 元素。同时也能够将 Vue 组件和自定义元素 (web components) 区分开来。\n\n在单文件组件和内联字符串模板中，我们都推荐这样做。但是，PascalCase 的标签名在 DOM 模板中是不可用的，详情参见 [DOM 内模板解析注意事项](/guide/essentials/component-basics#in-dom-template-parsing-caveats)。\n\n为了方便，Vue 支持将模板中使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 `MyComponent` 为名注册的组件，在模板中可以通过 `<MyComponent>` 或 `<my-component>` 引用。这让我们能够使用同样的 JavaScript 组件注册代码来配合不同来源的模板。",
          "questions": [
            "什么是组件注册？",
            "组件注册有哪两种方式？",
            "如何在 Vue 应用实例中全局注册组件？",
            "如何在单文件组件中注册组件？",
            "全局注册组件有哪些问题？",
            "局部注册组件有哪些优点？",
            "在局部注册中，如何将组件导入并注册？",
            "局部注册的组件在哪些范围内可用？",
            "为什么推荐使用 PascalCase 作为组件名的注册格式？",
            "在模板中可以使用什么格式的标签引用 kebab-case 的组件？"
          ]
        }
      ]
    },
    {
      "file_name": "v-model.md",
      "question_count": 30,
      "documents": [
        {
          "content": "# 组件 v-model {#component-v-model}\n\n`v-model` 可以在组件上使用以实现双向绑定。\n\n首先让我们回忆一下 `v-model` 在原生元素上的用法：\n\n```vue-html\n<input v-model=\"searchText\" />\n```\n\n在代码背后，模板编译器会对 `v-model` 进行更冗长的等价展开。因此上面的代码其实等价于下面这段：\n\n```vue-html\n<input\n  :value=\"searchText\"\n  @input=\"searchText = $event.target.value\"\n/>\n```\n\n而当使用在一个组件上时，`v-model` 会被展开为如下的形式：\n\n```vue-html\n<CustomInput\n  :model-value=\"searchText\"\n  @update:model-value=\"newValue => searchText = newValue\"\n/>\n```\n\n要让这个例子实际工作起来，`<CustomInput>` 组件内部需要做两件事：\n\n1. 将内部原生 `<input>` 元素的 `value` attribute 绑定到 `modelValue` prop\n2. 当原生的 `input` 事件触发时，触发一个携带了新值的 `update:modelValue` 自定义事件\n\n这里是相应的代码：\n\n<div class=\"options-api\">\n\n```vue\n<!-- CustomInput.vue -->\n<script>\nexport default {\n  props: ['modelValue'],\n  emits: ['update:modelValue']\n}\n</script>\n\n<template>\n  <input\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n</div>\n<div class=\"composition-api\">\n\n```vue\n<!-- CustomInput.vue -->\n<script setup>\ndefineProps(['modelValue'])\ndefineEmits(['update:modelValue'])\n</script>\n\n<template>\n  <input\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n</div>\n\n现在 `v-model` 可以在这个组件上正常工作了：\n\n```vue-html\n<CustomInput v-model=\"searchText\" />\n```\n\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqFkctqwzAQRX9lEAEn4Np744aWrvoD3URdiHiSGvRCHpmC8b93JDfGKYGCkJjXvTrSJF69r8aIohHtcA69p6O0vfEuELzFgZx5tz4SXIIzUFT1JpfGCmmlxe/c3uFFRU0wSQtwdqxh0dLQwHSnNJep3ilS+8PSCxCQYrC3CMDgMKgrNlB8odaOXVJ2TgdvvNp6vSwHhMZrRcgRQLs1G5+M61A/S/ErKQXUR5immwXMWW1VEKX4g3j3Mo9QfXCeKU9FtvpQmp/lM0Oi6RP/qYieebHZNvyL0acLLODNmGYSxCogxVJ6yW1c2iWz/QOnEnY48kdUpMIVGSllD8t8zVZb+PkHqPG4iw==)\n\n</div>\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9j81qwzAQhF9lEQE7kNp344SW0kNvPfVS9WDidSrQH9LKF+N37yoOxoSQm7QzO9/sJN68r8aEohFtPAflCSJS8idplfEuEEwQcIAZhuAMFGwtVuk9RXLm0/pEN7mqN7Ocy2YAac/ORgKDMXYXhGOOLIs/1NoVe2nbekEzlD+ExuuOkH8A7ZYxvhjXoz5KcUuSAuoTTNOaPM85bU0QB3HX58GdPQ7K4ldwPpY/xZXw3Wmu/svVFvHDKMpi8j3HNneeZ/VVBucXQDPmjVx+XZdikV6vNpZ2yKTyAecAOxzRUkVduCCfkqf7Zb9m1Pbo+R9ZkqZn)\n\n</div>\n\n另一种在组件内实现 `v-model` 的方式是使用一个可写的，同时具有 getter 和 setter 的 `computed`  属性。`get` 方法需返回 `modelValue` prop，而 `set` 方法需触发相应的事件：\n\n<div class=\"options-api\">\n\n```vue\n<!-- CustomInput.vue -->\n<script>\nexport default {\n  props: ['modelValue'],\n  emits: ['update:modelValue'],\n  computed: {\n    value: {\n      get() {\n        return this.modelValue\n      },\n      set(value) {\n        this.$emit('update:modelValue', value)\n      }\n    }\n  }\n}\n</script>\n\n<template>\n  <input v-model=\"value\" />\n</template>\n```\n\n</div>\n<div class=\"composition-api\">\n\n```vue\n<!-- CustomInput.vue -->\n<script setup>\nimport { computed } from 'vue'\n\nconst props = defineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\n\nconst value = computed({\n  get() {\n    return props.modelValue\n  },\n  set(value) {\n    emit('update:modelValue', value)\n  }\n})\n</script>\n\n<template>\n  <input v-model=\"value\" />\n</template>\n```\n\n</div>\n\n## `v-model` 的参数 {#v-model-arguments}\n\n默认情况下，`v-model` 在组件上都是使用 `modelValue` 作为 prop，并以 `update:modelValue` 作为对应的事件。我们可以通过给 `v-model` 指定一个参数来更改这些名字：\n\n```vue-html\n<MyComponent v-model:title=\"bookTitle\" />\n```\n\n在这个例子中，子组件应声明一个 `title` prop，并通过触发 `update:title` 事件更新父组件值：\n\n<div class=\"composition-api\">\n\n```vue\n<!-- MyComponent.vue -->\n<script setup>\ndefineProps(['title'])\ndefineEmits(['update:title'])\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"title\"\n    @input=\"$emit('update:title', $event.target.value)\"\n  />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9kE1rwzAMhv+KMIW00DXsGtKyMXYc7D7vEBplM8QfOHJoCfnvk+1QsjJ2svVKevRKk3h27jAGFJWoh7NXjmBACu4kjdLOeoIJPHYwQ+ethoJLi1vq7fpi+WfQ0JI+lCstcrkYQJqzNQMBKeoRjhG4LcYHbVvsofFfQUcCXhrteix20tRl9sIuOCBkvSHkCKD+fjxN04Ka57rkOOlrMwu7SlVHKdIrBZRcWpc3ntiLO7t/nKHFThl899YN248ikYpP9pj1V60o6sG1TMwDU/q/FZRxgeIPgK4uGcQLSZGlamz6sHKd1afUxOoGeeT298A9bHCMKxBfE3mTSNjl1vud5x8qNa76)\n\n</div>\n<div class=\"options-api\">\n\n```vue\n<!-- MyComponent.vue -->\n<script>\nexport default {\n  props: ['title'],\n  emits: ['update:title']\n}\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"title\"\n    @input=\"$emit('update:title', $event.target.value)\"\n  />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqFUNFqwzAM/BVhCm6ha9hryMrGnvcFdR9Mo26B2DGuHFJC/n2yvZakDAohtuTTne5G8eHcrg8oSlFdTr5xtFe2Ma7zBF/Xz45vFi3B2XcG5K6Y9eKYVFZZHBK8xrMOLcGoLMDphrqUMC6Ypm18rzXp9SZjATxS8PZWAVBDLZYg+xfT1diC9t/BxGEctHFtlI2wKR78468q7ttzQcgoTcgVQPXzuh/HzAnTVBVcp/58qz+lMqHelEinElAwtCrufGIrHhJYBPdfEs53jkM4yEQpj8k+miYmc5DBcRKYZeXxqZXGukDZPF1dWhQHUiK3yl63YbZ97r6nIe6uoup6KbmFFfbRCnHGyI4iwyaPPnqffgGMlsEM)\n\n</div>",
          "questions": [
            "`v-model` 在原生元素上的用法是什么？",
            "`v-model` 在组件上的用法是什么？",
            "`v-model` 在组件上被展开为什么形式？",
            "在组件内部实现 `v-model` 的两种方式是什么？",
            "第一种方式中，组件内部需要做哪两件事情？",
            "第二种方式中，`computed` 属性的 `get` 和 `set` 方法分别应该返回和触发什么？",
            "如何更改 `v-model` 在组件上使用的 prop 和事件名？",
            "如何在子组件中声明一个 `title` prop 并更新父组件的值？",
            "子组件应该触发哪个事件来更新父组件的值？",
            "请给出一个完整的 `MyComponent` 组件的代码，实现 `v-model` 功能。"
          ]
        },
        {
          "content": "## 多个 `v-model` 绑定 {#multiple-v-model-bindings}\n\n利用刚才在 [`v-model` 参数](#v-model-arguments)小节中学到的指定参数与事件名的技巧，我们可以在单个组件实例上创建多个 `v-model` 双向绑定。\n\n组件上的每一个 `v-model` 都会同步不同的 prop，而无需额外的选项：\n\n```vue-html\n<UserName\n  v-model:first-name=\"first\"\n  v-model:last-name=\"last\"\n/>\n```\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\ndefineProps({\n  firstName: String,\n  lastName: String\n})\n\ndefineEmits(['update:firstName', 'update:lastName'])\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"firstName\"\n    @input=\"$emit('update:firstName', $event.target.value)\"\n  />\n  <input\n    type=\"text\"\n    :value=\"lastName\"\n    @input=\"$emit('update:lastName', $event.target.value)\"\n  />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqNUc1qwzAMfhVjCk6hTdg1pGWD7bLDGIydlh1Cq7SGxDaOEjaC332yU6cdFNpLsPRJ348y8idj0qEHnvOi21lpkHWAvdmWSrZGW2Qjs1Azx2qrWyZoVMzQZwf2rWrhhKVZbHhGGivVTqsOWS0tfTeeKBGv+qjEMkJNdUaeNXigyCYjZIEKhNY0FQJVjBXHh+04nvicY/QOBM4VGUFhJHrwBWPDutV7aPKwslbU35Q8FCX/P+GJ4oB/T3hGpEU2m+ArfpnxytX2UEsF71abLhk9QxDzCzn7QCvVYeW7XuGyWSpH0eP6SyuxS75Eb/akOpn302LFYi8SiO8bJ5PK9DhFxV/j0yH8zOnzoWr6+SbhbifkMSwSsgByk1zzsoABFKZY2QNgGpiW57Pdrx2z3JCeI99Svvxh7g8muf2x)\n\n</div>\n<div class=\"options-api\">\n\n```vue\n<script>\nexport default {\n  props: {\n    firstName: String,\n    lastName: String\n  },\n  emits: ['update:firstName', 'update:lastName']\n}\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"firstName\"\n    @input=\"$emit('update:firstName', $event.target.value)\"\n  />\n  <input\n    type=\"text\"\n    :value=\"lastName\"\n    @input=\"$emit('update:lastName', $event.target.value)\"\n  />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqNkk1rg0AQhv/KIAETSJRexYYWeuqhl9JTt4clmSSC7i7rKCnif+/ObtYkELAiujPzztejQ/JqTNZ3mBRJ2e5sZWgrVNUYbQm+WrQfskE4WN1AmuXRwQmpUELh2Qv3eJBdTTAIBbDTLluhoraA4VpjXHNwL0kuV0EIYJE6q6IFcKhsSwWk7/qkUq/nq5be+aa5JztGfrmHu8t8GtoZhI2pJaGzAMrT03YYQk0YR3BnruSOZe5CXhKnC3X7TaP3WBc+ZaOc/1kk3hDJvYILRQGfQzx3Rct8GiJZJ7fA7gg/AmesNszMrUIXFpxbwCfZSh09D0Hc7tbN6sAWm4qZf6edcZgxrMHSdA3RF7PTn1l8lTIdhbXp1/CmhOeJRNHLupv4eIaXyItPdJEFD7R8NM0Ce/d/ZCTtESnzlVZXhP/vHbeZaT0tPdf59uONfx7mDVM=)\n\n</div>",
          "questions": [
            "在组件中如何创建多个v-model双向绑定？",
            "多个v-model会同步哪些prop？",
            "在组件中如何指定v-model的参数和事件名？",
            "在composition-api中如何定义props和emits？",
            "在options-api中如何定义props和emits？",
            "在composition-api中如何使用v-model？",
            "在options-api中如何使用v-model？",
            "在组件中如何使用v-model？",
            "在组件中如何监听input事件？",
            "在组件中如何获取input事件的值？"
          ]
        },
        {
          "content": "## 处理 `v-model` 修饰符 {#handling-v-model-modifiers}\n\n在学习输入绑定时，我们知道了 `v-model` 有一些[内置的修饰符](/guide/essentials/forms#modifiers)，例如 `.trim`，`.number` 和 `.lazy`。在某些场景下，你可能想要一个自定义组件的 `v-model` 支持自定义的修饰符。\n\n我们来创建一个自定义的修饰符 `capitalize`，它会自动将 `v-model` 绑定输入的字符串值第一个字母转为大写：\n\n```vue-html\n<MyComponent v-model.capitalize=\"myText\" />\n```\n\n组件的 `v-model` 上所添加的修饰符，可以通过 `modelModifiers` prop 在组件内访问到。在下面的组件中，我们声明了 `modelModifiers` 这个 prop，它的默认值是一个空对象：\n\n<div class=\"composition-api\">\n\n```vue{4,9}\n<script setup>\nconst props = defineProps({\n  modelValue: String,\n  modelModifiers: { default: () => ({}) }\n})\n\ndefineEmits(['update:modelValue'])\n\nconsole.log(props.modelModifiers) // { capitalize: true }\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n</div>\n<div class=\"options-api\">\n\n```vue{11}\n<script>\nexport default {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  emits: ['update:modelValue'],\n  created() {\n    console.log(this.modelModifiers) // { capitalize: true }\n  }\n}\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n</div>\n\n注意这里组件的 `modelModifiers` prop 包含了 `capitalize` 且其值为 `true`，因为它在模板中的 `v-model` 绑定 `v-model.capitalize=\"myText\"` 上被使用了。\n\n有了这个 prop，我们就可以检查 `modelModifiers` 对象的键，并编写一个处理函数来改变抛出的值。在下面的代码里，我们就是在每次 `<input />` 元素触发 `input` 事件时将值的首字母大写：\n\n<div class=\"composition-api\">\n\n```vue{11-13}\n<script setup>\nconst props = defineProps({\n  modelValue: String,\n  modelModifiers: { default: () => ({}) }\n})\n\nconst emit = defineEmits(['update:modelValue'])\n\nfunction emitValue(e) {\n  let value = e.target.value\n  if (props.modelModifiers.capitalize) {\n    value = value.charAt(0).toUpperCase() + value.slice(1)\n  }\n  emit('update:modelValue', value)\n}\n</script>\n\n<template>\n  <input type=\"text\" :value=\"modelValue\" @input=\"emitValue\" />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9Us1Og0AQfpUJF5ZYqV4JNTaNxyYmVi/igdCh3QR2N7tDIza8u7NLpdU0nmB+v5/ZY7Q0Jj10GGVR7iorDYFD6sxDoWRrtCU4gsUaBqitbiHm1ngqrfuV5j+Fik7ldH6R83u5GaBQlVaOoO03+Emw8BtFHCeFyucjKMNxQNiapiTkCGCzlw6kMh1BVRpJZSO/0AEe0Pa0l2oHve6AYdBmvj+/ZHO4bfUWm/Q8uSiiEb6IYM4A+XxCi2bRH9ZX3BgVGKuNYwFbrKXCZx+Jo0cPcG9l02EGL2SZ3mxKr/VW1hKty9hMniy7hjIQCSweQByHBIZCDWzGDwi20ps0Yjxx4MR73Jktc83OOPFHGKk7VZHUKkyFgsAEAqcG2Qif4WWYUml3yOp8wldlDSLISX+TvPDstAemLeGbVvvSLkncJSnpV2PQrkqHLOfmVHeNrFDcMz3w0iBQE1cUzMYBbuS2f55CPj4D6o0/I41HzMKsP+u0kLOPoZWzkx1X7j18A8s0DEY=)\n\n</div>\n<div class=\"options-api\">\n\n```vue{13-15}\n<script>\nexport default {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  emits: ['update:modelValue'],\n  methods: {\n    emitValue(e) {\n      let value = e.target.value\n      if (this.modelModifiers.capitalize) {\n        value = value.charAt(0).toUpperCase() + value.slice(1)\n      }\n      this.$emit('update:modelValue', value)\n    }\n  }\n}\n</script>\n\n<template>\n  <input type=\"text\" :value=\"modelValue\" @input=\"emitValue\" />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqFks1qg0AQgF9lkIKGpqa9iikNOefUtJfaw6KTZEHdZR1DbPDdO7saf0qgIq47//PNXL2N1uG5Ri/y4io1UtNrUspCK0Owa7aK/0osCQ5GFeCHq4nMuvlJCZCUeHEOGR5EnRNcrTS92VURXGex2qXVZ4JEsOhsAQxSbcrbDaBo9nihCHyXAaC1B3/4jVdDoXwhLHQuCPkGsD/JCmSpa4JUaEkilz9YAZ7RNHSS5REaVQPXgCay9vG0rPNToTLMw9FznXhdHYkHK04Qr4Zs3tL7g2JG8B4QbZS2LLqGXK5PkdcYwTsZrs1R6RU7lcmDRDPaM7AuWARMbf0KwbVdTNk4dyyk5f3l15r5YjRm8b+dQYF0UtkY1jo4fYDDLAByZBxWCmvAkIQ5IvdoBTcLeYCAiVbhvNwJvEk4GIK5M0xPwmwoeF6EpD60RrMVFXJXj72+ymWKwUvfXt+gfVzGB1tzcKfDZec+o/LfxsTdtlCj7bSpm3Xk4tjpD8FZ+uZMWTowu7MW7S+CWR77)\n\n</div>\n\n### 带参数的 `v-model` 修饰符 {#modifiers-for-v-model-with-arguments}\n\n对于又有参数又有修饰符的 `v-model` 绑定，生成的 prop 名将是 `arg + \"Modifiers\"`。举例来说：\n\n```vue-html\n<MyComponent v-model:title.capitalize=\"myText\">\n```\n\n相应的声明应该是：\n\n<div class=\"composition-api\">\n\n```js\nconst props = defineProps(['title', 'titleModifiers'])\ndefineEmits(['update:title'])\n\nconsole.log(props.titleModifiers) // { capitalize: true }\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: ['title', 'titleModifiers'],\n  emits: ['update:title'],\n  created() {\n    console.log(this.titleModifiers) // { capitalize: true }\n  }\n}\n```\n\n</div>\n\n这里是另一个例子，展示了如何在使用多个不同参数的 `v-model` 时使用修饰符：\n\n```vue-html\n<UserName\n  v-model:first-name.capitalize=\"first\"\n  v-model:last-name.uppercase=\"last\"\n/>\n```\n\n<div class=\"composition-api\">\n\n```vue{5,6,10,11}\n<script setup>\nconst props = defineProps({\n  firstName: String,\n  lastName: String,\n  firstNameModifiers: { default: () => ({}) },\n  lastNameModifiers: { default: () => ({}) }\n})\ndefineEmits(['update:firstName', 'update:lastName'])\n\nconsole.log(props.firstNameModifiers) // { capitalize: true }\nconsole.log(props.lastNameModifiers) // { uppercase: true}\n</script>\n```\n\n</div>\n<div class=\"options-api\">\n\n```vue{15,16}\n<script>\nexport default {\n  props: {\n    firstName: String,\n    lastName: String,\n    firstNameModifiers: {\n      default: () => ({})\n    },\n    lastNameModifiers: {\n      default: () => ({})\n    }\n  },\n  emits: ['update:firstName', 'update:lastName'],\n  created() {\n    console.log(this.firstNameModifiers) // { capitalize: true }\n    console.log(this.lastNameModifiers) // { uppercase: true}\n  }\n}\n</script>\n```\n\n</div>",
          "questions": [
            "自定义组件的 `v-model` 支持哪些内置的修饰符？",
            "如何创建一个自定义的修饰符？",
            "在组件中如何访问 `v-model` 上所添加的修饰符？",
            "如何检查 `modelModifiers` 对象的键并编写一个处理函数来改变抛出的值？",
            "在带参数的 `v-model` 绑定中，生成的 prop 名是什么？",
            "如何在使用多个不同参数的 `v-model` 时使用修饰符？",
            "在自定义组件中，如何声明 `modelModifiers` 这个 prop？",
            "如何在组件中触发 `update:modelValue` 事件？",
            "如何将值的首字母大写？",
            "如何将值转为大写？"
          ]
        }
      ]
    },
    {
      "file_name": "events.md",
      "question_count": 10,
      "documents": [
        {
          "content": "<script setup>\nimport { onMounted } from 'vue'\n\nif (typeof window !== 'undefined') {\n  const hash = window.location.hash\n\n  // The docs for v-model used to be part of this page. Attempt to redirect outdated links.\n  if ([\n    '#usage-with-v-model',\n    '#v-model-arguments',\n    '#multiple-v-model-bindings',\n    '#handling-v-model-modifiers'\n  ].includes(hash)) {\n    onMounted(() => {\n      window.location = './v-model.html' + hash\n    })\n  }\n}\n</script>\n# 组件事件 {#component-events}\n\n> 此章节假设你已经看过了[组件基础](/guide/essentials/component-basics)。若你还不了解组件是什么，请先阅读该章节。\n\n## 触发与监听事件 {#emitting-and-listening-to-events}\n\n在组件的模板表达式中，可以直接使用 `$emit` 方法触发自定义事件 (例如：在 `v-on` 的处理函数中)：\n\n```vue-html\n<!-- MyComponent -->\n<button @click=\"$emit('someEvent')\">click me</button>\n```\n\n<div class=\"options-api\">\n\n`$emit()` 方法在组件实例上也同样以 `this.$emit()` 的形式可用：\n\n```js\nexport default {\n  methods: {\n    submit() {\n      this.$emit('someEvent')\n    }\n  }\n}\n```\n\n</div>\n\n父组件可以通过 `v-on` (缩写为 `@`) 来监听事件：\n\n```vue-html\n<MyComponent @some-event=\"callback\" />\n```\n\n同样，组件的事件监听器也支持 `.once` 修饰符：\n\n```vue-html\n<MyComponent @some-event.once=\"callback\" />\n```\n\n像组件与 prop 一样，事件的名字也提供了自动的格式转换。注意这里我们触发了一个以 camelCase 形式命名的事件，但在父组件中可以使用 kebab-case 形式来监听。与 [prop 大小写格式](/guide/components/props#prop-name-casing)一样，在模板中我们也推荐使用 kebab-case 形式来编写监听器。\n\n:::tip\n和原生 DOM 事件不一样，组件触发的事件**没有冒泡机制**。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的事件总线，或是使用一个[全局状态管理方案](/guide/scaling-up/state-management)。\n:::\n\n## 事件参数 {#event-arguments}\n\n有时候我们会需要在触发事件时附带一个特定的值。举例来说，我们想要 `<BlogPost>` 组件来管理文本会缩放得多大。在这个场景下，我们可以给 `$emit` 提供一个额外的参数：\n\n```vue-html\n<button @click=\"$emit('increaseBy', 1)\">\n  Increase by 1\n</button>\n```\n\n然后我们在父组件中监听事件，我们可以先简单写一个内联的箭头函数作为监听器，此函数会接收到事件附带的参数：\n\n```vue-html\n<MyButton @increase-by=\"(n) => count += n\" />\n```\n\n或者，也可以用一个组件方法来作为事件处理函数：\n\n```vue-html\n<MyButton @increase-by=\"increaseCount\" />\n```\n\n该方法也会接收到事件所传递的参数：\n\n<div class=\"options-api\">\n\n```js\nmethods: {\n  increaseCount(n) {\n    this.count += n\n  }\n}\n```\n\n</div>\n<div class=\"composition-api\">\n\n```js\nfunction increaseCount(n) {\n  count.value += n\n}\n```\n\n</div>\n\n:::tip\n所有传入 `$emit()` 的额外参数都会被直接传向监听器。举例来说，`$emit('foo', 1, 2, 3)` 触发后，监听器函数将会收到这三个参数值。\n:::\n\n## 声明触发的事件 {#declaring-emitted-events}\n\n组件可以显式地通过 <span class=\"composition-api\">[`defineEmits()`](/api/sfc-script-setup#defineprops-defineemits) 宏</span><span class=\"options-api\">[`emits`](/api/options-state#emits) 选项</span>来声明它要触发的事件：\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\ndefineEmits(['inFocus', 'submit'])\n</script>\n```\n\n我们在 `<template>` 中使用的 `$emit` 方法不能在组件的 `<script setup>` 部分中使用，但 `defineEmits()` 会返回一个相同作用的函数供我们使用：\n\n```vue\n<script setup>\nconst emit = defineEmits(['inFocus', 'submit'])\n\nfunction buttonClick() {\n  emit('submit')\n}\n</script>\n```\n\n`defineEmits()` 宏**不能**在子函数中使用。如上所示，它必须直接放置在 `<script setup>` 的顶级作用域下。\n\n如果你显式地使用了 `setup` 函数而不是 `<script setup>`，则事件需要通过 [`emits`](/api/options-state#emits) 选项来定义，`emit` 函数也被暴露在 `setup()` 的上下文对象上：\n\n```js\nexport default {\n  emits: ['inFocus', 'submit'],\n  setup(props, ctx) {\n    ctx.emit('submit')\n  }\n}\n```\n\n与 `setup()` 上下文对象中的其他属性一样，`emit` 可以安全地被解构：\n\n```js\nexport default {\n  emits: ['inFocus', 'submit'],\n  setup(props, { emit }) {\n    emit('submit')\n  }\n}\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  emits: ['inFocus', 'submit']\n}\n```\n\n</div>\n\n这个 `emits` 选项还支持对象语法，它允许我们对触发事件的参数进行验证：\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nconst emit = defineEmits({\n  submit(payload) {\n    // 通过返回值为 `true` 还是为 `false` 来判断\n    // 验证是否通过\n  }\n})\n</script>\n```\n\n如果你正在搭配 TypeScript 使用 `<script setup>`，也可以使用纯类型标注来声明触发的事件：\n\n```vue\n<script setup lang=\"ts\">\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n</script>\n```\n\nTypeScript 用户请参考：[如何为组件所抛出事件标注类型](/guide/typescript/composition-api#typing-component-emits) <sup class=\"vt-badge ts\" />\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  emits: {\n    submit(payload) {\n      // 通过返回值为 `true` 还是为 `false` 来判断\n      // 验证是否通过\n    }\n  }\n}\n```\n\nTypeScript 用户请参考：[如何为组件所抛出的事件标注类型](/guide/typescript/options-api#typing-component-emits)。<sup class=\"vt-badge ts\" />\n\n</div>\n\n尽管事件声明是可选的，我们还是推荐你完整地声明所有要触发的事件，以此在代码中作为文档记录组件的用法。同时，事件声明能让 Vue 更好地将事件和[透传 attribute](/guide/components/attrs#v-on-listener-inheritance) 作出区分，从而避免一些由第三方代码触发的自定义 DOM 事件所导致的边界情况。\n\n:::tip\n如果一个原生事件的名字 (例如 `click`) 被定义在 `emits` 选项中，则监听器只会监听组件触发的 `click` 事件而不会再响应原生的 `click` 事件。\n:::\n\n## 事件校验 {#events-validation}\n\n和对 props 添加类型校验的方式类似，所有触发的事件也可以使用对象形式来描述。\n\n要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 <span class=\"options-api\">`this.$emit`</span><span class=\"composition-api\">`emit`</span> 的内容，返回一个布尔值来表明事件是否合法。\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nconst emit = defineEmits({\n  // 没有校验\n  click: null,\n\n  // 校验 submit 事件\n  submit: ({ email, password }) => {\n    if (email && password) {\n      return true\n    } else {\n      console.warn('Invalid submit event payload!')\n      return false\n    }\n  }\n})\n\nfunction submitForm(email, password) {\n  emit('submit', { email, password })\n}\n</script>\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  emits: {\n    // 没有校验\n    click: null,\n\n    // 校验 submit 事件\n    submit: ({ email, password }) => {\n      if (email && password) {\n        return true\n      } else {\n        console.warn('Invalid submit event payload!')\n        return false\n      }\n    }\n  },\n  methods: {\n    submitForm(email, password) {\n      this.$emit('submit', { email, password })\n    }\n  }\n}\n```\n\n</div>",
          "questions": [
            "在Vue组件中，如何触发自定义事件？",
            "在Vue组件中，如何监听自定义事件？",
            "Vue组件触发的事件是否具有冒泡机制？",
            "在Vue组件中，如何传递事件参数？",
            "在Vue组件中，如何声明触发的事件？",
            "在Vue组件中，如何对触发的事件进行校验？",
            "在Vue组件中，如何使用`$emit`方法触发自定义事件？",
            "在Vue组件中，如何使用`v-on`监听自定义事件？",
            "在Vue组件中，如何使用`.once`修饰符监听自定义事件？",
            "在Vue组件中，如何将事件名从camelCase形式转换为kebab-case形式？"
          ]
        }
      ]
    }
  ]
}
