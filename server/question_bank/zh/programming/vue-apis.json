{
  "question_type": "short",
  "designated_role": "examiner",
  "icon": "mdi-vuejs",
  "description": "Vue 3 框架的核心 API 详细信息，解释了如何使用这些 API 来创建和管理 Vue 组件，处理状态、生命周期钩子等",
  "link": "https://cn.vuejs.org/api/",
  "total_question_count": 230,
  "files": [
    {
      "file_name": "utility-types.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# TypeScript 工具类型 {#utility-types}\n\n:::info\n此页面仅列出了一些可能需要解释其使用方式的常用工具类型。有关导出类型的完整列表，请查看[源代码](https://github.com/vuejs/core/blob/main/packages/runtime-core/src/index.ts#L131)。\n:::\n\n## PropType\\<T> {#proptype-t}\n\n用于在用运行时 props 声明时给一个 prop 标注更复杂的类型定义。\n\n- **示例**\n\n  ```ts\n  import type { PropType } from 'vue'\n\n  interface Book {\n    title: string\n    author: string\n    year: number\n  }\n\n  export default {\n    props: {\n      book: {\n        // 提供一个比 `Object` 更具体的类型\n        type: Object as PropType<Book>,\n        required: true\n      }\n    }\n  }\n  ```\n\n- **参考**[指南 - 为组件 props 标注类型](/guide/typescript/options-api#typing-component-props)\n\n## MaybeRef\\<T> {#mayberef}\n\n`T | Ref<T>` 的别名。对于标注[组合式函数](/guide/reusability/composables.html)的参数很有用。\n\n- 仅在 3.3+ 版本中支持。\n\n## MaybeRefOrGetter\\<T> {#maybereforgetter}\n\n`T | Ref<T> | (() => T)` 的别名。对于标注[组合式函数](/guide/reusability/composables.html)的参数很有用。\n\n- 仅在 3.3+ 版本中支持。\n\n## ExtractPropTypes\\<T> {#extractproptypes}\n\n从运行时的 props 选项对象中提取 props 类型。提取到的类型是面向内部的，也就是说组件接收到的是解析后的 props。这意味着 boolean 类型的 props 和带有默认值的 props 总是一个定义的值，即使它们不是必需的。\n\n要提取面向外部的 props，即父组件允许传递的 props，请使用 [`ExtractPublicPropTypes`](#extractpublicproptypes)。\n\n- **示例**\n\n  ```ts\n  const propsOptions = {\n    foo: String,\n    bar: Boolean,\n    baz: {\n      type: Number,\n      required: true\n    },\n    qux: {\n      type: Number,\n      default: 1\n    }\n  } as const\n\n  type Props = ExtractPropTypes<typeof propsOptions>\n  // {\n  //   foo?: string,\n  //   bar: boolean,\n  //   baz: number,\n  //   qux: number\n  // }\n  ```\n\n## ExtractPublicPropTypes\\<T> {#extractpublicproptypes}\n\n从运行时的 props 选项对象中提取 prop。提取的类型是面向外部的，即父组件允许传递的 props。\n\n- **示例**\n\n  ```ts\n  const propsOptions = {\n    foo: String,\n    bar: Boolean,\n    baz: {\n      type: Number,\n      required: true\n    },\n    qux: {\n      type: Number,\n      default: 1\n    }\n  } as const\n\n  type Props = ExtractPublicPropTypes<typeof propsOptions>\n  // {\n  //   foo?: string,\n  //   bar?: boolean,\n  //   baz: number,\n  //   qux?: number\n  // }\n  ```\n\n## ComponentCustomProperties {#componentcustomproperties}\n\n用于增强组件实例类型以支持自定义全局属性。\n\n- **示例**\n\n  ```ts\n  import axios from 'axios'\n\n  declare module 'vue' {\n    interface ComponentCustomProperties {\n      $http: typeof axios\n      $translate: (key: string) => string\n    }\n  }\n  ```\n\n  :::tip\n  类型扩展必须被放置在一个模块 `.ts` 或 `.d.ts` 文件中。查看[类型扩展指南](/guide/typescript/options-api#augmenting-global-properties)了解更多细节\n  :::\n\n- **参考**[指南 - 扩展全局属性](/guide/typescript/options-api#augmenting-global-properties)\n\n## ComponentCustomOptions {#componentcustomoptions}\n\n用来扩展组件选项类型以支持自定义选项。\n\n- **示例**\n\n  ```ts\n  import { Route } from 'vue-router'\n\n  declare module 'vue' {\n    interface ComponentCustomOptions {\n      beforeRouteEnter?(to: any, from: any, next: () => void): void\n    }\n  }\n  ```\n\n  :::tip\n  类型扩展必须被放置在一个模块 `.ts` 或 `.d.ts` 文件中。查看[类型扩展指南](/guide/typescript/options-api#augmenting-global-properties)了解更多细节。\n  :::\n\n- **参考**[指南 - 扩展自定义选项](/guide/typescript/options-api#augmenting-custom-options)\n\n## ComponentCustomProps {#componentcustomprops}\n\n用于扩展全局可用的 TSX props，以便在 TSX 元素上使用没有在组件选项上定义过的 props。\n\n- **示例**\n\n  ```ts\n  declare module 'vue' {\n    interface ComponentCustomProps {\n      hello?: string\n    }\n  }\n\n  export {}\n  ```\n\n  ```tsx\n  // 现在即使没有在组件选项上定义过 hello 这个 prop 也依然能通过类型检查了\n  <MyComponent hello=\"world\" />\n  ```\n\n  :::tip\n  类型扩展必须被放置在一个模块 `.ts` 或 `.d.ts` 文件中。查看[类型扩展指南](/guide/typescript/options-api#augmenting-global-properties)了解更多细节。\n  :::\n\n## CSSProperties {#cssproperties}\n\n用于扩展在样式属性绑定上允许的值的类型。\n\n- **示例**\n\n允许任意自定义 CSS 属性：\n\n  ```ts\n  declare module 'vue' {\n    interface CSSProperties {\n      [key: `--${string}`]: string\n    }\n  }\n  ```\n\n  ```tsx\n  <div style={ { '--bg-color': 'blue' } }>\n  ```\n\n  ```html\n  <div :style=\"{ '--bg-color': 'blue' }\"></div>\n  ```\n\n:::tip\n类型增强必须被放置在一个模块 `.ts` 或 `.d.ts` 文件中。查看[类型增强指南](/guide/typescript/options-api#augmenting-global-properties)了解更多细节。\n:::\n\n:::info 参考\nSFC `<style>` 标签支持通过 `v-bind` CSS 函数来链接 CSS 值与组件状态。这允许在没有类型扩展的情况下自定义属性。\n\n- [CSS 中的 v-bind()](/api/sfc-css-features#v-bind-in-css)\n:::",
          "questions": [
            "`PropType<T>` 有什么作用？请举例说明。",
            "`MaybeRef<T>` 和 `MaybeRefOrGetter<T>` 分别是什么？它们在什么情况下会被使用？",
            "`ExtractPropTypes<T>` 和 `ExtractPublicPropTypes<T>` 有什么区别？请举例说明。",
            "`ComponentCustomProperties` 和 `ComponentCustomOptions` 分别用于什么？请举例说明。",
            "`ComponentCustomProps` 有什么作用？请举例说明。",
            "`CSSProperties` 用于扩展什么类型的值？请举例说明。",
            "如何在组件中使用 `PropType<T>`？",
            "如何在组合式函数中使用 `MaybeRef<T>` 和 `MaybeRefOrGetter<T>`？",
            "如何在组件中使用 `ComponentCustomProperties` 和 `ComponentCustomOptions`？",
            "如何在组件中使用 `ComponentCustomProps` 和 `CSSProperties`？"
          ]
        }
      ]
    },
    {
      "file_name": "application.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 应用实例 API {#application-api}\n\n## createApp() {#createapp}\n\n创建一个应用实例。\n\n- **类型**\n\n  ```ts\n  function createApp(rootComponent: Component, rootProps?: object): App\n  ```\n\n- **详细信息**\n\n  第一个参数是根组件。第二个参数可选，它是要传递给根组件的 props。\n\n- **示例**\n\n  可以直接内联根组件：\n\n  ```js\n  import { createApp } from 'vue'\n\n  const app = createApp({\n    /* 根组件选项 */\n  })\n  ```\n\n  也可以使用从别处导入的组件：\n\n  ```js\n  import { createApp } from 'vue'\n  import App from './App.vue'\n\n  const app = createApp(App)\n  ```\n\n- **参考**[指南 - 创建一个 Vue 应用实例](/guide/essentials/application)\n\n## createSSRApp() {#createssrapp}\n\n以 [SSR 激活](/guide/scaling-up/ssr#client-hydration)模式创建一个应用实例。用法与 `createApp()` 完全相同。\n\n## app.mount() {#app-mount}\n\n将应用实例挂载在一个容器元素中。\n\n- **类型**\n\n  ```ts\n  interface App {\n    mount(rootContainer: Element | string): ComponentPublicInstance\n  }\n  ```\n\n- **详细信息**\n\n  参数可以是一个实际的 DOM 元素或一个 CSS 选择器 (使用第一个匹配到的元素)。返回根组件的实例。\n\n  如果该组件有模板或定义了渲染函数，它将替换容器内所有现存的 DOM 节点。否则在运行时编译器可用的情况下，容器元素的 `innerHTML` 将被用作模板。\n\n  在 SSR 激活模式下，它将激活容器内现有的 DOM 节点。如果出现了[激活不匹配](/guide/scaling-up/ssr#hydration-mismatch)，那么现有的 DOM 节点将会被修改以匹配客户端的实际渲染结果。\n\n  对于每个应用实例，`mount()` 仅能调用一次。\n\n- **示例**\n\n  ```js\n  import { createApp } from 'vue'\n  const app = createApp(/* ... */)\n\n  app.mount('#app')\n  ```\n\n  也可以挂载到一个实际的 DOM 元素。\n\n  ```js\n  app.mount(document.body.firstChild)\n  ```\n\n## app.unmount() {#app-unmount}\n\n卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n\n- **类型**\n\n  ```ts\n  interface App {\n    unmount(): void\n  }\n  ```\n\n## app.component() {#app-component}\n\n如果同时传递一个组件名字符串及其定义，则注册一个全局组件；如果只传递一个名字，则会返回用该名字注册的组件 (如果存在的话)。\n\n- **类型**\n\n  ```ts\n  interface App {\n    component(name: string): Component | undefined\n    component(name: string, component: Component): this\n  }\n  ```\n\n- **示例**\n\n  ```js\n  import { createApp } from 'vue'\n\n  const app = createApp({})\n\n  // 注册一个选项对象\n  app.component('my-component', {\n    /* ... */\n  })\n\n  // 得到一个已注册的组件\n  const MyComponent = app.component('my-component')\n  ```\n\n- **参考**[组件注册](/guide/components/registration)\n\n## app.directive() {#app-directive}\n\n如果同时传递一个名字和一个指令定义，则注册一个全局指令；如果只传递一个名字，则会返回用该名字注册的指令 (如果存在的话)。\n\n- **类型**\n\n  ```ts\n  interface App {\n    directive(name: string): Directive | undefined\n    directive(name: string, directive: Directive): this\n  }\n  ```\n\n- **示例**\n\n  ```js\n  import { createApp } from 'vue'\n\n  const app = createApp({\n    /* ... */\n  })\n\n  // 注册（对象形式的指令）\n  app.directive('my-directive', {\n    /* 自定义指令钩子 */\n  })\n\n  // 注册（函数形式的指令）\n  app.directive('my-directive', () => {\n    /* ... */\n  })\n\n  // 得到一个已注册的指令\n  const myDirective = app.directive('my-directive')\n  ```\n\n- **参考**[自定义指令](/guide/reusability/custom-directives)\n\n## app.use() {#app-use}\n\n安装一个[插件](/guide/reusability/plugins)。\n\n- **类型**\n\n  ```ts\n  interface App {\n    use(plugin: Plugin, ...options: any[]): this\n  }\n  ```\n\n- **详细信息**\n\n  第一个参数应是插件本身，可选的第二个参数是要传递给插件的选项。\n\n  插件可以是一个带 `install()` 方法的对象，亦或直接是一个将被用作 `install()` 方法的函数。插件选项 (`app.use()` 的第二个参数) 将会传递给插件的 `install()` 方法。\n\n  若 `app.use()` 对同一个插件多次调用，该插件只会被安装一次。\n\n- **示例**\n\n  ```js\n  import { createApp } from 'vue'\n  import MyPlugin from './plugins/MyPlugin'\n\n  const app = createApp({\n    /* ... */\n  })\n\n  app.use(MyPlugin)\n  ```\n\n- **参考**[插件](/guide/reusability/plugins)\n\n## app.mixin() {#app-mixin}\n\n应用一个全局 mixin (适用于该应用的范围)。一个全局的 mixin 会作用于应用中的每个组件实例。\n\n:::warning 不推荐\nMixins 在 Vue 3 支持主要是为了向后兼容，因为生态中有许多库使用到。在新的应用中应尽量避免使用 mixin，特别是全局 mixin。\n\n若要进行逻辑复用，推荐用[组合式函数](/guide/reusability/composables)来替代。\n:::\n\n- **类型**\n\n  ```ts\n  interface App {\n    mixin(mixin: ComponentOptions): this\n  }\n  ```\n\n## app.provide() {#app-provide}\n\n提供一个值，可以在应用中的所有后代组件中注入使用。\n\n- **类型**\n\n  ```ts\n  interface App {\n    provide<T>(key: InjectionKey<T> | symbol | string, value: T): this\n  }\n  ```\n\n- **详细信息**\n\n  第一个参数应当是注入的 key，第二个参数则是提供的值。返回应用实例本身。\n\n- **示例**\n\n  ```js\n  import { createApp } from 'vue'\n\n  const app = createApp(/* ... */)\n\n  app.provide('message', 'hello')\n  ```\n\n  在应用的某个组件中：\n\n  <div class=\"composition-api\">\n\n  ```js\n  import { inject } from 'vue'\n\n  export default {\n    setup() {\n      console.log(inject('message')) // 'hello'\n    }\n  }\n  ```\n\n  </div>\n  <div class=\"options-api\">\n\n  ```js\n  export default {\n    inject: ['message'],\n    created() {\n      console.log(this.message) // 'hello'\n    }\n  }\n  ```\n\n  </div>\n\n- **参考**\n  - [依赖注入](/guide/components/provide-inject)\n  - [应用层 Provide](/guide/components/provide-inject#app-level-provide)\n  - [app.runWithContext()](#app-runwithcontext)\n\n## app.runWithContext()<sup class=\"vt-badge\" data-text=\"3.3+\" /> {#app-runwithcontext}\n\n使用当前应用作为注入上下文执行回调函数。\n\n- **类型**\n\n  ```ts\n  interface App {\n    runWithContext<T>(fn: () => T): T\n  }\n  ```\n\n- **详情**\n\n  需要一个回调函数并立即运行该回调。在回调同步调用期间，即使没有当前活动的组件实例，`inject()` 调用也可以从当前应用提供的值中查找注入。回调的返回值也将被返回。\n\n- **示例**\n\n  ```js\n  import { inject } from 'vue'\n\n  app.provide('id', 1)\n\n  const injected = app.runWithContext(() => {\n    return inject('id')\n  })\n\n  console.log(injected) // 1\n  ```\n\n## app.version {#app-version}\n\n提供当前应用所使用的 Vue 版本号。这在[插件](/guide/reusability/plugins)中很有用，因为可能需要根据不同的 Vue 版本执行不同的逻辑。\n\n- **类型**\n\n  ```ts\n  interface App {\n    version: string\n  }\n  ```\n\n- **示例**\n\n  在一个插件中对版本作判断：\n\n  ```js\n  export default {\n    install(app) {\n      const version = Number(app.version.split('.')[0])\n      if (version < 3) {\n        console.warn('This plugin requires Vue 3')\n      }\n    }\n  }\n  ```\n\n- **参考**[全局 API - version](/api/general#version)\n\n## app.config {#app-config}\n\n每个应用实例都会暴露一个 `config` 对象，其中包含了对这个应用的配置设定。你可以在挂载应用前更改这些属性 (下面列举了每个属性的对应文档)。\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp(/* ... */)\n\nconsole.log(app.config)\n```\n\n## app.config.errorHandler {#app-config-errorhandler}\n\n用于为应用内抛出的未捕获错误指定一个全局处理函数。\n\n- **类型**\n\n  ```ts\n  interface AppConfig {\n    errorHandler?: (\n      err: unknown,\n      instance: ComponentPublicInstance | null,\n      // `info` 是一个 Vue 特定的错误信息\n      // 例如：错误是在哪个生命周期的钩子上抛出的\n      info: string\n    ) => void\n  }\n  ```\n\n- **详细信息**\n\n  错误处理器接收三个参数：错误对象、触发该错误的组件实例和一个指出错误来源类型信息的字符串。\n\n  它可以从下面这些来源中捕获错误：\n\n  - 组件渲染器\n  - 事件处理器\n  - 生命周期钩子\n  - `setup()` 函数\n  - 侦听器\n  - 自定义指令钩子\n  - 过渡 (Transition) 钩子\n\n- **示例**\n\n  ```js\n  app.config.errorHandler = (err, instance, info) => {\n    // 处理错误，例如：报告给一个服务\n  }\n  ```",
          "questions": [
            "`createApp()` 方法的第一个参数是什么？第二个参数是可选的吗？",
            "`mount()` 方法的参数可以是什么？返回值是什么？",
            "`component()` 方法的第一个参数是什么？第二个参数是什么？",
            "`directive()` 方法的第一个参数是什么？第二个参数是什么？",
            "`use()` 方法的第一个参数是什么？第二个参数是什么？",
            "`mixin()` 方法的作用是什么？它会作用于哪些组件实例？",
            "`provide()` 方法的第一个参数应当是什么？第二个参数是什么？它们的作用是什么？",
            "`runWithContext()` 方法的作用是什么？它需要传递什么参数？返回值是什么？",
            "`version` 属性提供了什么信息？",
            "`config` 对象中的 `errorHandler` 属性的作用是什么？它接收哪些参数？"
          ]
        },
        {
          "content": "## app.config.warnHandler {#app-config-warnhandler}\n\n用于为 Vue 的运行时警告指定一个自定义处理函数。\n\n- **类型**\n\n  ```ts\n  interface AppConfig {\n    warnHandler?: (\n      msg: string,\n      instance: ComponentPublicInstance | null,\n      trace: string\n    ) => void\n  }\n  ```\n\n- **详细信息**\n\n  警告处理器将接受警告信息作为其第一个参数，来源组件实例为第二个参数，以及组件追踪字符串作为第三个参数。\n\n  这可以用户过滤筛选特定的警告信息，降低控制台输出的冗余。所有的 Vue 警告都需要在开发阶段得到解决，因此仅建议在调试期间选取部分特定警告，并且应该在调试完成之后立刻移除。\n\n  :::tip\n  警告仅会在开发阶段显示，因此在生产环境中，这条配置将被忽略。\n  :::\n\n- **示例**\n\n  ```js\n  app.config.warnHandler = (msg, instance, trace) => {\n    // `trace` 是组件层级结构的追踪\n  }\n  ```\n\n## app.config.performance {#app-config-performance}\n\n设置此项为 `true` 可以在浏览器开发工具的“性能/时间线”页中启用对组件初始化、编译、渲染和修补的性能表现追踪。仅在开发模式和支持 [performance.mark](https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark) API 的浏览器中工作。\n\n- **类型**：`boolean`\n\n- **参考**[指南 - 性能](/guide/best-practices/performance)\n\n## app.config.compilerOptions {#app-config-compileroptions}\n\n配置运行时编译器的选项。设置在此对象上的值将会在浏览器内进行模板编译时使用，并会影响到所配置应用的所有组件。另外你也可以通过 [`compilerOptions` 选项](/api/options-rendering#compileroptions)在每个组件的基础上覆盖这些选项。\n\n::: warning 重要\n此配置项仅在完整构建版本，即可以在浏览器中编译模板的 `vue.js` 文件中可用。如果你用的是带构建的项目配置，且使用的是仅含运行时的 Vue 文件版本，那么编译器选项必须通过构建工具的相关配置传递给 `@vue/compiler-dom`。\n\n- `vue-loader`：[通过 `compilerOptions` loader 的选项传递](https://vue-loader.vuejs.org/zh/options.html#compileroptions)。并请阅读[如何在 `vue-cli` 中配置它](https://cli.vuejs.org/zh/guide/webpack.html#%E4%BF%AE%E6%94%B9-loader-%E9%80%89%E9%A1%B9)。\n\n- `vite`：[通过 `@vitejs/plugin-vue` 的选项传递](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#options)。\n:::\n\n### app.config.compilerOptions.isCustomElement {#app-config-compileroptions-iscustomelement}\n\n用于指定一个检查方法来识别原生自定义元素。\n\n- **类型** `(tag: string) => boolean`\n\n- **详细信息**\n\n  如果该标签需要当作原生自定义元素则应返回 `true`。对匹配到的标签，Vue 会将其渲染为原生元素而非将其视为一个 Vue 组件来解析。\n\n  原生 HTML 和 SVG 标签不需要在此函数中进行匹配，Vue 的解析器会自动识别它们。\n\n- **示例**\n\n  ```js\n  // 将所有标签前缀为 `ion-` 的标签视为自定义元素\n  app.config.compilerOptions.isCustomElement = (tag) => {\n    return tag.startsWith('ion-')\n  }\n  ```\n\n- **参考** [Vue 与 Web Components](/guide/extras/web-components)\n\n### app.config.compilerOptions.whitespace {#app-config-compileroptions-whitespace}\n\n用于调整模板中空格的处理行为。\n\n- **类型** `'condense' | 'preserve'`\n\n- **默认** `'condense'`\n\n- **详细信息**\n\n  Vue 移除/缩短了模板中的空格以求更高效的模板输出。默认的策略是“缩短”，表现行为如下：\n\n  1. 元素中开头和结尾的空格字符将被缩短为一个空格。\n  2. 包含换行的元素之间的空白字符会被删除。\n  3. 文本节点中连续的空白字符被缩短成一个空格。\n\n  设置该选项为 `'preserve'` 则会禁用 (2) 和 (3) 两项。\n\n- **示例**\n\n  ```js\n  app.config.compilerOptions.whitespace = 'preserve'\n  ```\n\n### app.config.compilerOptions.delimiters {#app-config-compileroptions-delimiters}\n\n用于调整模板内文本插值的分隔符。\n\n- **类型** `[string, string]`\n\n- **默认** `{{ \"['\\u007b\\u007b', '\\u007d\\u007d']\" }}`\n\n- **详细信息**\n\n  此项通常是为了避免与同样使用 mustache 语法的服务器端框架发生冲突。\n\n- **示例**\n\n  ```js\n  // 分隔符改为ES6模板字符串样式\n  app.config.compilerOptions.delimiters = ['${', '}']\n  ```\n\n### app.config.compilerOptions.comments {#app-config-compileroptions-comments}\n\n用于调整是否移除模板中的 HTML 注释。\n\n- **类型** `boolean`\n\n- **默认** `false`\n\n- **详细信息**\n\n  默认情况下，Vue 会在生产环境移除所有注释，设置该项为 `true` 会强制 Vue 在生产环境也保留注释。在开发过程中，注释是始终被保留的。这个选项通常在 Vue 与其他依赖 HTML 注释的库一起使用时使用。\n\n- **示例**\n\n  ```js\n  app.config.compilerOptions.comments = true\n  ```\n\n## app.config.globalProperties {#app-config-globalproperties}\n\n一个用于注册能够被应用内所有组件实例访问到的全局属性的对象。\n\n- **类型**\n\n  ```ts\n  interface AppConfig {\n    globalProperties: Record<string, any>\n  }\n  ```\n\n- **详细信息**\n\n  这是对 Vue 2 中 `Vue.prototype` 使用方式的一种替代，此写法在 Vue 3 已经不存在了。与任何全局的东西一样，应该谨慎使用。\n\n  如果全局属性与组件自己的属性冲突，组件自己的属性将具有更高的优先级。\n\n- **用法**\n\n  ```js\n  app.config.globalProperties.msg = 'hello'\n  ```\n\n  这使得 `msg` 在应用的任意组件模板上都可用，并且也可以通过任意组件实例的 `this` 访问到：\n\n  ```js\n  export default {\n    mounted() {\n      console.log(this.msg) // 'hello'\n    }\n  }\n  ```\n\n- **参考**[指南 - 扩展全局属性](/guide/typescript/options-api#augmenting-global-properties) <sup class=\"vt-badge ts\" />\n\n## app.config.optionMergeStrategies {#app-config-optionmergestrategies}\n\n一个用于定义自定义组件选项的合并策略的对象。\n\n- **类型**\n\n  ```ts\n  interface AppConfig {\n    optionMergeStrategies: Record<string, OptionMergeFunction>\n  }\n\n  type OptionMergeFunction = (to: unknown, from: unknown) => any\n  ```\n\n- **详细信息**\n\n  一些插件或库对自定义组件选项添加了支持 (通过注入全局 mixin)。这些选项在有多个不同来源时可能需要特殊的合并策略 (例如 mixin 或组件继承)。\n\n  可以在 `app.config.optionMergeStrategies` 对象上以选项的名称作为 key，可以为一个自定义选项注册分配一个合并策略函数。\n\n  合并策略函数分别接受在父实例和子实例上定义的该选项的值作为第一和第二个参数。\n\n- **示例**\n\n  ```js\n  const app = createApp({\n    // 自身的选项\n    msg: 'Vue',\n    // 来自 mixin 的选项\n    mixins: [\n      {\n        msg: 'Hello '\n      }\n    ],\n    mounted() {\n      // 在 this.$options 上暴露被合并的选项\n      console.log(this.$options.msg)\n    }\n  })\n\n  // 为 `msg` 定义一个合并策略函数\n  app.config.optionMergeStrategies.msg = (parent, child) => {\n    return (parent || '') + (child || '')\n  }\n\n  app.mount('#app')\n  // 打印 'Hello Vue'\n  ```\n\n- **参考**[组件实例 - `$options`](/api/component-instance#options)",
          "questions": [
            "`app.config.warnHandler` 的作用是什么？它接受哪些参数？",
            "`app.config.performance` 的作用是什么？它只在哪些情况下工作？",
            "`app.config.compilerOptions` 的作用是什么？它包含哪些选项？",
            "`app.config.compilerOptions.isCustomElement` 的作用是什么？它接受哪些参数？",
            "`app.config.compilerOptions.whitespace` 的作用是什么？它有哪些选项？",
            "`app.config.compilerOptions.delimiters` 的作用是什么？它接受哪些参数？",
            "`app.config.compilerOptions.comments` 的作用是什么？它接受哪些参数？",
            "`app.config.globalProperties` 的作用是什么？它接受哪些参数？",
            "`app.config.optionMergeStrategies` 的作用是什么？它接受哪些参数？",
            "如何为 `msg` 自定义一个合并策略函数？"
          ]
        }
      ]
    },
    {
      "file_name": "reactivity-utilities.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 响应式 API：工具函数 {#reactivity-api-utilities}\n\n## isRef() {#isref}\n\n检查某个值是否为 ref。\n\n- **类型**\n\n  ```ts\n  function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\n  ```\n\n  请注意，返回值是一个[类型判定](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) (type predicate)，这意味着 `isRef` 可以被用作类型守卫：\n\n  ```ts\n  let foo: unknown\n  if (isRef(foo)) {\n    // foo 的类型被收窄为了 Ref<unknown>\n    foo.value\n  }\n  ```\n\n## unref() {#unref}\n\n如果参数是 ref，则返回内部值，否则返回参数本身。这是 `val = isRef(val) ? val.value : val` 计算的一个语法糖。\n\n- **类型**\n\n  ```ts\n  function unref<T>(ref: T | Ref<T>): T\n  ```\n\n- **示例**\n\n  ```ts\n  function useFoo(x: number | Ref<number>) {\n    const unwrapped = unref(x)\n    // unwrapped 现在保证为 number 类型\n  }\n  ```\n\n## toRef() {#toref}\n\n可以将值、refs 或 getters 规范化为 refs (3.3+)。\n\n也可以基于响应式对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。\n\n- **类型**\n\n  ```ts\n  // 规范化签名 (3.3+)\n  function toRef<T>(\n    value: T\n  ): T extends () => infer R\n    ? Readonly<Ref<R>>\n    : T extends Ref\n    ? T\n    : Ref<UnwrapRef<T>>\n\n  // 对象属性签名\n  function toRef<T extends object, K extends keyof T>(\n    object: T,\n    key: K,\n    defaultValue?: T[K]\n  ): ToRef<T[K]>\n\n  type ToRef<T> = T extends Ref ? T : Ref<T>\n  ```\n\n- **示例**\n\n  规范化签名 (3.3+)：\n\n  ```js\n  // 按原样返回现有的 ref\n  toRef(existingRef)\n\n  // 创建一个只读的 ref，当访问 .value 时会调用此 getter 函数\n  toRef(() => props.foo)\n\n  // 从非函数的值中创建普通的 ref\n  // 等同于 ref(1)\n  toRef(1)\n  ```\n\n  对象属性签名：\n\n  ```js\n  const state = reactive({\n    foo: 1,\n    bar: 2\n  })\n\n  // 双向 ref，会与源属性同步\n  const fooRef = toRef(state, 'foo')\n\n  // 更改该 ref 会更新源属性\n  fooRef.value++\n  console.log(state.foo) // 2\n\n  // 更改源属性也会更新该 ref\n  state.foo++\n  console.log(fooRef.value) // 3\n  ```\n\n  请注意，这不同于：\n\n  ```js\n  const fooRef = ref(state.foo)\n  ```\n\n  上面这个 ref **不会**和 `state.foo` 保持同步，因为这个 `ref()` 接收到的是一个纯数值。\n\n  `toRef()` 这个函数在你想把一个 prop 的 ref 传递给一个组合式函数时会很有用：\n\n  ```vue\n  <script setup>\n  import { toRef } from 'vue'\n\n  const props = defineProps(/* ... */)\n\n  // 将 `props.foo` 转换为 ref，然后传入\n  // 一个组合式函数\n  useSomeFeature(toRef(props, 'foo'))\n\n  // getter 语法——推荐在 3.3+ 版本使用\n  useSomeFeature(toRef(() => props.foo))\n  </script>\n  ```\n\n  当 `toRef` 与组件 props 结合使用时，关于禁止对 props 做出更改的限制依然有效。尝试将新的值传递给 ref 等效于尝试直接更改 props，这是不允许的。在这种场景下，你可能可以考虑使用带有 `get` 和 `set` 的 [`computed`](./reactivity-core#computed) 替代。详情请见[在组件上使用 `v-model`](/guide/components/v-model) 指南。\n\n  当使用对象属性签名时，即使源属性当前不存在，`toRef()` 也会返回一个可用的 ref。这让它在处理可选 props 的时候格外实用，相比之下 [`toRefs`](#torefs) 就不会为可选 props 创建对应的 refs。\n\n## toValue() <sup class=\"vt-badge\" data-text=\"3.3+\" /> {#tovalue}\n\n将值、refs 或 getters 规范化为值。这与 [unref()](#unref) 类似，不同的是此函数也会规范化 getter 函数。如果参数是一个 getter，它将会被调用并且返回它的返回值。\n\n这可以在[组合式函数](/guide/reusability/composables.html)中使用，用来规范化一个可以是值、ref 或 getter 的参数。\n\n- **类型**\n\n  ```ts\n  function toValue<T>(source: T | Ref<T> | (() => T)): T\n  ```\n\n- **示例**\n\n  ```js\n  toValue(1) //       --> 1\n  toValue(ref(1)) //  --> 1\n  toValue(() => 1) // --> 1\n  ```\n\n  在组合式函数中规范化参数：\n\n  ```ts\n  import type { MaybeRefOrGetter } from 'vue'\n\n  function useFeature(id: MaybeRefOrGetter<number>) {\n    watch(() => toValue(id), id => {\n      // 处理 id 变更\n    })\n  }\n\n  // 这个组合式函数支持以下的任意形式：\n  useFeature(1)\n  useFeature(ref(1))\n  useFeature(() => 1)\n  ```\n\n## toRefs() {#torefs}\n\n将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 [`toRef()`](#toref) 创建的。\n\n- **类型**\n\n  ```ts\n  function toRefs<T extends object>(\n    object: T\n  ): {\n    [K in keyof T]: ToRef<T[K]>\n  }\n\n  type ToRef = T extends Ref ? T : Ref<T>\n  ```\n\n- **示例**\n\n  ```js\n  const state = reactive({\n    foo: 1,\n    bar: 2\n  })\n\n  const stateAsRefs = toRefs(state)\n  /*\n  stateAsRefs 的类型：{\n    foo: Ref<number>,\n    bar: Ref<number>\n  }\n  */\n\n  // 这个 ref 和源属性已经“链接上了”\n  state.foo++\n  console.log(stateAsRefs.foo.value) // 2\n\n  stateAsRefs.foo.value++\n  console.log(state.foo) // 3\n  ```\n\n  当从组合式函数中返回响应式对象时，`toRefs` 相当有用。使用它，消费者组件可以解构/展开返回的对象而不会失去响应性：\n\n  ```js\n  function useFeatureX() {\n    const state = reactive({\n      foo: 1,\n      bar: 2\n    })\n\n    // ...基于状态的操作逻辑\n\n    // 在返回时都转为 ref\n    return toRefs(state)\n  }\n\n  // 可以解构而不会失去响应性\n  const { foo, bar } = useFeatureX()\n  ```\n\n  `toRefs` 在调用时只会为源对象上可以枚举的属性创建 ref。如果要为可能还不存在的属性创建 ref，请改用 [`toRef`](#toref)。\n\n## isProxy() {#isproxy}\n\n检查一个对象是否是由 [`reactive()`](./reactivity-core#reactive)、[`readonly()`](./reactivity-core#readonly)、[`shallowReactive()`](./reactivity-advanced#shallowreactive) 或 [`shallowReadonly()`](./reactivity-advanced#shallowreadonly) 创建的代理。\n\n- **类型**\n\n  ```ts\n  function isProxy(value: unknown): boolean\n  ```\n\n## isReactive() {#isreactive}\n\n检查一个对象是否是由 [`reactive()`](./reactivity-core#reactive) 或 [`shallowReactive()`](./reactivity-advanced#shallowreactive) 创建的代理。\n\n- **类型**\n\n  ```ts\n  function isReactive(value: unknown): boolean\n  ```\n\n## isReadonly() {#isreadonly}\n\n检查传入的值是否为只读对象。只读对象的属性可以更改，但他们不能通过传入的对象直接赋值。\n\n通过 [`readonly()`](./reactivity-core#readonly) 和 [`shallowReadonly()`](./reactivity-advanced#shallowreadonly) 创建的代理都是只读的，因为他们是没有 `set` 函数的 [`computed()`](./reactivity-core#computed) ref。\n\n- **类型**\n\n  ```ts\n  function isReadonly(value: unknown): boolean\n  ```",
          "questions": [
            "`isRef()` 函数的返回值是什么类型？",
            "`isRef()` 函数可以被用作什么？",
            "`unref()` 函数的作用是什么？",
            "`toRef()` 函数可以将哪些类型的值规范化为 ref？",
            "`toRef()` 函数可以基于哪些对象属性创建对应的 ref？",
            "`toRefs()` 函数的作用是什么？",
            "`toRefs()` 函数在调用时会为哪些属性创建 ref？",
            "`isProxy()` 函数的作用是什么？",
            "`isReactive()` 函数的作用是什么？",
            "`isReadonly()` 函数的作用是什么？"
          ]
        }
      ]
    },
    {
      "file_name": "reactivity-advanced.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 响应式 API：进阶 {#reactivity-api-advanced}\n\n## shallowRef() {#shallowref}\n\n[`ref()`](./reactivity-core#ref) 的浅层作用形式。\n\n- **类型**\n\n  ```ts\n  function shallowRef<T>(value: T): ShallowRef<T>\n\n  interface ShallowRef<T> {\n    value: T\n  }\n  ```\n\n- **详细信息**\n\n  和 `ref()` 不同，浅层 ref 的内部值将会原样存储和暴露，并且不会被深层递归地转为响应式。只有对 `.value` 的访问是响应式的。\n\n  `shallowRef()` 常常用于对大型数据结构的性能优化或是与外部的状态管理系统集成。\n\n- **示例**\n\n  ```js\n  const state = shallowRef({ count: 1 })\n\n  // 不会触发更改\n  state.value.count = 2\n\n  // 会触发更改\n  state.value = { count: 2 }\n  ```\n\n- **参考**\n  - [指南 - 减少大型不可变结构的响应性开销](/guide/best-practices/performance#reduce-reactivity-overhead-for-large-immutable-structures)\n  - [指南 - 与其他状态系统集成](/guide/extras/reactivity-in-depth#integration-with-external-state-systems)\n\n## triggerRef() {#triggerref}\n\n强制触发依赖于一个[浅层 ref](#shallowref) 的副作用，这通常在对浅引用的内部值进行深度变更后使用。\n\n- **类型**\n\n  ```ts\n  function triggerRef(ref: ShallowRef): void\n  ```\n\n- **示例**\n\n  ```js\n  const shallow = shallowRef({\n    greet: 'Hello, world'\n  })\n\n  // 触发该副作用第一次应该会打印 \"Hello, world\"\n  watchEffect(() => {\n    console.log(shallow.value.greet)\n  })\n\n  // 这次变更不应触发副作用，因为这个 ref 是浅层的\n  shallow.value.greet = 'Hello, universe'\n\n  // 打印 \"Hello, universe\"\n  triggerRef(shallow)\n  ```\n\n## customRef() {#customref}\n\n创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。\n\n- **类型**\n\n  ```ts\n  function customRef<T>(factory: CustomRefFactory<T>): Ref<T>\n\n  type CustomRefFactory<T> = (\n    track: () => void,\n    trigger: () => void\n  ) => {\n    get: () => T\n    set: (value: T) => void\n  }\n  ```\n\n- **详细信息**\n\n  `customRef()` 预期接收一个工厂函数作为参数，这个工厂函数接受 `track` 和 `trigger` 两个函数作为参数，并返回一个带有 `get` 和 `set` 方法的对象。\n\n  一般来说，`track()` 应该在 `get()` 方法中调用，而 `trigger()` 应该在 `set()` 中调用。然而事实上，你对何时调用、是否应该调用他们有完全的控制权。\n\n- **示例**\n\n  创建一个防抖 ref，即只在最近一次 set 调用后的一段固定间隔后再调用：\n\n  ```js\n  import { customRef } from 'vue'\n\n  export function useDebouncedRef(value, delay = 200) {\n    let timeout\n    return customRef((track, trigger) => {\n      return {\n        get() {\n          track()\n          return value\n        },\n        set(newValue) {\n          clearTimeout(timeout)\n          timeout = setTimeout(() => {\n            value = newValue\n            trigger()\n          }, delay)\n        }\n      }\n    })\n  }\n  ```\n\n  在组件中使用：\n\n  ```vue\n  <script setup>\n  import { useDebouncedRef } from './debouncedRef'\n  const text = useDebouncedRef('hello')\n  </script>\n\n  <template>\n    <input v-model=\"text\" />\n  </template>\n  ```\n\n  [在演练场中尝试一下](https://play.vuejs.org/#eNplUkFugzAQ/MqKC1SiIekxIpEq9QVV1BMXCguhBdsyaxqE/PcuGAhNfYGd3Z0ZDwzeq1K7zqB39OI205UiaJGMOieiapTUBAOYFt/wUxqRYf6OBVgotGzA30X5Bt59tX4iMilaAsIbwelxMfCvWNfSD+Gw3++fEhFHTpLFuCBsVJ0ScgUQjw6Az+VatY5PiroHo3IeaeHANlkrh7Qg1NBL43cILUmlMAfqVSXK40QUOSYmHAZHZO0KVkIZgu65kTnWp8Qb+4kHEXfjaDXkhd7DTTmuNZ7MsGyzDYbz5CgSgbdppOBFqqT4l0eX1gZDYOm057heOBQYRl81coZVg9LQWGr+IlrchYKAdJp9h0C6KkvUT3A6u8V1dq4ASqRgZnVnWg04/QWYNyYzC2rD5Y3/hkDgz8fY/cOT1ZjqizMZzGY3rDPC12KGZYyd3J26M8ny1KKx7c3X25q1c1wrZN3L9LCMWs/+AmeG6xI=)\n\n## shallowReactive() {#shallowreactive}\n\n[`reactive()`](./reactivity-core#reactive) 的浅层作用形式。\n\n- **类型**\n\n  ```ts\n  function shallowReactive<T extends object>(target: T): T\n  ```\n\n- **详细信息**\n\n  和 `reactive()` 不同，这里没有深层级的转换：一个浅层响应式对象里只有根级别的属性是响应式的。属性的值会被原样存储和暴露，这也意味着值为 ref 的属性**不会**被自动解包了。\n\n  :::warning 谨慎使用\n  浅层数据结构应该只用于组件中的根级状态。请避免将其嵌套在深层次的响应式对象中，因为它创建的树具有不一致的响应行为，这可能很难理解和调试。\n  :::\n\n- **示例**\n\n  ```js\n  const state = shallowReactive({\n    foo: 1,\n    nested: {\n      bar: 2\n    }\n  })\n\n  // 更改状态自身的属性是响应式的\n  state.foo++\n\n  // ...但下层嵌套对象不会被转为响应式\n  isReactive(state.nested) // false\n\n  // 不是响应式的\n  state.nested.bar++\n  ```\n\n## shallowReadonly() {#shallowreadonly}\n\n[`readonly()`](./reactivity-core#readonly) 的浅层作用形式\n\n- **类型**\n\n  ```ts\n  function shallowReadonly<T extends object>(target: T): Readonly<T>\n  ```\n\n- **详细信息**\n\n  和 `readonly()` 不同，这里没有深层级的转换：只有根层级的属性变为了只读。属性的值都会被原样存储和暴露，这也意味着值为 ref 的属性**不会**被自动解包了。\n\n  :::warning 谨慎使用\n  浅层数据结构应该只用于组件中的根级状态。请避免将其嵌套在深层次的响应式对象中，因为它创建的树具有不一致的响应行为，这可能很难理解和调试。\n  :::\n\n- **示例**\n\n  ```js\n  const state = shallowReadonly({\n    foo: 1,\n    nested: {\n      bar: 2\n    }\n  })\n\n  // 更改状态自身的属性会失败\n  state.foo++\n\n  // ...但可以更改下层嵌套对象\n  isReadonly(state.nested) // false\n\n  // 这是可以通过的\n  state.nested.bar++\n  ```\n\n## toRaw() {#toraw}\n\n根据一个 Vue 创建的代理返回其原始对象。\n\n- **类型**\n\n  ```ts\n  function toRaw<T>(proxy: T): T\n  ```\n\n- **详细信息**\n\n  `toRaw()` 可以返回由 [`reactive()`](./reactivity-core#reactive)、[`readonly()`](./reactivity-core#readonly)、[`shallowReactive()`](#shallowreactive) 或者 [`shallowReadonly()`](#shallowreadonly) 创建的代理对应的原始对象。\n\n  这是一个可以用于临时读取而不引起代理访问/跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。\n\n- **示例**\n\n  ```js\n  const foo = {}\n  const reactiveFoo = reactive(foo)\n\n  console.log(toRaw(reactiveFoo) === foo) // true\n  ```",
          "questions": [
            "shallowRef 和 ref 有什么区别？",
            "shallowRef 适用于哪些场景？",
            "shallowRef 内部值会被转为响应式吗？",
            "triggerRef 用于什么场景？",
            "triggerRef 会触发哪些副作用？",
            "customRef 的工厂函数需要接收哪些参数？",
            "customRef 的工厂函数应该在哪些方法中调用 track 和 trigger？",
            "shallowReactive 和 reactive 有什么区别？",
            "shallowReactive 适用于哪些场景？",
            "toRaw 方法的作用是什么？"
          ]
        },
        {
          "content": "## markRaw() {#markraw}\n\n将一个对象标记为不可被转为代理。返回该对象本身。\n\n- **类型**\n\n  ```ts\n  function markRaw<T extends object>(value: T): T\n  ```\n\n- **示例**\n\n  ```js\n  const foo = markRaw({})\n  console.log(isReactive(reactive(foo))) // false\n\n  // 也适用于嵌套在其他响应性对象\n  const bar = reactive({ foo })\n  console.log(isReactive(bar.foo)) // false\n  ```\n\n  :::warning 谨慎使用\n  `markRaw()` 和类似 `shallowReactive()` 这样的浅层式 API 使你可以有选择地避开默认的深度响应/只读转换，并在状态关系谱中嵌入原始的、非代理的对象。它们可能出于各种各样的原因被使用：\n\n  - 有些值不应该是响应式的，例如复杂的第三方类实例或 Vue 组件对象。\n\n  - 当呈现带有不可变数据源的大型列表时，跳过代理转换可以提高性能。\n\n  这应该是一种进阶需求，因为只在根层访问能到原始值，所以如果把一个嵌套的、没有标记的原始对象设置成一个响应式对象，然后再次访问它，你获取到的是代理的版本。这可能会导致**对象身份风险**，即执行一个依赖于对象身份的操作，但却同时使用了同一对象的原始版本和代理版本：\n\n  ```js\n  const foo = markRaw({\n    nested: {}\n  })\n\n  const bar = reactive({\n    // 尽管 `foo` 被标记为了原始对象，但 foo.nested 却没有\n    nested: foo.nested\n  })\n\n  console.log(foo.nested === bar.nested) // false\n  ```\n\n  识别风险一般是很罕见的。然而，要正确使用这些 API，同时安全地避免这样的风险，需要你对响应性系统的工作方式有充分的了解。\n\n  :::\n\n## effectScope() {#effectscope}\n\n创建一个 effect 作用域，可以捕获其中所创建的响应式副作用 (即计算属性和侦听器)，这样捕获到的副作用可以一起处理。对于该 API 的使用细节，请查阅对应的 [RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md)。\n\n- **类型**\n\n  ```ts\n  function effectScope(detached?: boolean): EffectScope\n\n  interface EffectScope {\n    run<T>(fn: () => T): T | undefined // 如果作用域不活跃就为 undefined\n    stop(): void\n  }\n  ```\n\n- **示例**\n\n  ```js\n  const scope = effectScope()\n\n  scope.run(() => {\n    const doubled = computed(() => counter.value * 2)\n\n    watch(doubled, () => console.log(doubled.value))\n\n    watchEffect(() => console.log('Count: ', doubled.value))\n  })\n\n  // 处理掉当前作用域内的所有 effect\n  scope.stop()\n  ```\n\n## getCurrentScope() {#getcurrentscope}\n\n如果有的话，返回当前活跃的 [effect 作用域](#effectscope)。\n\n- **类型**\n\n  ```ts\n  function getCurrentScope(): EffectScope | undefined\n  ```\n\n## onScopeDispose() {#onscopedispose}\n\n在当前活跃的 [effect 作用域](#effectscope)上注册一个处理回调函数。当相关的 effect 作用域停止时会调用这个回调函数。\n\n这个方法可以作为可复用的组合式函数中 `onUnmounted` 的替代品，它并不与组件耦合，因为每一个 Vue 组件的 `setup()` 函数也是在一个 effect 作用域中调用的。\n\n- **类型**\n\n  ```ts\n  function onScopeDispose(fn: () => void): void\n  ```",
          "questions": [
            "`markRaw()` 的作用是什么？它的返回值是什么？",
            "为什么有时候需要使用 `markRaw()` 来标记一个对象为不可被转为代理？",
            "`markRaw()` 和 `shallowReactive()` 这样的浅层式 API 可能会带来什么风险？如何避免这些风险？",
            "`effectScope()` 的作用是什么？它可以捕获哪些响应式副作用？",
            "`effectScope()` 的返回值是什么？它有哪些方法？",
            "如何使用 `effectScope()` 来处理多个响应式副作用？",
            "`getCurrentScope()` 的作用是什么？它返回的值是什么？",
            "`onScopeDispose()` 的作用是什么？它的参数是什么类型？",
            "`onScopeDispose()` 可以替代哪个组合式函数中的 `onUnmounted`？为什么？",
            "`onScopeDispose()` 与组件的耦合度如何？为什么？"
          ]
        }
      ]
    },
    {
      "file_name": "component-instance.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 组件实例 {#component-instance}\n\n:::info\n本页文档描述了组件公共实例 (即 `this`) 上暴露的内置属性和方法，\n\n本页罗列的所有属性，除了 `$data` 下的嵌套属性之外，都是只读的。\n:::\n\n## $data {#data}\n\n从 [`data`](./options-state#data) 选项函数中返回的对象，会被组件赋为响应式。组件实例将会代理对其数据对象的属性访问。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $data: object\n  }\n  ```\n\n## $props {#props}\n\n表示组件当前已解析的 props 对象。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $props: object\n  }\n  ```\n\n- **详细信息**\n\n  这里只包含通过 [`props`](./options-state#props) 选项声明的 props。组件实例将会代理对其 props 对象上属性的访问。\n\n## $el {#el}\n\n该组件实例管理的 DOM 根节点。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $el: Node | undefined\n  }\n  ```\n\n- **详细信息**\n\n  `$el` 直到组件[挂载完成 (mounted)](./options-lifecycle#mounted) 之前都会是 `undefined`。\n\n  - 对于单一根元素的组件，`$el` 将会指向该根元素。\n  - 对于以文本节点为根的组件，`$el` 将会指向该文本节点。\n  - 对于以多个元素为根的组件，`$el` 将是一个仅作占位符的 DOM 节点，Vue 使用它来跟踪组件在 DOM 中的位置 (文本节点或 SSR 激活模式下的注释节点)。\n\n  :::tip\n  为保持一致性，我们推荐使用[模板引用](/guide/essentials/template-refs)来直接访问元素而不是依赖 `$el`。\n  :::\n\n## $options {#options}\n\n已解析的用于实例化当前组件的组件选项。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $options: ComponentOptions\n  }\n  ```\n\n- **详细信息**\n\n  这个 `$options` 对象暴露了当前组件的已解析选项，并且会是以下几种可能来源的合并结果：\n\n  - 全局 mixin\n  - 组件 `extends` 的基组件\n  - 组件级 mixin\n\n  它通常用于支持自定义组件选项：\n\n  ```js\n  const app = createApp({\n    customOption: 'foo',\n    created() {\n      console.log(this.$options.customOption) // => 'foo'\n    }\n  })\n  ```\n\n- **参考** [`app.config.optionMergeStrategies`](/api/application#app-config-optionmergestrategies)\n\n## $parent {#parent}\n\n当前组件可能存在的父组件实例，如果当前组件是顶层组件，则为 `null`。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $parent: ComponentPublicInstance | null\n  }\n  ```\n\n## $root {#root}\n\n当前组件树的根组件实例。如果当前实例没有父组件，那么这个值就是它自己。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $root: ComponentPublicInstance\n  }\n  ```\n\n## $slots {#slots}\n\n一个表示父组件所传入[插槽](/guide/components/slots)的对象。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $slots: { [name: string]: Slot }\n  }\n\n  type Slot = (...args: any[]) => VNode[]\n  ```\n\n- **详细信息**\n\n  通常用于手写[渲染函数](/guide/extras/render-function)，但也可用于检测是否存在插槽。\n\n  每一个插槽都在 `this.$slots` 上暴露为一个函数，返回一个 vnode 数组，同时 key 名对应着插槽名。默认插槽暴露为 `this.$slots.default`。\n\n  如果插槽是一个[作用域插槽](/guide/components/slots#scoped-slots)，传递给该插槽函数的参数可以作为插槽的 prop 提供给插槽。\n\n- **参考**[渲染函数 - 渲染插槽](/guide/extras/render-function#rendering-slots)\n\n## $refs {#refs}\n\n一个包含 DOM 元素和组件实例的对象，通过[模板引用](/guide/essentials/template-refs)注册。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $refs: { [name: string]: Element | ComponentPublicInstance | null }\n  }\n  ```\n\n- **参考**\n\n  - [模板引用](/guide/essentials/template-refs)\n  - [特殊 Attribute - ref](./built-in-special-attributes.md#ref)\n\n## $attrs {#attrs}\n\n一个包含了组件所有透传 attributes 的对象。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $attrs: object\n  }\n  ```\n\n- **详细信息**\n\n  [透传 Attributes](/guide/components/attrs) 是指由父组件传入，且没有被子组件声明为 props 或是组件自定义事件的 attributes 和事件处理函数。\n\n  默认情况下，若是单一根节点组件，`$attrs` 中的所有属性都是直接自动继承自组件的根元素。而多根节点组件则不会如此，同时你也可以通过配置 [`inheritAttrs`](./options-misc#inheritattrs) 选项来显式地关闭该行为。\n\n- **参考**\n\n  - [透传 Attribute](/guide/components/attrs)\n\n## $watch() {#watch}\n\n用于命令式地创建侦听器的 API。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $watch(\n      source: string | (() => any),\n      callback: WatchCallback,\n      options?: WatchOptions\n    ): StopHandle\n  }\n\n  type WatchCallback<T> = (\n    value: T,\n    oldValue: T,\n    onCleanup: (cleanupFn: () => void) => void\n  ) => void\n\n  interface WatchOptions {\n    immediate?: boolean // default: false\n    deep?: boolean // default: false\n    flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n    onTrack?: (event: DebuggerEvent) => void\n    onTrigger?: (event: DebuggerEvent) => void\n  }\n\n  type StopHandle = () => void\n  ```\n\n- **详细信息**\n\n  第一个参数是侦听来源。可以是一个组件的属性名的字符串，一个简单的由点分隔的路径字符串，或是一个 getter 函数。\n\n  第二个参数是回调函数。它接收的参数分别是侦听来源的新值、旧值。\n\n  - **`immediate`**：指定在侦听器创建时是否立即触发回调。在第一次调用时旧值为 `undefined`。\n  - **`deep`**：指定在侦听来源是一个对象时，是否强制深度遍历，这样回调函数就会在深层级发生变更时被触发。详见[深层侦听器](/guide/essentials/watchers#deep-watchers)。\n  - **`flush`**：指定回调函数的刷新时机。详见[回调刷新时机](/guide/essentials/watchers#callback-flush-timing)及 [`watchEffect()`](/api/reactivity-core#watcheffect)。\n  - **`onTrack / onTrigger`**：调试侦听器的依赖，详见[侦听器调试](/guide/extras/reactivity-in-depth#watcher-debugging)。\n\n- **示例**\n\n  侦听一个属性名：\n\n  ```js\n  this.$watch('a', (newVal, oldVal) => {})\n  ```\n\n  侦听一个由 `.` 分隔的路径：\n\n  ```js\n  this.$watch('a.b', (newVal, oldVal) => {})\n  ```\n\n  对更复杂表达式使用 getter 函数：\n\n  ```js\n  this.$watch(\n    // 每一次这个 `this.a + this.b` 表达式生成一个\n    // 不同的结果，处理函数都会被调用\n    // 这就好像我们在侦听一个计算属性\n    // 而不定义计算属性本身。\n    () => this.a + this.b,\n    (newVal, oldVal) => {}\n  )\n  ```\n\n  停止该侦听器：\n\n  ```js\n  const unwatch = this.$watch('a', cb)\n\n  // 之后……\n  unwatch()\n  ```\n\n- **参考**\n  - [选项 - `watch`](/api/options-state#watch)\n  - [指南 - 侦听器](/guide/essentials/watchers)\n\n## $emit() {#emit}\n\n在当前组件触发一个自定义事件。任何额外的参数都会传递给事件监听器的回调函数。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $emit(event: string, ...args: any[]): void\n  }\n  ```\n\n- **示例**\n\n  ```js\n  export default {\n    created() {\n      // 仅触发事件\n      this.$emit('foo')\n      // 带有额外的参数\n      this.$emit('bar', 1, 2, 3)\n    }\n  }\n  ```\n\n- **参考**\n\n  - [组件 - 事件](/guide/components/events)\n  - [`emits` 选项](./options-state#emits)\n\n## $forceUpdate() {#forceupdate}\n\n强制该组件重新渲染。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $forceUpdate(): void\n  }\n  ```\n\n- **详细信息**\n\n  鉴于 Vue 的全自动响应性系统，这个功能应该很少会被用到。唯一可能需要它的情况是，你使用高阶响应式 API 显式创建了一个非响应式的组件状态。",
          "questions": [
            "`$data` 属性的值是什么类型的？",
            "`$props` 属性表示什么？",
            "`$el` 属性指向什么？",
            "`$options` 属性暴露了哪些组件选项？",
            "`$parent` 属性表示什么？",
            "`$root` 属性表示什么？",
            "`$slots` 属性表示什么？",
            "`$refs` 属性表示什么？",
            "`$attrs` 属性表示什么？",
            "`$watch()` 方法用于什么？有哪些参数？"
          ]
        }
      ]
    },
    {
      "file_name": "composition-api-lifecycle.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 组合式 API：生命周期钩子 {#composition-api-lifecycle-hooks}\n\n:::info 使用方式注意\n所有罗列在本页的 API 都应该在组件的 `setup()` 阶段被同步调用。相关细节请看[指南 - 生命周期钩子](/guide/essentials/lifecycle)。\n:::\n\n## onMounted() {#onmounted}\n\n注册一个回调函数，在组件挂载完成后执行。\n\n- **类型**\n\n  ```ts\n  function onMounted(callback: () => void): void\n  ```\n\n- **详细信息**\n\n  组件在以下情况下被视为已挂载：\n\n  - 其所有同步子组件都已经被挂载 (不包含异步组件或 `<Suspense>` 树内的组件)。\n\n  - 其自身的 DOM 树已经创建完成并插入了父容器中。注意仅当根容器在文档中时，才可以保证组件 DOM 树也在文档中。\n\n  这个钩子通常用于执行需要访问组件所渲染的 DOM 树相关的副作用，或是在[服务端渲染应用](/guide/scaling-up/ssr)中用于确保 DOM 相关代码仅在客户端执行。\n\n  **这个钩子在服务器端渲染期间不会被调用。**\n\n- **示例**\n\n  通过模板引用访问一个元素：\n\n  ```vue\n  <script setup>\n  import { ref, onMounted } from 'vue'\n\n  const el = ref()\n\n  onMounted(() => {\n    el.value // <div>\n  })\n  </script>\n\n  <template>\n    <div ref=\"el\"></div>\n  </template>\n  ```\n\n## onUpdated() {#onupdated}\n\n注册一个回调函数，在组件因为响应式状态变更而更新其 DOM 树之后调用。\n\n- **类型**\n\n  ```ts\n  function onUpdated(callback: () => void): void\n  ```\n\n- **详细信息**\n\n  父组件的更新钩子将在其子组件的更新钩子之后调用。\n\n  这个钩子会在组件的任意 DOM 更新后被调用，这些更新可能是由不同的状态变更导致的，因为多个状态变更可以在同一个渲染周期中批量执行（考虑到性能因素）。如果你需要在某个特定的状态更改后访问更新后的 DOM，请使用 [nextTick()](/api/general#nexttick) 作为替代。\n\n  **这个钩子在服务器端渲染期间不会被调用。**\n\n  :::warning\n  不要在 updated 钩子中更改组件的状态，这可能会导致无限的更新循环！\n  :::\n\n- **示例**\n\n  访问更新后的 DOM\n\n  ```vue\n  <script setup>\n  import { ref, onUpdated } from 'vue'\n\n  const count = ref(0)\n\n  onUpdated(() => {\n    // 文本内容应该与当前的 `count.value` 一致\n    console.log(document.getElementById('count').textContent)\n  })\n  </script>\n\n  <template>\n    <button id=\"count\" @click=\"count++\">{{ count }}</button>\n  </template>\n  ```\n\n## onUnmounted() {#onunmounted}\n\n注册一个回调函数，在组件实例被卸载之后调用。\n\n- **类型**\n\n  ```ts\n  function onUnmounted(callback: () => void): void\n  ```\n\n- **详细信息**\n\n  一个组件在以下情况下被视为已卸载：\n\n  - 其所有子组件都已经被卸载。\n\n  - 所有相关的响应式作用 (渲染作用以及 `setup()` 时创建的计算属性和侦听器) 都已经停止。\n\n  可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。\n\n  **这个钩子在服务器端渲染期间不会被调用。**\n\n- **示例**\n\n  ```vue\n  <script setup>\n  import { onMounted, onUnmounted } from 'vue'\n\n  let intervalId\n  onMounted(() => {\n    intervalId = setInterval(() => {\n      // ...\n    })\n  })\n\n  onUnmounted(() => clearInterval(intervalId))\n  </script>\n  ```\n\n## onBeforeMount() {#onbeforemount}\n\n注册一个钩子，在组件被挂载之前被调用。\n\n- **类型**\n\n  ```ts\n  function onBeforeMount(callback: () => void): void\n  ```\n\n- **详细信息**\n\n  当这个钩子被调用时，组件已经完成了其响应式状态的设置，但还没有创建 DOM 节点。它即将首次执行 DOM 渲染过程。\n\n  **这个钩子在服务器端渲染期间不会被调用。**\n\n## onBeforeUpdate() {#onbeforeupdate}\n\n注册一个钩子，在组件即将因为响应式状态变更而更新其 DOM 树之前调用。\n\n- **类型**\n\n  ```ts\n  function onBeforeUpdate(callback: () => void): void\n  ```\n\n- **详细信息**\n\n  这个钩子可以用来在 Vue 更新 DOM 之前访问 DOM 状态。在这个钩子中更改状态也是安全的。\n\n  **这个钩子在服务器端渲染期间不会被调用。**\n\n## onBeforeUnmount() {#onbeforeunmount}\n\n注册一个钩子，在组件实例被卸载之前调用。\n\n- **类型**\n\n  ```ts\n  function onBeforeUnmount(callback: () => void): void\n  ```\n\n- **详细信息**\n\n  当这个钩子被调用时，组件实例依然还保有全部的功能。\n\n  **这个钩子在服务器端渲染期间不会被调用。**\n\n## onErrorCaptured() {#onerrorcaptured}\n\n注册一个钩子，在捕获了后代组件传递的错误时调用。\n\n- **类型**\n\n  ```ts\n  function onErrorCaptured(callback: ErrorCapturedHook): void\n\n  type ErrorCapturedHook = (\n    err: unknown,\n    instance: ComponentPublicInstance | null,\n    info: string\n  ) => boolean | void\n  ```\n\n- **详细信息**\n\n  错误可以从以下几个来源中捕获：\n\n  - 组件渲染\n  - 事件处理器\n  - 生命周期钩子\n  - `setup()` 函数\n  - 侦听器\n  - 自定义指令钩子\n  - 过渡钩子\n\n  这个钩子带有三个实参：错误对象、触发该错误的组件实例，以及一个说明错误来源类型的信息字符串。\n\n  你可以在 `errorCaptured()` 中更改组件状态来为用户显示一个错误状态。注意不要让错误状态再次渲染导致本次错误的内容，否则组件会陷入无限循环。\n\n  这个钩子可以通过返回 `false` 来阻止错误继续向上传递。请看下方的传递细节介绍。\n\n  **错误传递规则**\n\n  - 默认情况下，所有的错误都会被发送到应用级的 [`app.config.errorHandler`](/api/application#app-config-errorhandler) (前提是这个函数已经定义)，这样这些错误都能在一个统一的地方报告给分析服务。\n\n  - 如果组件的继承链或组件链上存在多个 `errorCaptured` 钩子，对于同一个错误，这些钩子会被按从底至上的顺序一一调用。这个过程被称为“向上传递”，类似于原生 DOM 事件的冒泡机制。\n\n  - 如果 `errorCaptured` 钩子本身抛出了一个错误，那么这个错误和原来捕获到的错误都将被发送到 `app.config.errorHandler`。\n\n  - `errorCaptured` 钩子可以通过返回 `false` 来阻止错误继续向上传递。即表示“这个错误已经被处理了，应当被忽略”，它将阻止其他的 `errorCaptured` 钩子或 `app.config.errorHandler` 因这个错误而被调用。\n\n## onRenderTracked() <sup class=\"vt-badge dev-only\" /> {#onrendertracked}\n\n注册一个调试钩子，当组件渲染过程中追踪到响应式依赖时调用。\n\n**这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。**\n\n- **类型**\n\n  ```ts\n  function onRenderTracked(callback: DebuggerHook): void\n\n  type DebuggerHook = (e: DebuggerEvent) => void\n\n  type DebuggerEvent = {\n    effect: ReactiveEffect\n    target: object\n    type: TrackOpTypes /* 'get' | 'has' | 'iterate' */\n    key: any\n  }\n  ```\n\n- **参考**[深入响应式系统](/guide/extras/reactivity-in-depth)\n\n## onRenderTriggered() <sup class=\"vt-badge dev-only\" /> {#onrendertriggered}\n\n注册一个调试钩子，当响应式依赖的变更触发了组件渲染时调用。\n\n**这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。**\n\n- **类型**\n\n  ```ts\n  function onRenderTriggered(callback: DebuggerHook): void\n\n  type DebuggerHook = (e: DebuggerEvent) => void\n\n  type DebuggerEvent = {\n    effect: ReactiveEffect\n    target: object\n    type: TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */\n    key: any\n    newValue?: any\n    oldValue?: any\n    oldTarget?: Map<any, any> | Set<any>\n  }\n  ```\n\n- **参考**[深入响应式系统](/guide/extras/reactivity-in-depth)\n\n## onActivated() {#onactivated}\n\n注册一个回调函数，若组件实例是 [`<KeepAlive>`](/api/built-in-components#keepalive) 缓存树的一部分，当组件被插入到 DOM 中时调用。\n\n**这个钩子在服务器端渲染期间不会被调用。**\n\n- **类型**\n\n  ```ts\n  function onActivated(callback: () => void): void\n  ```\n\n- **参考**[指南 - 缓存实例的生命周期](/guide/built-ins/keep-alive#lifecycle-of-cached-instance)",
          "questions": [
            "组合式 API 中的生命周期钩子有哪些？",
            "`onMounted()` 的作用是什么？",
            "`onUpdated()` 的作用是什么？",
            "`onUnmounted()` 的作用是什么？",
            "`onBeforeMount()` 的作用是什么？",
            "`onBeforeUpdate()` 的作用是什么？",
            "`onBeforeUnmount()` 的作用是什么？",
            "`onErrorCaptured()` 的作用是什么？它的错误传递规则是什么？",
            "`onRenderTracked()` 的作用是什么？在什么情况下会被调用？",
            "`onRenderTriggered()` 的作用是什么？在什么情况下会被调用？"
          ]
        },
        {
          "content": "## onDeactivated() {#ondeactivated}\n\n注册一个回调函数，若组件实例是 [`<KeepAlive>`](/api/built-in-components#keepalive) 缓存树的一部分，当组件从 DOM 中被移除时调用。\n\n**这个钩子在服务器端渲染期间不会被调用。**\n\n- **类型**\n\n  ```ts\n  function onDeactivated(callback: () => void): void\n  ```\n\n- **参考**[指南 - 缓存实例的生命周期](/guide/built-ins/keep-alive#lifecycle-of-cached-instance)\n\n## onServerPrefetch() <sup class=\"vt-badge\" data-text=\"SSR only\" /> {#onserverprefetch}\n\n注册一个异步函数，在组件实例在服务器上被渲染之前调用。\n\n- **类型**\n\n  ```ts\n  function onServerPrefetch(callback: () => Promise<any>): void\n  ```\n\n- **详细信息**\n\n  如果这个钩子返回了一个 Promise，服务端渲染会在渲染该组件前等待该 Promise 完成。\n\n  这个钩子仅会在服务端渲染中执行，可以用于执行一些仅存在于服务端的数据抓取过程。\n\n- **示例**\n\n  ```vue\n  <script setup>\n  import { ref, onServerPrefetch, onMounted } from 'vue'\n\n  const data = ref(null)\n\n  onServerPrefetch(async () => {\n    // 组件作为初始请求的一部分被渲染\n    // 在服务器上预抓取数据，因为它比在客户端上更快。\n    data.value = await fetchOnServer(/* ... */)\n  })\n\n  onMounted(async () => {\n    if (!data.value) {\n      // 如果数据在挂载时为空值，这意味着该组件\n      // 是在客户端动态渲染的。将转而执行\n      // 另一个客户端侧的抓取请求\n      data.value = await fetchOnClient(/* ... */)\n    }\n  })\n  </script>\n  ```\n\n- **参考**[服务端渲染](/guide/scaling-up/ssr)",
          "questions": [
            "onDeactivated钩子函数的作用是什么？",
            "onDeactivated钩子函数在哪些情况下会被调用？",
            "onDeactivated钩子函数在服务器端渲染期间会被调用吗？",
            "onServerPrefetch钩子函数的作用是什么？",
            "onServerPrefetch钩子函数在哪些情况下会被调用？",
            "onServerPrefetch钩子函数只会在哪种情况下执行？",
            "onServerPrefetch钩子函数可以用于执行什么样的操作？",
            "onServerPrefetch钩子函数返回的Promise会在什么时候被执行？",
            "onServerPrefetch钩子函数可以在哪些场景下使用？",
            "代码示例中的fetchOnServer和fetchOnClient函数分别是用来做什么的？"
          ]
        }
      ]
    },
    {
      "file_name": "composition-api-setup.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 组合式 API：setup() {#composition-api-setup}\n\n## 基本使用 {#basic-usage}\n\n`setup()` 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：\n\n1. 需要在非单文件组件中使用组合式 API 时。\n2. 需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。\n\n:::info 注意\n对于结合单文件组件使用的组合式 API，推荐通过 [`<script setup>`](/api/sfc-script-setup) 以获得更加简洁及符合人体工程学的语法。\n:::\n\n我们可以使用[响应式 API](./reactivity-core) 来声明响应式的状态，在 `setup()` 函数中返回的对象会暴露给模板和组件实例。其他的选项也可以通过组件实例来获取 `setup()` 暴露的属性：\n\n```vue\n<script>\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    // 返回值会暴露给模板和其他的选项式 API 钩子\n    return {\n      count\n    }\n  },\n\n  mounted() {\n    console.log(this.count) // 0\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\">{{ count }}</button>\n</template>\n```\n\n在模板中访问从 `setup` 返回的 [ref](/api/reactivity-core#ref) 时，它会[自动浅层解包](/guide/essentials/reactivity-fundamentals#deep-reactivity)，因此你无须再在模板中为它写 `.value`。当通过 `this` 访问时也会同样如此解包。\n\n`setup()` 自身并不含对组件实例的访问权，即在 `setup()` 中访问 `this` 会是 `undefined`。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。\n\n`setup()` 应该*同步地*返回一个对象。唯一可以使用 `async setup()` 的情况是，该组件是 [Suspense](../guide/built-ins/suspense) 组件的后裔。\n\n## 访问 Props {#accessing-props}\n\n`setup` 函数的第一个参数是组件的 `props`。和标准的组件一致，一个 `setup` 函数的 `props` 是响应式的，并且会在传入新的 props 时同步更新。\n\n```js\nexport default {\n  props: {\n    title: String\n  },\n  setup(props) {\n    console.log(props.title)\n  }\n}\n```\n\n请注意如果你解构了 `props` 对象，解构出的变量将会丢失响应性。因此我们推荐通过 `props.xxx` 的形式来使用其中的 props。\n\n如果你确实需要解构 `props` 对象，或者需要将某个 prop 传到一个外部函数中并保持响应性，那么你可以使用 [toRefs()](./reactivity-utilities#torefs) 和 [toRef()](/api/reactivity-utilities#toref) 这两个工具函数：\n\n```js\nimport { toRefs, toRef } from 'vue'\n\nexport default {\n  setup(props) {\n    // 将 `props` 转为一个其中全是 ref 的对象，然后解构\n    const { title } = toRefs(props)\n    // `title` 是一个追踪着 `props.title` 的 ref\n    console.log(title.value)\n\n    // 或者，将 `props` 的单个属性转为一个 ref\n    const title = toRef(props, 'title')\n  }\n}\n```\n\n## Setup 上下文 {#setup-context}\n\n传入 `setup` 函数的第二个参数是一个 **Setup 上下文**对象。上下文对象暴露了其他一些在 `setup` 中可能会用到的值：\n\n```js\nexport default {\n  setup(props, context) {\n    // 透传 Attributes（非响应式的对象，等价于 $attrs）\n    console.log(context.attrs)\n\n    // 插槽（非响应式的对象，等价于 $slots）\n    console.log(context.slots)\n\n    // 触发事件（函数，等价于 $emit）\n    console.log(context.emit)\n\n    // 暴露公共属性（函数）\n    console.log(context.expose)\n  }\n}\n```\n\n该上下文对象是非响应式的，可以安全地解构：\n\n```js\nexport default {\n  setup(props, { attrs, slots, emit, expose }) {\n    ...\n  }\n}\n```\n\n`attrs` 和 `slots` 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 `attrs.x` 或 `slots.x` 的形式使用其中的属性。此外还需注意，和 `props` 不同，`attrs` 和 `slots` 的属性都**不是**响应式的。如果你想要基于 `attrs` 或 `slots` 的改变来执行副作用，那么你应该在 `onBeforeUpdate` 生命周期钩子中编写相关逻辑。\n\n### 暴露公共属性 {#exposing-public-properties}\n\n`expose` 函数用于显式地限制该组件暴露出的属性，当父组件通过[模板引用](/guide/essentials/template-refs#ref-on-component)访问该组件的实例时，将仅能访问 `expose` 函数暴露出的内容：\n\n```js{5,10}\nexport default {\n  setup(props, { expose }) {\n    // 让组件实例处于 “关闭状态”\n    // 即不向父组件暴露任何东西\n    expose()\n\n    const publicCount = ref(0)\n    const privateCount = ref(0)\n    // 有选择地暴露局部状态\n    expose({ count: publicCount })\n  }\n}\n```\n\n## 与渲染函数一起使用 {#usage-with-render-functions}\n\n`setup` 也可以返回一个[渲染函数](/guide/extras/render-function)，此时在渲染函数中可以直接使用在同一作用域下声明的响应式状态：\n\n```js{6}\nimport { h, ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    return () => h('div', count.value)\n  }\n}\n```\n\n返回一个渲染函数将会阻止我们返回其他东西。对于组件内部来说，这样没有问题，但如果我们想通过模板引用将这个组件的方法暴露给父组件，那就有问题了。\n\n我们可以通过调用 [`expose()`](#exposing-public-properties) 解决这个问题：\n\n```js{8-10}\nimport { h, ref } from 'vue'\n\nexport default {\n  setup(props, { expose }) {\n    const count = ref(0)\n    const increment = () => ++count.value\n\n    expose({\n      increment\n    })\n\n    return () => h('div', count.value)\n  }\n}\n```\n\n此时父组件可以通过模板引用来访问这个 `increment` 方法。",
          "questions": [
            "`setup()` 钩子通常在哪些情况下使用？",
            "`setup()` 函数返回的对象会暴露给哪些地方？",
            "在 `setup()` 中如何声明响应式状态？",
            "在模板中访问从 `setup()` 返回的 `ref` 时需要写什么？",
            "`setup()` 函数是否含有对组件实例的访问权？",
            "`setup()` 函数的第一个参数是什么？",
            "`attrs` 和 `slots` 对象的属性是否是响应式的？",
            "`expose` 函数的作用是什么？",
            "`setup()` 是否可以返回一个渲染函数？",
            "如何在 `setup()` 中将方法暴露给父组件？"
          ]
        }
      ]
    },
    {
      "file_name": "reactivity-core.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# 响应式 API：核心 {#reactivity-api-core}\n\n:::info 参考\n要更好地了解响应式 API，推荐阅读下面几个指南中的章节：\n\n- [响应式基础](/guide/essentials/reactivity-fundamentals) (with the API preference set to Composition API)\n- [深入响应式系统](/guide/extras/reactivity-in-depth)\n  :::\n\n## ref() {#ref}\n\n接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 `.value`。\n\n- **类型**\n\n  ```ts\n  function ref<T>(value: T): Ref<UnwrapRef<T>>\n\n  interface Ref<T> {\n    value: T\n  }\n  ```\n\n- **详细信息**\n\n  ref 对象是可更改的，也就是说你可以为 `.value` 赋予新的值。它也是响应式的，即所有对 `.value` 的操作都将被追踪，并且写操作会触发与之相关的副作用。\n\n  如果将一个对象赋值给 ref，那么这个对象将通过 [reactive()](#reactive) 转为具有深层次响应式的对象。这也意味着如果对象中包含了嵌套的 ref，它们将被深层地解包。\n\n  若要避免这种深层次的转换，请使用 [`shallowRef()`](./reactivity-advanced#shallowref) 来替代。\n\n- **示例**\n\n  ```js\n  const count = ref(0)\n  console.log(count.value) // 0\n\n  count.value++\n  console.log(count.value) // 1\n  ```\n\n- **参考**\n  - [指南 - `ref()` 的响应式基础](/guide/essentials/reactivity-fundamentals#reactive-variables-with-ref)\n  - [指南 - 为 `ref()` 标注类型](/guide/typescript/composition-api#typing-ref) <sup class=\"vt-badge ts\" />\n\n## computed() {#computed}\n\n接受一个 getter 函数，返回一个只读的响应式 [ref](#ref) 对象。该 ref 通过 `.value` 暴露 getter 函数的返回值。它也可以接受一个带有 `get` 和 `set` 函数的对象来创建一个可写的 ref 对象。\n\n- **类型**\n\n  ```ts\n  // 只读\n  function computed<T>(\n    getter: () => T,\n    // 查看下方的 \"计算属性调试\" 链接\n    debuggerOptions?: DebuggerOptions\n  ): Readonly<Ref<Readonly<T>>>\n\n  // 可写的\n  function computed<T>(\n    options: {\n      get: () => T\n      set: (value: T) => void\n    },\n    debuggerOptions?: DebuggerOptions\n  ): Ref<T>\n  ```\n\n- **示例**\n\n  创建一个只读的计算属性 ref：\n\n  ```js\n  const count = ref(1)\n  const plusOne = computed(() => count.value + 1)\n\n  console.log(plusOne.value) // 2\n\n  plusOne.value++ // 错误\n  ```\n\n  创建一个可写的计算属性 ref：\n\n  ```js\n  const count = ref(1)\n  const plusOne = computed({\n    get: () => count.value + 1,\n    set: (val) => {\n      count.value = val - 1\n    }\n  })\n\n  plusOne.value = 1\n  console.log(count.value) // 0\n  ```\n\n  调试：\n\n  ```js\n  const plusOne = computed(() => count.value + 1, {\n    onTrack(e) {\n      debugger\n    },\n    onTrigger(e) {\n      debugger\n    }\n  })\n  ```\n\n- **参考**\n  - [指南 - 计算属性](/guide/essentials/computed)\n  - [指南 - 计算属性调试](/guide/extras/reactivity-in-depth#computed-debugging)\n  - [指南 - 为 `computed()` 标注类型](/guide/typescript/composition-api#typing-computed) <sup class=\"vt-badge ts\" />\n\n## reactive() {#reactive}\n\n返回一个对象的响应式代理。\n\n- **类型**\n\n  ```ts\n  function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\n  ```\n\n- **详细信息**\n\n  响应式转换是“深层”的：它会影响到所有嵌套的属性。一个响应式对象也将深层地解包任何 [ref](#ref) 属性，同时保持响应性。\n\n  值得注意的是，当访问到某个响应式数组或 `Map` 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包。\n\n  若要避免深层响应式转换，只想保留对这个对象顶层次访问的响应性，请使用 [shallowReactive()](./reactivity-advanced#shallowreactive) 作替代。\n\n  返回的对象以及其中嵌套的对象都会通过 [ES Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 包裹，因此**不等于**源对象，建议只使用响应式代理，避免使用原始对象。\n\n- **示例**\n\n  创建一个响应式对象：\n\n  ```js\n  const obj = reactive({ count: 0 })\n  obj.count++\n  ```\n\n  ref 的解包：\n\n  ```ts\n  const count = ref(1)\n  const obj = reactive({ count })\n\n  // ref 会被解包\n  console.log(obj.count === count.value) // true\n\n  // 会更新 `obj.count`\n  count.value++\n  console.log(count.value) // 2\n  console.log(obj.count) // 2\n\n  // 也会更新 `count` ref\n  obj.count++\n  console.log(obj.count) // 3\n  console.log(count.value) // 3\n  ```\n\n\t注意当访问到某个响应式数组或 `Map` 这样的原生集合类型中的 ref 元素时，**不会**执行 ref 的解包：\n\n  ```js\n  const books = reactive([ref('Vue 3 Guide')])\n  // 这里需要 .value\n  console.log(books[0].value)\n\n  const map = reactive(new Map([['count', ref(0)]]))\n  // 这里需要 .value\n  console.log(map.get('count').value)\n  ```\n\n  将一个 [ref](#ref) 赋值给一个 `reactive` 属性时，该 ref 会被自动解包：\n\n  ```ts\n  const count = ref(1)\n  const obj = reactive({})\n\n  obj.count = count\n\n  console.log(obj.count) // 1\n  console.log(obj.count === count.value) // true\n  ```\n\n- **参考**\n  - [指南 - 响应式基础](/guide/essentials/reactivity-fundamentals)\n  - [指南 - 为 `reactive()` 标注类型](/guide/typescript/composition-api#typing-reactive) <sup class=\"vt-badge ts\" />\n\n## readonly() {#readonly}\n\n接受一个对象 (不论是响应式还是普通的) 或是一个 [ref](#ref)，返回一个原值的只读代理。\n\n- **类型**\n\n  ```ts\n  function readonly<T extends object>(\n    target: T\n  ): DeepReadonly<UnwrapNestedRefs<T>>\n  ```\n\n- **详细信息**\n\n  只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的 ref 解包行为与 `reactive()` 相同，但解包得到的值是只读的。\n\n  要避免深层级的转换行为，请使用 [shallowReadonly()](./reactivity-advanced#shallowreadonly) 作替代。\n\n- **示例**\n\n  ```js\n  const original = reactive({ count: 0 })\n\n  const copy = readonly(original)\n\n  watchEffect(() => {\n    // 用来做响应性追踪\n    console.log(copy.count)\n  })\n\n  // 更改源属性会触发其依赖的侦听器\n  original.count++\n\n  // 更改该只读副本将会失败，并会得到一个警告\n  copy.count++ // warning!\n  ```",
          "questions": [
            "`ref()` 和 `reactive()` 的区别是什么？",
            "`computed()` 可以接受哪些参数？分别有什么作用？",
            "`computed()` 创建的计算属性 ref 是只读的还是可写的？",
            "如何避免 `reactive()` 的深层响应式转换？",
            "`readonly()` 可以接受哪些参数？它的代理是深层的还是浅层的？",
            "当访问到响应式数组或 `Map` 中的 ref 元素时，会执行 ref 的解包吗？",
            "`ref()` 和 `reactive()` 返回的对象有什么区别？",
            "`computed()` 的调试选项有哪些？分别有什么作用？",
            "如何将一个 `ref` 赋值给一个 `reactive` 属性？",
            "`reactive()` 和 `readonly()` 分别返回什么类型的对象？"
          ]
        },
        {
          "content": "## watchEffect() {#watcheffect}\n\n立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。\n\n- **类型**\n\n  ```ts\n  function watchEffect(\n    effect: (onCleanup: OnCleanup) => void,\n    options?: WatchEffectOptions\n  ): StopHandle\n\n  type OnCleanup = (cleanupFn: () => void) => void\n\n  interface WatchEffectOptions {\n    flush?: 'pre' | 'post' | 'sync' // 默认：'pre'\n    onTrack?: (event: DebuggerEvent) => void\n    onTrigger?: (event: DebuggerEvent) => void\n  }\n\n  type StopHandle = () => void\n  ```\n\n- **详细信息**\n\n  第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求 (参见下面的示例)。\n\n  第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。\n\n  默认情况下，侦听器将在组件渲染之前执行。设置 `flush: 'post'` 将会使侦听器延迟到组件渲染之后再执行。详见[回调的触发时机](/guide/essentials/watchers#callback-flush-timing)。在某些特殊情况下 (例如要使缓存失效)，可能有必要在响应式依赖发生改变时立即触发侦听器。这可以通过设置 `flush: 'sync'` 来实现。然而，该设置应谨慎使用，因为如果有多个属性同时更新，这将导致一些性能和数据一致性的问题。\n\n  返回值是一个用来停止该副作用的函数。\n\n- **示例**\n\n  ```js\n  const count = ref(0)\n\n  watchEffect(() => console.log(count.value))\n  // -> 输出 0\n\n  count.value++\n  // -> 输出 1\n  ```\n\n  副作用清除：\n\n  ```js\n  watchEffect(async (onCleanup) => {\n    const { response, cancel } = doAsyncWork(id.value)\n    // `cancel` 会在 `id` 更改时调用\n    // 以便取消之前\n    // 未完成的请求\n    onCleanup(cancel)\n    data.value = await response\n  })\n  ```\n\n  停止侦听器：\n\n  ```js\n  const stop = watchEffect(() => {})\n\n  // 当不再需要此侦听器时:\n  stop()\n  ```\n\n  选项：\n\n  ```js\n  watchEffect(() => {}, {\n    flush: 'post',\n    onTrack(e) {\n      debugger\n    },\n    onTrigger(e) {\n      debugger\n    }\n  })\n  ```\n\n- **参考**\n  - [指南 - 侦听器](/guide/essentials/watchers#watcheffect)\n  - [指南 - 侦听器调试](/guide/extras/reactivity-in-depth#watcher-debugging)\n\n## watchPostEffect() {#watchposteffect}\n\n[`watchEffect()`](#watcheffect) 使用 `flush: 'post'` 选项时的别名。\n\n## watchSyncEffect() {#watchsynceffect}\n\n[`watchEffect()`](#watcheffect) 使用 `flush: 'sync'` 选项时的别名。\n\n## watch() {#watch}\n\n侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。\n\n- **类型**\n\n  ```ts\n  // 侦听单个来源\n  function watch<T>(\n    source: WatchSource<T>,\n    callback: WatchCallback<T>,\n    options?: WatchOptions\n  ): StopHandle\n\n  // 侦听多个来源\n  function watch<T>(\n    sources: WatchSource<T>[],\n    callback: WatchCallback<T[]>,\n    options?: WatchOptions\n  ): StopHandle\n\n  type WatchCallback<T> = (\n    value: T,\n    oldValue: T,\n    onCleanup: (cleanupFn: () => void) => void\n  ) => void\n\n  type WatchSource<T> =\n    | Ref<T> // ref\n    | (() => T) // getter\n    | T extends object\n    ? T\n    : never // 响应式对象\n\n  interface WatchOptions extends WatchEffectOptions {\n    immediate?: boolean // 默认：false\n    deep?: boolean // 默认：false\n    flush?: 'pre' | 'post' | 'sync' // 默认：'pre'\n    onTrack?: (event: DebuggerEvent) => void\n    onTrigger?: (event: DebuggerEvent) => void\n  }\n  ```\n\n  > 为了便于阅读，对类型进行了简化。\n\n- **详细信息**\n\n  `watch()` 默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。\n\n  第一个参数是侦听器的**源**。这个来源可以是以下几种：\n\n  - 一个函数，返回一个值\n  - 一个 ref\n  - 一个响应式对象\n  - ...或是由以上类型的值组成的数组\n\n  第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数。该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。\n\n\t当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。\n\n  第三个可选的参数是一个对象，支持以下这些选项：\n\n  - **`immediate`**：在侦听器创建时立即触发回调。第一次调用时旧值是 `undefined`。\n  - **`deep`**：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。参考[深层侦听器](/guide/essentials/watchers#deep-watchers)。\n  - **`flush`**：调整回调函数的刷新时机。参考[回调的刷新时机](/guide/essentials/watchers#callback-flush-timing)及 [`watchEffect()`](/api/reactivity-core#watcheffect)。\n  - **`onTrack / onTrigger`**：调试侦听器的依赖。参考[调试侦听器](/guide/extras/reactivity-in-depth#watcher-debugging)。\n\n  与 [`watchEffect()`](#watcheffect) 相比，`watch()` 使我们可以：\n\n  - 懒执行副作用；\n  - 更加明确是应该由哪个状态触发侦听器重新执行；\n  - 可以访问所侦听状态的前一个值和当前值。\n\n- **示例**\n\n  侦听一个 getter 函数：\n\n  ```js\n  const state = reactive({ count: 0 })\n  watch(\n    () => state.count,\n    (count, prevCount) => {\n      /* ... */\n    }\n  )\n  ```\n\n  侦听一个 ref：\n\n  ```js\n  const count = ref(0)\n  watch(count, (count, prevCount) => {\n    /* ... */\n  })\n  ```\n\n  当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值：\n\n  ```js\n  watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {\n    /* ... */\n  })\n  ```\n\n  当使用 getter 函数作为源时，回调只在此函数的返回值变化时才会触发。如果你想让回调在深层级变更时也能触发，你需要使用 `{ deep: true }` 强制侦听器进入深层级模式。在深层级模式时，如果回调函数由于深层级的变更而被触发，那么新值和旧值将是同一个对象。\n\n  ```js\n  const state = reactive({ count: 0 })\n  watch(\n    () => state,\n    (newValue, oldValue) => {\n      // newValue === oldValue\n    },\n    { deep: true }\n  )\n  ```\n\n  当直接侦听一个响应式对象时，侦听器会自动启用深层模式：\n\n  ```js\n  const state = reactive({ count: 0 })\n  watch(state, () => {\n    /* 深层级变更状态所触发的回调 */\n  })\n  ```\n\n  `watch()` 和 [`watchEffect()`](#watcheffect) 享有相同的刷新时机和调试选项：\n\n  ```js\n  watch(source, callback, {\n    flush: 'post',\n    onTrack(e) {\n      debugger\n    },\n    onTrigger(e) {\n      debugger\n    }\n  })\n  ```\n\n  停止侦听器：\n\n  ```js\n  const stop = watch(source, callback)\n\n  // 当已不再需要该侦听器时：\n  stop()\n  ```\n\n  副作用清理：\n\n  ```js\n  watch(id, async (newId, oldId, onCleanup) => {\n    const { response, cancel } = doAsyncWork(newId)\n    // 当 `id` 变化时，`cancel` 将被调用，\n    // 取消之前的未完成的请求\n    onCleanup(cancel)\n    data.value = await response\n  })\n  ```\n\n- **参考**\n\n  - [指南 - 侦听器](/guide/essentials/watchers)\n  - [指南 - 侦听器调试](/guide/extras/reactivity-in-depth#watcher-debugging)",
          "questions": [
            "`watchEffect()` 和 `watch()` 的区别是什么？",
            "`watchEffect()` 的第一个参数是什么？第二个参数是什么？第三个参数是什么？",
            "`watchEffect()` 的返回值是什么？有什么作用？",
            "`watchEffect()` 的选项中，`flush` 的默认值是什么？有哪些可选值？分别代表什么意思？",
            "`watchEffect()` 中的副作用清理是什么？如何使用？",
            "`watch()` 的第一个参数可以是哪些类型？分别代表什么意思？",
            "`watch()` 的第二个参数是什么？有哪些参数？分别代表什么意思？",
            "`watch()` 的选项中，`immediate` 和 `deep` 分别代表什么意思？有什么作用？",
            "`watch()` 和 `watchEffect()` 的刷新时机和调试选项有哪些？分别代表什么意思？",
            "`watch()` 的返回值是什么？有什么作用？"
          ]
        }
      ]
    },
    {
      "file_name": "composition-api-dependency-injection.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 组合式 API：依赖注入 {#composition-api-dependency-injection}\n\n## provide() {#provide}\n\n提供一个值，可以被后代组件注入。\n\n- **类型**\n\n  ```ts\n  function provide<T>(key: InjectionKey<T> | string, value: T): void\n  ```\n\n- **详细信息**\n\n  `provide()` 接受两个参数：第一个参数是要注入的 key，可以是一个字符串或者一个 symbol，第二个参数是要注入的值。\n\n  当使用 TypeScript 时，key 可以是一个被类型断言为 `InjectionKey` 的 symbol。`InjectionKey` 是一个 Vue 提供的工具类型，继承自 `Symbol`，可以用来同步 `provide()` 和 `inject()` 之间值的类型。\n\n  与注册生命周期钩子的 API 类似，`provide()` 必须在组件的 `setup()` 阶段同步调用。\n\n- **示例**\n\n  ```vue\n  <script setup>\n  import { ref, provide } from 'vue'\n  import { fooSymbol } from './injectionSymbols'\n\n  // 提供静态值\n  provide('foo', 'bar')\n\n  // 提供响应式的值\n  const count = ref(0)\n  provide('count', count)\n\n  // 提供时将 Symbol 作为 key\n  provide(fooSymbol, count)\n  </script>\n  ```\n\n- **参考**\n  - [指南 - 依赖注入](/guide/components/provide-inject)\n  - [指南 - 为 provide/inject 标注类型](/guide/typescript/composition-api#typing-provide-inject) <sup class=\"vt-badge ts\" />\n\n## inject() {#inject}\n\n注入一个由祖先组件或整个应用 (通过 `app.provide()`) 提供的值。\n\n- **类型**\n\n  ```ts\n  // 没有默认值\n  function inject<T>(key: InjectionKey<T> | string): T | undefined\n\n  // 带有默认值\n  function inject<T>(key: InjectionKey<T> | string, defaultValue: T): T\n\n  // 使用工厂函数\n  function inject<T>(\n    key: InjectionKey<T> | string,\n    defaultValue: () => T,\n    treatDefaultAsFactory: true\n  ): T\n  ```\n\n- **详细信息**\n\n  第一个参数是注入的 key。Vue 会遍历父组件链，通过匹配 key 来确定所提供的值。如果父组件链上多个组件对同一个 key 提供了值，那么离得更近的组件将会“覆盖”链上更远的组件所提供的值。如果没有能通过 key 匹配到值，`inject()` 将返回 `undefined`，除非提供了一个默认值。\n\n  第二个参数是可选的，即在没有匹配到 key 时使用的默认值。\n\n  第二个参数也可以是一个工厂函数，用来返回某些创建起来比较复杂的值。在这种情况下，你必须将 `true` 作为第三个参数传入，表明这个函数将作为工厂函数使用，而非值本身。\n\n  与注册生命周期钩子的 API 类似，`inject()` 必须在组件的 `setup()` 阶段同步调用。\n\n  当使用 TypeScript 时，key 可以是一个类型为 `InjectionKey` 的 symbol。`InjectionKey` 是一个 Vue 提供的工具类型，继承自 `Symbol`，可以用来同步 `provide()` 和 `inject()` 之间值的类型。\n\n- **示例**\n\n  假设有一个父组件已经提供了一些值，如前面 `provide()` 的例子中所示：\n\n  ```vue\n  <script setup>\n  import { inject } from 'vue'\n  import { fooSymbol } from './injectionSymbols'\n\n  // 注入不含默认值的静态值\n  const foo = inject('foo')\n\n  // 注入响应式的值\n  const count = inject('count')\n\n  // 通过 Symbol 类型的 key 注入\n  const foo2 = inject(fooSymbol)\n\n  // 注入一个值，若为空则使用提供的默认值\n  const bar = inject('foo', 'default value')\n\n  // 注入一个值，若为空则使用提供的函数类型的默认值\n  const fn = inject('function', () => {})\n\n  // 注入一个值，若为空则使用提供的工厂函数\n  const baz = inject('factory', () => new ExpensiveObject(), true)\n  </script>\n  ```\n\n- **参考**\n  - [指南 - 依赖注入](/guide/components/provide-inject)\n  - [指南 - 为 provide/inject 标注类型](/guide/typescript/composition-api#typing-provide-inject) <sup class=\"vt-badge ts\" />",
          "questions": [
            "`provide()` 和 `inject()` 分别是用来做什么的？",
            "`provide()` 方法接受哪些参数？分别代表什么意思？",
            "`provide()` 方法必须在哪个阶段调用？",
            "`inject()` 方法接受哪些参数？分别代表什么意思？",
            "如果父组件链上多个组件对同一个 key 提供了值，哪个组件提供的值会被使用？",
            "如果没有能通过 key 匹配到值，`inject()` 方法会返回什么？",
            "`InjectionKey` 是什么？有什么作用？",
            "在使用 TypeScript 时，key 可以是什么类型？",
            "`inject()` 方法必须在哪个阶段调用？",
            "`inject()` 方法的第二个参数可以是什么类型？分别代表什么意思？"
          ]
        }
      ]
    },
    {
      "file_name": "general.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 全局 API：常规 {#global-api-general}\n\n## version {#version}\n\n暴露当前所使用的 Vue 版本。\n\n- **类型** `string`\n\n- **示例**\n\n  ```js\n  import { version } from 'vue'\n\n  console.log(version)\n  ```\n\n## nextTick() {#nexttick}\n\n等待下一次 DOM 更新刷新的工具方法。\n\n- **类型**\n\n  ```ts\n  function nextTick(callback?: () => void): Promise<void>\n  ```\n\n- **详细信息**\n\n  当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。\n\n  `nextTick()` 可以在状态改变后立即使用，以等待 DOM 更新完成。你可以传递一个回调函数作为参数，或者 await 返回的 Promise。\n\n- **示例**\n\n  <div class=\"composition-api\">\n\n  ```vue\n  <script setup>\n  import { ref, nextTick } from 'vue'\n\n  const count = ref(0)\n\n  async function increment() {\n    count.value++\n\n    // DOM 还未更新\n    console.log(document.getElementById('counter').textContent) // 0\n\n    await nextTick()\n    // DOM 此时已经更新\n    console.log(document.getElementById('counter').textContent) // 1\n  }\n  </script>\n\n  <template>\n    <button id=\"counter\" @click=\"increment\">{{ count }}</button>\n  </template>\n  ```\n\n  </div>\n  <div class=\"options-api\">\n\n  ```vue\n  <script>\n  import { nextTick } from 'vue'\n\n  export default {\n    data() {\n      return {\n        count: 0\n      }\n    },\n    methods: {\n      async increment() {\n        this.count++\n\n        // DOM 还未更新\n        console.log(document.getElementById('counter').textContent) // 0\n\n        await nextTick()\n        // DOM 此时已经更新\n        console.log(document.getElementById('counter').textContent) // 1\n      }\n    }\n  }\n  </script>\n\n  <template>\n    <button id=\"counter\" @click=\"increment\">{{ count }}</button>\n  </template>\n  ```\n\n  </div>\n\n- **参考** [`this.$nextTick()`](/api/component-instance#nexttick)\n\n## defineComponent() {#definecomponent}\n\n在定义 Vue 组件时提供类型推导的辅助函数。\n\n- **类型**\n\n  ```ts\n  // 选项语法\n  function defineComponent(\n    component: ComponentOptions\n  ): ComponentConstructor\n\n  // 函数语法 (需要 3.3+)\n  function defineComponent(\n    setup: ComponentOptions['setup'],\n    extraOptions?: ComponentOptions\n  ): () => any\n  ```\n\n  > 为了便于阅读，对类型进行了简化。\n\n- **详细信息**\n\n  第一个参数是一个组件选项对象。返回值将是该选项对象本身，因为该函数实际上在运行时没有任何操作，仅用于提供类型推导。\n\n  注意返回值的类型有一点特别：它会是一个构造函数类型，它的实例类型是根据选项推断出的组件实例类型。这是为了能让该返回值在 TSX 中用作标签时提供类型推导支持。\n\n  你可以像这样从 `defineComponent()` 的返回类型中提取出一个组件的实例类型 (与其选项中的 `this` 的类型等价)：\n\n  ```ts\n  const Foo = defineComponent(/* ... */)\n\n  type FooInstance = InstanceType<typeof Foo>\n  ```\n\n  ### 函数签名 <sup class=\"vt-badge\" data-text=\"3.3+\" /> {#function-signature}\n\n  `defineComponent()` 还有一种备用签名，旨在与组合式 API 和 [渲染函数或 JSX](/guide/extras/render-function.html) 一起使用。\n\n  与传递选项对象不同的是，它需要传入一个函数。这个函数的工作方式与组合式 API 的 [`setup()`](/api/composition-api-setup.html#composition-api-setup) 函数相同：它接收 props 和 setup 上下文。返回值应该是一个渲染函数——支持 `h()` 和 JSX：\n\n  ```js\n  import { ref, h } from 'vue'\n\n  const Comp = defineComponent(\n    (props) => {\n      // 就像在 <script setup> 中一样使用组合式 API\n      const count = ref(0)\n\n      return () => {\n        // 渲染函数或 JSX\n        return h('div', count.value)\n      }\n    },\n    // 其他选项，例如声明 props 和 emits。\n    {\n      props: {\n        /* ... */\n      }\n    }\n  )\n  ```\n\n  此签名的主要用例是使用 TypeScript (特别是使用 TSX )，因为它支持泛型：\n\n  ```tsx\n  const Comp = defineComponent(\n    <T extends string | number>(props: { msg: T; list: T[] }) => {\n      // 就像在 <script setup> 中一样使用组合式 API\n      const count = ref(0)\n\n      return () => {\n        // 渲染函数或 JSX\n        return <div>{count.value}</div>\n      }\n    },\n    // 目前仍然需要手动声明运行时的 props\n    {\n      props: ['msg', 'list']\n    }\n  )\n  ```\n\n  在将来，我们计划提供一个 Babel 插件，自动推断并注入运行时 props (就像在 SFC 中的 `defineProps` 一样)，以便省略运行时 props 的声明。\n\n  ### webpack Treeshaking 的注意事项 {#note-on-webpack-treeshaking}\n\n  因为 `defineComponent()` 是一个函数调用，所以它可能被某些构建工具认为会产生副作用，如 webpack。即使一个组件从未被使用，也有可能不被 tree-shake。\n\n  为了告诉 webpack 这个函数调用可以被安全地 tree-shake，我们可以在函数调用之前添加一个 `/*#__PURE__*/` 形式的注释：\n\n  ```js\n  export default /*#__PURE__*/ defineComponent(/* ... */)\n  ```\n\n  请注意，如果你的项目中使用的是 Vite，就不需要这么做，因为 Rollup (Vite 底层使用的生产环境打包工具) 可以智能地确定 `defineComponent()` 实际上并没有副作用，所以无需手动注释。\n\n- **参考**[指南 - 配合 TypeScript 使用 Vue](/guide/typescript/overview#general-usage-notes)\n\n## defineAsyncComponent() {#defineasynccomponent}\n\n定义一个异步组件，它在运行时是懒加载的。参数可以是一个异步加载函数，或是对加载行为进行更具体定制的一个选项对象。\n\n- **类型**\n\n  ```ts\n  function defineAsyncComponent(\n    source: AsyncComponentLoader | AsyncComponentOptions\n  ): Component\n\n  type AsyncComponentLoader = () => Promise<Component>\n\n  interface AsyncComponentOptions {\n    loader: AsyncComponentLoader\n    loadingComponent?: Component\n    errorComponent?: Component\n    delay?: number\n    timeout?: number\n    suspensible?: boolean\n    onError?: (\n      error: Error,\n      retry: () => void,\n      fail: () => void,\n      attempts: number\n    ) => any\n  }\n  ```\n\n- **参考**[指南 - 异步组件](/guide/components/async)\n\n## defineCustomElement() {#definecustomelement}\n\n这个方法和 [`defineComponent`](#definecomponent) 接受的参数相同，不同的是会返回一个原生[自定义元素](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements)类的构造器。\n\n- **类型**\n\n  ```ts\n  function defineCustomElement(\n    component:\n      | (ComponentOptions & { styles?: string[] })\n      | ComponentOptions['setup']\n  ): {\n    new (props?: object): HTMLElement\n  }\n  ```\n\n  > 为了便于阅读，对类型进行了简化。\n\n- **详细信息**\n\n  除了常规的组件选项，`defineCustomElement()` 还支持一个特别的选项 `styles`，它应该是一个内联 CSS 字符串的数组，所提供的 CSS 会被注入到该元素的 shadow root 上。\n\n  返回值是一个可以通过 [`customElements.define()`](https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define) 注册的自定义元素构造器。\n\n- **示例**\n\n  ```js\n  import { defineCustomElement } from 'vue'\n\n  const MyVueElement = defineCustomElement({\n    /* 组件选项 */\n  })\n\n  // 注册自定义元素\n  customElements.define('my-vue-element', MyVueElement)\n  ```\n\n- **参考**\n\n  - [指南 - 使用 Vue 构建自定义元素](/guide/extras/web-components#building-custom-elements-with-vue)\n\n  - 另外请注意在使用单文件组件时 `defineCustomElement()` 需要[特殊的配置](/guide/extras/web-components#sfc-as-custom-element)。",
          "questions": [
            "`nextTick()` 方法的作用是什么？",
            "`nextTick()` 方法的参数类型是什么？",
            "`nextTick()` 方法的返回值类型是什么？",
            "`defineComponent()` 方法的作用是什么？",
            "`defineComponent()` 方法的参数类型是什么？",
            "`defineComponent()` 方法的返回值类型是什么？",
            "`defineAsyncComponent()` 方法的作用是什么？",
            "`defineAsyncComponent()` 方法的参数类型是什么？",
            "`defineCustomElement()` 方法的作用是什么？",
            "`defineCustomElement()` 方法的参数类型是什么？"
          ]
        }
      ]
    },
    {
      "file_name": "built-in-directives.md",
      "question_count": 30,
      "documents": [
        {
          "content": "# 内置指令 {#built-in-directives}\n\n## v-text {#v-text}\n\n更新元素的文本内容。\n\n- **期望的绑定值类型：**`string`\n\n- **详细信息**\n\n  `v-text` 通过设置元素的 [textContent](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent) 属性来工作，因此它将覆盖元素中所有现有的内容。如果你需要更新 `textContent` 的部分，应该使用 [mustache interpolations](/guide/essentials/template-syntax#text-interpolation) 代替。\n\n- **示例**\n\n  ```vue-html\n  <span v-text=\"msg\"></span>\n  <!-- 等同于 -->\n  <span>{{msg}}</span>\n  ```\n\n- **参考**[模板语法 - 文本插值](/guide/essentials/template-syntax#text-interpolation)\n\n## v-html {#v-html}\n\n更新元素的 [innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)。\n\n- **期望的绑定值类型：**`string`\n\n- **详细信息**\n\n `v-html` 的内容直接作为普通 HTML 插入—— Vue 模板语法是不会被解析的。如果你发现自己正打算用 `v-html` 来编写模板，不如重新想想怎么使用组件来代替。\n\n ::: warning 安全说明\n 在你的站点上动态渲染任意的 HTML 是非常危险的，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**将用户提供的内容作为插值\n  :::\n\n 在[单文件组件](/guide/scaling-up/sfc)，`scoped` 样式将不会作用于 `v-html` 里的内容，因为 HTML 内容不会被 Vue 的模板编译器解析。如果你想让 `v-html` 的内容也支持 scoped CSS，你可以使用 [CSS modules](./sfc-css-features#css-modules) 或使用一个额外的全局 `<style>` 元素，手动设置类似 BEM 的作用域策略。\n\n- **示例**\n\n  ```vue-html\n  <div v-html=\"html\"></div>\n  ```\n\n- **参考**[模板语法 - 原始 HTML](/guide/essentials/template-syntax#raw-html)\n\n## v-show {#v-show}\n\n基于表达式值的真假性，来改变元素的可见性。\n\n- **期望的绑定值类型：**`any`\n\n- **详细信息**\n\n  `v-show` 通过设置内联样式的 `display` CSS 属性来工作，当元素可见时将使用初始 `display` 值。当条件改变时，也会触发过渡效果。\n\n- **参考**[条件渲染 - v-show](/guide/essentials/conditional#v-show)\n\n## v-if {#v-if}\n\n基于表达式值的真假性，来条件性地渲染元素或者模板片段。\n\n- **期望的绑定值类型：**`any`\n\n- **详细信息**\n\n  当 `v-if` 元素被触发，元素及其所包含的指令/组件都会销毁和重构。如果初始条件是假，那么其内部的内容根本都不会被渲染。\n\n  可用于 `<template>` 表示仅包含文本或多个元素的条件块。\n\n  当条件改变时会触发过渡效果。\n\n  当同时使用时，`v-if` 比 `v-for` 优先级更高。我们并不推荐在一元素上同时使用这两个指令 — 查看[列表渲染指南](/guide/essentials/list#v-for-with-v-if)详情。\n\n- **参考**[条件渲染 - v-if](/guide/essentials/conditional#v-if)\n\n## v-else {#v-else}\n\n表示 `v-if` 或 `v-if` / `v-else-if` 链式调用的“else 块”。\n\n- **无需传入表达式**\n\n- **详细信息**\n\n  - 限定：上一个兄弟元素必须有 `v-if` 或 `v-else-if`。\n\n  - 可用于 `<template>` 表示仅包含文本或多个元素的条件块。\n\n- **示例**\n\n  ```vue-html\n  <div v-if=\"Math.random() > 0.5\">\n    Now you see me\n  </div>\n  <div v-else>\n    Now you don't\n  </div>\n  ```\n\n- **参考**[条件渲染 - v-else](/guide/essentials/conditional#v-else)\n\n## v-else-if {#v-else-if}\n\n表示 `v-if` 的“else if 块”。可以进行链式调用。\n\n- **期望的绑定值类型：**`any`\n\n- **详细信息**\n\n  - 限定：上一个兄弟元素必须有 `v-if` 或 `v-else-if`。\n\n  - 可用于 `<template>` 表示仅包含文本或多个元素的条件块。\n\n- **示例**\n\n  ```vue-html\n  <div v-if=\"type === 'A'\">\n    A\n  </div>\n  <div v-else-if=\"type === 'B'\">\n    B\n  </div>\n  <div v-else-if=\"type === 'C'\">\n    C\n  </div>\n  <div v-else>\n    Not A/B/C\n  </div>\n  ```\n\n- **参考**[条件渲染 - v-else-if](/guide/essentials/conditional#v-else-if)\n\n## v-for {#v-for}\n\n基于原始数据多次渲染元素或模板块。\n\n- **期望的绑定值类型：**`Array | Object | number | string | Iterable`\n\n- **详细信息**\n\n  指令值必须使用特殊语法 `alias in expression` 为正在迭代的元素提供一个别名：\n\n  ```vue-html\n  <div v-for=\"item in items\">\n    {{ item.text }}\n  </div>\n  ```\n\n  或者，你也可以为索引指定别名 (如果用在对象，则是键值)：\n\n  ```vue-html\n  <div v-for=\"(item, index) in items\"></div>\n  <div v-for=\"(value, key) in object\"></div>\n  <div v-for=\"(value, name, index) in object\"></div>\n  ```\n\n  `v-for` 的默认方式是尝试就地更新元素而不移动它们。要强制其重新排序元素，你需要用特殊 attribute `key` 来提供一个排序提示：\n\n  ```vue-html\n  <div v-for=\"item in items\" :key=\"item.id\">\n    {{ item.text }}\n  </div>\n  ```\n\n  `v-for` 也可以用于 [Iterable Protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) 的实现，包括原生 `Map` 和 `Set`。\n\n- **参考**\n  - [列表渲染](/guide/essentials/list)",
          "questions": [
            "`v-text` 和 `{{}}` 有什么区别？",
            "`v-html` 有什么安全风险？如何避免？",
            "`v-show` 是如何控制元素可见性的？",
            "`v-if` 和 `v-for` 同时使用时，哪个优先级更高？",
            "`v-else` 和 `v-else-if` 的使用限制是什么？",
            "`v-for` 可以用于哪些数据类型？",
            "如何为 `v-for` 提供排序提示？",
            "`v-for` 是否支持原生 `Map` 和 `Set`？",
            "`v-for` 中的别名有哪些用法？",
            "`v-for` 可以用于哪些元素或模板块的渲染？"
          ]
        },
        {
          "content": "## v-on {#v-on}\n\n给元素绑定事件监听器。\n\n- **缩写：**`@`\n\n- **期望的绑定值类型：**`Function | Inline Statement | Object (不带参数)`\n\n- **参数：**`event` (使用对象语法则为可选项)\n\n- **修饰符**\n\n  - `.stop` - 调用 `event.stopPropagation()`。\n  - `.prevent` - 调用 `event.preventDefault()`。\n  - `.capture` - 在捕获模式添加事件监听器。\n  - `.self` - 只有事件从元素本身发出才触发处理函数。\n  - `.{keyAlias}` - 只在某些按键下触发处理函数。\n  - `.once` - 最多触发一次处理函数。\n  - `.left` - 只在鼠标左键事件触发处理函数。\n  - `.right` - 只在鼠标右键事件触发处理函数。\n  - `.middle` - 只在鼠标中键事件触发处理函数。\n  - `.passive` - 通过 `{ passive: true }` 附加一个 DOM 事件。\n\n- **详细信息**\n\n  事件类型由参数来指定。表达式可以是一个方法名，一个内联声明，如果有修饰符则可省略。\n\n  当用于普通元素，只监听[**原生 DOM 事件**](https://developer.mozilla.org/en-US/docs/Web/Events)。当用于自定义元素组件，则监听子组件触发的**自定义事件**。\n\n  当监听原生 DOM 事件时，方法接收原生事件作为唯一参数。如果使用内联声明，声明可以访问一个特殊的 `$event` 变量：`v-on:click=\"handle('ok', $event)\"`。\n\n  `v-on` 还支持绑定不带参数的事件/监听器对的对象。请注意，当使用对象语法时，不支持任何修饰符。\n\n- **示例**\n\n  ```vue-html\n  <!-- 方法处理函数 -->\n  <button v-on:click=\"doThis\"></button>\n\n  <!-- 动态事件 -->\n  <button v-on:[event]=\"doThis\"></button>\n\n  <!-- 内联声明 -->\n  <button v-on:click=\"doThat('hello', $event)\"></button>\n\n  <!-- 缩写 -->\n  <button @click=\"doThis\"></button>\n\n  <!-- 使用缩写的动态事件 -->\n  <button @[event]=\"doThis\"></button>\n\n  <!-- 停止传播 -->\n  <button @click.stop=\"doThis\"></button>\n\n  <!-- 阻止默认事件 -->\n  <button @click.prevent=\"doThis\"></button>\n\n  <!-- 不带表达式地阻止默认事件 -->\n  <form @submit.prevent></form>\n\n  <!-- 链式调用修饰符 -->\n  <button @click.stop.prevent=\"doThis\"></button>\n\n  <!-- 按键用于 keyAlias 修饰符-->\n  <input @keyup.enter=\"onEnter\" />\n\n  <!-- 点击事件将最多触发一次 -->\n  <button v-on:click.once=\"doThis\"></button>\n\n  <!-- 对象语法 -->\n  <button v-on=\"{ mousedown: doThis, mouseup: doThat }\"></button>\n  ```\n\n  监听子组件的自定义事件 (当子组件的“my-event”事件被触发，处理函数将被调用)：\n\n  ```vue-html\n  <MyComponent @my-event=\"handleThis\" />\n\n  <!-- 内联声明 -->\n  <MyComponent @my-event=\"handleThis(123, $event)\" />\n  ```\n\n- **参考**\n  - [事件处理](/guide/essentials/event-handling)\n  - [组件 - 自定义事件](/guide/essentials/component-basics#listening-to-events)\n\n## v-bind {#v-bind}\n\n动态的绑定一个或多个 attribute，也可以是组件的 prop。\n\n- **缩写：**`:` 或者 `.` (当使用 `.prop` 修饰符)\n\n- **期望：**`any (带参数) | Object (不带参数)`\n\n- **参数：**`attrOrProp (可选的)`\n\n- **修饰符**\n\n  - `.camel` - 将短横线命名的 attribute 转变为驼峰式命名。\n  - `.prop` - 强制绑定为 DOM property。<sup class=\"vt-badge\">3.2+</sup>\n  - `.attr` - 强制绑定为 DOM attribute。<sup class=\"vt-badge\">3.2+</sup>\n\n- **用途**\n\n  当用于绑定 `class` 或 `style` attribute，`v-bind` 支持额外的值类型如数组或对象。详见下方的指南链接。\n\n  在处理绑定时，Vue 默认会利用 `in` 操作符来检查该元素上是否定义了和绑定的 key 同名的 DOM property。如果存在同名的 property，则 Vue 会将它作为 DOM property 赋值，而不是作为 attribute 设置。这个行为在大多数情况都符合期望的绑定值类型，但是你也可以显式用 `.prop` 和 `.attr` 修饰符来强制绑定方式。有时这是必要的，特别是在和[自定义元素](/guide/extras/web-components#passing-dom-properties)打交道时。\n\n  当用于组件 props 绑定时，所绑定的 props 必须在子组件中已被正确声明。\n\n  当不带参数使用时，可以用于绑定一个包含了多个 attribute 名称-绑定值对的对象。\n\n- **示例**\n\n  ```vue-html\n  <!-- 绑定 attribute -->\n  <img v-bind:src=\"imageSrc\" />\n\n  <!-- 动态 attribute 名 -->\n  <button v-bind:[key]=\"value\"></button>\n\n  <!-- 缩写 -->\n  <img :src=\"imageSrc\" />\n\n  <!-- 缩写形式的动态 attribute 名 -->\n  <button :[key]=\"value\"></button>\n\n  <!-- 内联字符串拼接 -->\n  <img :src=\"'/path/to/images/' + fileName\" />\n\n  <!-- class 绑定 -->\n  <div :class=\"{ red: isRed }\"></div>\n  <div :class=\"[classA, classB]\"></div>\n  <div :class=\"[classA, { classB: isB, classC: isC }]\"></div>\n\n  <!-- style 绑定 -->\n  <div :style=\"{ fontSize: size + 'px' }\"></div>\n  <div :style=\"[styleObjectA, styleObjectB]\"></div>\n\n  <!-- 绑定对象形式的 attribute -->\n  <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n\n  <!-- prop 绑定。“prop” 必须在子组件中已声明。 -->\n  <MyComponent :prop=\"someThing\" />\n\n  <!-- 传递子父组件共有的 prop -->\n  <MyComponent v-bind=\"$props\" />\n\n  <!-- XLink -->\n  <svg><a :xlink:special=\"foo\"></a></svg>\n  ```\n\n  `.prop` 修饰符也有专门的缩写，`.`：\n\n  ```vue-html\n  <div :someProperty.prop=\"someObject\"></div>\n\n  <!-- 等同于 -->\n  <div .someProperty=\"someObject\"></div>\n  ```\n\n  当在 DOM 内模板使用 `.camel` 修饰符，可以驼峰化 `v-bind` attribute 的名称，例如 SVG `viewBox` attribute：\n\n  ```vue-html\n  <svg :view-box.camel=\"viewBox\"></svg>\n  ```\n\n  如果使用字符串模板或使用构建步骤预编译模板，则不需要 `.camel`。\n\n- **参考**\n  - [Class 与 Style 绑定](/guide/essentials/class-and-style)\n  - [组件 -  Prop 传递细节](/guide/components/props#prop-passing-details)\n\n## v-model {#v-model}\n\n在表单输入元素或组件上创建双向绑定。\n\n- **期望的绑定值类型**：根据表单输入元素或组件输出的值而变化\n\n- **仅限：**\n\n  - `<input>`\n  - `<select>`\n  - `<textarea>`\n  - components\n\n- **修饰符**\n\n  - [`.lazy`](/guide/essentials/forms#lazy) - 监听 `change` 事件而不是 `input`\n  - [`.number`](/guide/essentials/forms#number) - 将输入的合法字符串转为数字\n  - [`.trim`](/guide/essentials/forms#trim) - 移除输入内容两端空格\n\n- **参考**\n\n  - [表单输入绑定](/guide/essentials/forms)\n  - [组件事件 - 配合 `v-model` 使用](/guide/components/v-model)\n\n## v-slot {#v-slot}\n\n用于声明具名插槽或是期望接收 props 的作用域插槽。\n\n- **缩写：**`#`\n\n- **期望的绑定值类型**：能够合法在函数参数位置使用的 JavaScript 表达式。支持解构语法。绑定值是可选的——只有在给作用域插槽传递 props 才需要。\n\n- **参数**：插槽名 (可选，默认是 `default`)\n\n- **仅限：**\n\n  - `<template>`\n  - [components](/guide/components/slots#scoped-slots) (用于带有 prop 的单个默认插槽)\n\n- **示例**\n\n  ```vue-html\n  <!-- 具名插槽 -->\n  <BaseLayout>\n    <template v-slot:header>\n      Header content\n    </template>\n\n    <template v-slot:default>\n      Default slot content\n    </template>\n\n    <template v-slot:footer>\n      Footer content\n    </template>\n  </BaseLayout>\n\n  <!-- 接收 prop 的具名插槽 -->\n  <InfiniteScroll>\n    <template v-slot:item=\"slotProps\">\n      <div class=\"item\">\n        {{ slotProps.item.text }}\n      </div>\n    </template>\n  </InfiniteScroll>\n\n  <!-- 接收 prop 的默认插槽，并解构 -->\n  <Mouse v-slot=\"{ x, y }\">\n    Mouse position: {{ x }}, {{ y }}\n  </Mouse>\n  ```\n\n- **参考**\n  - [组件 - 插槽](/guide/components/slots)\n\n## v-pre {#v-pre}\n\n跳过该元素及其所有子元素的编译。\n\n- **无需传入**\n\n- **详细信息**\n\n  元素内具有 `v-pre`，所有 Vue 模板语法都会被保留并按原样渲染。最常见的用例就是显示原始双大括号标签及内容。\n\n- **示例**\n\n  ```vue-html\n  <span v-pre>{{ this will not be compiled }}</span>\n  ```",
          "questions": [
            "v-on指令的缩写是什么？期望的绑定值类型有哪些？",
            "v-on指令的参数是什么？使用对象语法时，支持哪些修饰符？",
            "v-on指令可以监听哪些事件？当监听原生DOM事件时，方法接收什么参数？",
            "v-bind指令的缩写是什么？期望的绑定值类型有哪些？",
            "v-bind指令的参数是什么？使用修饰符时，有哪些可用的修饰符？",
            "v-bind指令可以绑定哪些属性？Vue在处理绑定时会利用什么操作符来检查元素上是否定义了和绑定的key同名的DOM property？",
            "v-model指令可以在哪些元素或组件上创建双向绑定？有哪些可用的修饰符？",
            "v-slot指令的缩写是什么？期望的绑定值类型是什么？参数是什么？",
            "v-slot指令可以用于哪些元素或组件？具名插槽和作用域插槽有什么区别？",
            "v-pre指令的作用是什么？在什么情况下会使用到它？"
          ]
        },
        {
          "content": "## v-once {#v-once}\n\n仅渲染元素和组件一次，并跳过之后的更新。\n\n- **无需传入**\n\n- **详细信息**\n\n  在随后的重新渲染，元素/组件及其所有子项将被当作静态内容并跳过渲染。这可以用来优化更新时的性能。\n\n  ```vue-html\n  <!-- 单个元素 -->\n  <span v-once>This will never change: {{msg}}</span>\n  <!-- 带有子元素的元素 -->\n  <div v-once>\n    <h1>comment</h1>\n    <p>{{msg}}</p>\n  </div>\n  <!-- 组件 -->\n  <MyComponent v-once :comment=\"msg\" />\n  <!-- `v-for` 指令 -->\n  <ul>\n    <li v-for=\"i in list\" v-once>{{i}}</li>\n  </ul>\n  ```\n\n  从 3.2 起，你也可以搭配 [`v-memo`](#v-memo) 的无效条件来缓存部分模板。\n\n- **参考**\n  - [数据绑定语法 - 插值](/guide/essentials/template-syntax#text-interpolation)\n  - [v-memo](#v-memo)\n\n## v-memo <sup class=\"vt-badge\" data-text=\"3.2+\" /> {#v-memo}\n\n- **期望的绑定值类型：**`any[]`\n\n- **详细信息**\n\n  缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过。举例来说：\n\n  ```vue-html\n  <div v-memo=\"[valueA, valueB]\">\n    ...\n  </div>\n  ```\n\n  当组件重新渲染，如果 `valueA` 和 `valueB` 都保持不变，这个 `<div>` 及其子项的所有更新都将被跳过。实际上，甚至虚拟 DOM 的 vnode 创建也将被跳过，因为缓存的子树副本可以被重新使用。\n\n  正确指定缓存数组很重要，否则应该生效的更新可能被跳过。`v-memo` 传入空依赖数组 (`v-memo=\"[]\"`) 将与 `v-once` 效果相同。\n\n  **与 `v-for` 一起使用**\n\n  `v-memo` 仅用于性能至上场景中的微小优化，应该很少需要。最常见的情况可能是有助于渲染海量 `v-for` 列表 (长度超过 1000 的情况)：\n\n  ```vue-html\n  <div v-for=\"item in list\" :key=\"item.id\" v-memo=\"[item.id === selected]\">\n    <p>ID: {{ item.id }} - selected: {{ item.id === selected }}</p>\n    <p>...more child nodes</p>\n  </div>\n  ```\n\n  当组件的 `selected` 状态改变，默认会重新创建大量的 vnode，尽管绝大部分都跟之前是一模一样的。`v-memo` 用在这里本质上是在说“只有当该项的被选中状态改变时才需要更新”。这使得每个选中状态没有变的项能完全重用之前的 vnode 并跳过差异比较。注意这里 memo 依赖数组中并不需要包含 `item.id`，因为 Vue 也会根据 item 的 `:key` 进行判断。\n\n  :::warning 警告\n  当搭配 `v-for` 使用 `v-memo`，确保两者都绑定在同一个元素上。**`v-memo` 不能用在 `v-for` 内部。**\n  :::\n\n  `v-memo` 也能被用于在一些默认优化失败的边际情况下，手动避免子组件出现不需要的更新。但是一样的，开发者需要负责指定正确的依赖数组以免跳过必要的更新。\n\n- **参考**\n  - [v-once](#v-once)\n\n## v-cloak {#v-cloak}\n\n用于隐藏尚未完成编译的 DOM 模板。\n\n- **无需传入**\n\n- **详细信息**\n\n  **该指令只在没有构建步骤的环境下需要使用。**\n\n  当使用直接在 DOM 中书写的模板时，可能会出现一种叫做“未编译模板闪现”的情况：用户可能先看到的是还没编译完成的双大括号标签，直到挂载的组件将它们替换为实际渲染的内容。\n\n  `v-cloak` 会保留在所绑定的元素上，直到相关组件实例被挂载后才移除。配合像 `[v-cloak] { display: none }` 这样的 CSS 规则，它可以在组件编译完毕前隐藏原始模板。\n\n- **示例**\n\n  ```css\n  [v-cloak] {\n    display: none;\n  }\n  ```\n\n  ```vue-html\n  <div v-cloak>\n    {{ message }}\n  </div>\n  ```\n\n  直到编译完成前，`<div>` 将不可见。",
          "questions": [
            "什么是v-once指令？它的作用是什么？",
            "v-once指令可以用在哪些元素和组件上？如何使用？",
            "v-memo指令的作用是什么？它需要传入什么参数？",
            "v-memo指令可以和哪些指令一起使用？如何正确使用？",
            "在使用v-for指令渲染大量列表时，如何使用v-memo指令进行优化？",
            "什么是v-cloak指令？它的作用是什么？",
            "v-cloak指令需要传入什么参数吗？如何使用？",
            "为什么需要使用v-cloak指令？它解决了什么问题？",
            "v-cloak指令可以和哪些CSS规则一起使用？如何使用？",
            "v-cloak指令在什么情况下需要使用？"
          ]
        }
      ]
    },
    {
      "file_name": "custom-renderer.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 自定义渲染器 API {#custom-renderer-api}\n\n## createRenderer() {#createrenderer}\n\n创建一个自定义渲染器。通过提供平台特定的节点创建以及更改 API，你可以在非 DOM 环境中也享受到 Vue 核心运行时的特性。\n\n- **类型**\n\n  ```ts\n  function createRenderer<HostNode, HostElement>(\n    options: RendererOptions<HostNode, HostElement>\n  ): Renderer<HostElement>\n\n  interface Renderer<HostElement> {\n    render: RootRenderFunction<HostElement>\n    createApp: CreateAppFunction<HostElement>\n  }\n\n  interface RendererOptions<HostNode, HostElement> {\n    patchProp(\n      el: HostElement,\n      key: string,\n      prevValue: any,\n      nextValue: any,\n      // 其余部分在大多数自定义渲染器中是不会使用的\n      isSVG?: boolean,\n      prevChildren?: VNode<HostNode, HostElement>[],\n      parentComponent?: ComponentInternalInstance | null,\n      parentSuspense?: SuspenseBoundary | null,\n      unmountChildren?: UnmountChildrenFn\n    ): void\n    insert(\n      el: HostNode,\n      parent: HostElement,\n      anchor?: HostNode | null\n    ): void\n    remove(el: HostNode): void\n    createElement(\n      type: string,\n      isSVG?: boolean,\n      isCustomizedBuiltIn?: string,\n      vnodeProps?: (VNodeProps & { [key: string]: any }) | null\n    ): HostElement\n    createText(text: string): HostNode\n    createComment(text: string): HostNode\n    setText(node: HostNode, text: string): void\n    setElementText(node: HostElement, text: string): void\n    parentNode(node: HostNode): HostElement | null\n    nextSibling(node: HostNode): HostNode | null\n\n    // 可选的, DOM 特有的\n    querySelector?(selector: string): HostElement | null\n    setScopeId?(el: HostElement, id: string): void\n    cloneNode?(node: HostNode): HostNode\n    insertStaticContent?(\n      content: string,\n      parent: HostElement,\n      anchor: HostNode | null,\n      isSVG: boolean\n    ): [HostNode, HostNode]\n  }\n  ```\n\n- **示例**\n\n  ```js\n  import { createRenderer } from '@vue/runtime-core'\n\n  const { render, createApp } = createRenderer({\n    patchProp,\n    insert,\n    remove,\n    createElement\n    // ...\n  })\n\n  // `render` 是底层 API\n  // `createApp` 返回一个应用实例\n  export { render, createApp }\n\n  // 重新导出 Vue 的核心 API\n  export * from '@vue/runtime-core'\n  ```\n\n  Vue 自身的 `@vue/runtime-dom` 也是[利用这套 API 实现的](https://github.com/vuejs/core/blob/main/packages/runtime-dom/src/index.ts)。要想了解一个简单一些的实现，请参考 [`@vue/runtime-test`](https://github.com/vuejs/core/blob/main/packages/runtime-test/src/index.ts)，这是一个 Vue 自己做单元测试的私有包。",
          "questions": [
            "什么是自定义渲染器 API？",
            "通过提供平台特定的节点创建以及更改 API，可以在哪些环境中享受到 Vue 核心运行时的特性？",
            "`createRenderer()` 是什么类型的函数？",
            "`createRenderer()` 函数的参数是什么？",
            "`Renderer` 接口有哪些属性？",
            "`RendererOptions` 接口有哪些属性？",
            "`patchProp()` 方法的参数是什么？",
            "`createElement()` 方法的参数是什么？",
            "`insertStaticContent()` 方法的参数是什么？",
            "`@vue/runtime-dom` 是如何实现的？"
          ]
        }
      ]
    },
    {
      "file_name": "ssr.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 服务端渲染 API {#server-side-rendering-api}\n\n## renderToString() {#rendertostring}\n\n- **导出自 `vue/server-renderer`**\n\n- **类型**\n\n  ```ts\n  function renderToString(\n    input: App | VNode,\n    context?: SSRContext\n  ): Promise<string>\n  ```\n\n- **示例**\n\n  ```js\n  import { createSSRApp } from 'vue'\n  import { renderToString } from 'vue/server-renderer'\n\n  const app = createSSRApp({\n    data: () => ({ msg: 'hello' }),\n    template: `<div>{{ msg }}</div>`\n  })\n\n  ;(async () => {\n    const html = await renderToString(app)\n    console.log(html)\n  })()\n  ```\n\n  ### SSR 上下文 {#ssr-context}\n\n  你可以传入一个可选的上下文对象用来在渲染过程中记录额外的数据，例如[访问 Teleport 的内容](/guide/scaling-up/ssr#teleports)：\n\n  ```js\n  const ctx = {}\n  const html = await renderToString(app, ctx)\n\n  console.log(ctx.teleports) // { '#teleported': 'teleported content' }\n  ```\n\n  这个页面中的其他大多数 SSR API 也可以接受一个上下文对象。该上下文对象可以在组件代码里通过 [useSSRContext](#usessrcontext) 辅助函数进行访问。\n\n- **参考**[指南 - 服务端渲染 (SSR)](/guide/scaling-up/ssr)\n\n## renderToNodeStream() {#rendertonodestream}\n\n将输入渲染为一个 [Node.js Readable stream](https://nodejs.org/api/stream.html#stream_class_stream_readable) 实例。\n\n- **导出自 `vue/server-renderer`**\n\n- **类型**\n\n  ```ts\n  function renderToNodeStream(\n    input: App | VNode,\n    context?: SSRContext\n  ): Readable\n  ```\n\n- **示例**\n\n  ```js\n  // 在一个 Node.js http 处理函数内\n  renderToNodeStream(app).pipe(res)\n  ```\n\n  :::tip 备注\n  `vue/server-renderer` 的 ESM 构建不支持此方法，因为它是与 Node.js 环境分离的。请换为使用 [`pipeToNodeWritable`](#pipetonodewritable)。\n  :::\n\n## pipeToNodeWritable() {#pipetonodewritable}\n\n将输入渲染并 pipe 到一个 [Node.js Writable stream](https://nodejs.org/api/stream.html#stream_writable_streams) 实例。\n\n- **导出自 `vue/server-renderer`**\n\n- **类型**\n\n  ```ts\n  function pipeToNodeWritable(\n    input: App | VNode,\n    context: SSRContext = {},\n    writable: Writable\n  ): void\n  ```\n\n- **示例**\n\n  ```js\n  // 在一个 Node.js http 处理函数内\n  pipeToNodeWritable(app, {}, res)\n  ```\n\n## renderToWebStream() {#rendertowebstream}\n\n将输入渲染为一个 [Web ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) 实例。\n\n- **导出自 `vue/server-renderer`**\n\n- **类型**\n\n  ```ts\n  function renderToWebStream(\n    input: App | VNode,\n    context?: SSRContext\n  ): ReadableStream\n  ```\n\n- **示例**\n\n  ```js\n  // 在一个支持 ReadableStream 的环境下\n  return new Response(renderToWebStream(app))\n  ```\n\n  :::tip 备注\n  在不能全局暴露 `ReadableStream` 构造函数的环境下，请换为使用 [`pipeToWebWritable()`](#pipetowebwritable)。\n  :::\n\n## pipeToWebWritable() {#pipetowebwritable}\n\n将输入渲染并 pipe 到一个 [Web WritableStream](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream) 实例。\n\n- **导出自 `vue/server-renderer`**\n\n- **类型**\n\n  ```ts\n  function pipeToWebWritable(\n    input: App | VNode,\n    context: SSRContext = {},\n    writable: WritableStream\n  ): void\n  ```\n\n- **示例**\n\n  通常与 [`TransformStream`](https://developer.mozilla.org/en-US/docs/Web/API/TransformStream) 结合使用：\n\n  ```js\n  // 诸如 CloudFlare worker 这样的环境中，TransformStream 是可用的。\n  // 在 Node.js 中，TransformStream 需要从 'stream/web' 显示导入。\n  const { readable, writable } = new TransformStream()\n  pipeToWebWritable(app, {}, writable)\n\n  return new Response(readable)\n  ```\n\n## renderToSimpleStream() {#rendertosimplestream}\n\n通过一个简单的接口，将输入以 stream 模式进行渲染。\n\n- **导出自 `vue/server-renderer`**\n\n- **类型**\n\n  ```ts\n  function renderToSimpleStream(\n    input: App | VNode,\n    context: SSRContext,\n    options: SimpleReadable\n  ): SimpleReadable\n\n  interface SimpleReadable {\n    push(content: string | null): void\n    destroy(err: any): void\n  }\n  ```\n\n- **示例**\n\n  ```js\n  let res = ''\n\n  renderToSimpleStream(\n    app,\n    {},\n    {\n      push(chunk) {\n        if (chunk === null) {\n          // done\n          console(`render complete: ${res}`)\n        } else {\n          res += chunk\n        }\n      },\n      destroy(err) {\n        // error encountered\n      }\n    }\n  )\n  ```\n\n## useSSRContext() {#usessrcontext}\n\n一个运行时 API，用于获取已传递给 `renderToString()` 或其他服务端渲染 API 的上下文对象。\n\n- **类型**\n\n  ```ts\n  function useSSRContext<T = Record<string, any>>(): T | undefined\n  ```\n\n- **示例**\n\n  得到的上下文能够作为附加信息用于渲染最终的 HTML (例如 head 中的元数据)。\n\n  ```vue\n  <script setup>\n  import { useSSRContext } from 'vue'\n\n  // 确保只在服务端渲染时调用\n  // https://cn.vitejs.dev/guide/ssr.html#conditional-logic\n  if (import.meta.env.SSR) {\n    const ctx = useSSRContext()\n    // ...给上下文对象添加属性\n  }\n  </script>\n  ```",
          "questions": [
            "`renderToString()` 和 `renderToNodeStream()` 分别返回什么类型的实例？",
            "`pipeToNodeWritable()` 和 `pipeToWebWritable()` 分别接受哪些参数？",
            "`renderToWebStream()` 和 `renderToSimpleStream()` 分别返回什么类型的实例？",
            "在服务端渲染过程中，如何记录额外的数据？",
            "如何在组件代码中访问服务端渲染过程中记录的上下文对象？",
            "`useSSRContext()` 是什么？它的返回值是什么类型？",
            "在什么情况下应该使用 `pipeToWebWritable()` 代替 `renderToWebStream()`？",
            "`renderToSimpleStream()` 的 `SimpleReadable` 接口有哪些方法？",
            "在服务端渲染中，如何给上下文对象添加属性？",
            "`vue/server-renderer` 的 ESM 构建不支持哪个方法？为什么？"
          ]
        }
      ]
    },
    {
      "file_name": "built-in-special-elements.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 内置特殊元素 {#built-in-special-elements}\n\n:::info 不是组件\n`<component>`、`<slot>` 和 `<template>` 具有类似组件的特性，也是模板语法的一部分。但它们并非真正的组件，同时在模板编译期间会被编译掉。因此，它们通常在模板中用小写字母书写。\n:::\n\n## `<component>` {#component}\n\n一个用于渲染动态组件或元素的“元组件”。\n\n- **Props**\n\n  ```ts\n  interface DynamicComponentProps {\n    is: string | Component\n  }\n  ```\n\n- **详细信息**\n\n  要渲染的实际组件由 `is` prop 决定。\n\n  - 当 `is` 是字符串，它既可以是 HTML 标签名也可以是组件的注册名。\n\n  - 或者，`is` 也可以直接绑定到组件的定义。\n\n- **示例**\n\n  按注册名渲染组件 (选项式 API)：\n\n  ```vue\n  <script>\n  import Foo from './Foo.vue'\n  import Bar from './Bar.vue'\n\n  export default {\n    components: { Foo, Bar },\n    data() {\n      return {\n        view: 'Foo'\n      }\n    }\n  }\n  </script>\n\n  <template>\n    <component :is=\"view\" />\n  </template>\n  ```\n\n  按定义渲染组件 (`<script setup>` 组合式 API)：\n\n  ```vue\n  <script setup>\n  import Foo from './Foo.vue'\n  import Bar from './Bar.vue'\n  </script>\n\n  <template>\n    <component :is=\"Math.random() > 0.5 ? Foo : Bar\" />\n  </template>\n  ```\n\n  渲染 HTML 元素：\n\n  ```vue-html\n  <component :is=\"href ? 'a' : 'span'\"></component>\n  ```\n\n  [内置组件](./built-in-components)都可以传递给 `is`，但是如果想通过名称传递则必须先对其进行注册。举例来说：\n\n  ```vue\n  <script>\n  import { Transition, TransitionGroup } from 'vue'\n\n  export default {\n    components: {\n      Transition,\n      TransitionGroup\n    }\n  }\n  </script>\n\n  <template>\n    <component :is=\"isGroup ? 'TransitionGroup' : 'Transition'\">\n      ...\n    </component>\n  </template>\n  ```\n\n  如果将组件本身传递给 `is` 而不是其名称，则不需要注册，例如在 `<script setup>` 中。\n\n  如果在 `<component>` 标签上使用 `v-model`，模板编译器会将其扩展为 `modelValue` prop 和 `update:modelValue` 事件监听器，就像对任何其他组件一样。但是，这与原生 HTML 元素不兼容，例如 `<input>` 或 `<select>`。因此，在动态创建的原生元素上使用 `v-model` 将不起作用：\n\n  ```vue\n  <script setup>\n  import { ref } from 'vue'\n\n  const tag = ref('input')\n  const username = ref('')\n  </script>\n\n  <template>\n    <!-- 由于 'input' 是原生 HTML 元素，因此这个 v-model 不起作用 -->\n    <component :is=\"tag\" v-model=\"username\" />\n  </template>\n  ```\n\n  在实践中，这种极端情况并不常见，因为原生表单字段通常包裹在实际应用的组件中。如果确实需要直接使用原生元素，那么你可以手动将 `v-model` 拆分为 attribute 和事件。\n\n- **参考**[动态组件](/guide/essentials/component-basics#dynamic-components)\n\n## `<slot>` {#slot}\n\n表示模板中的插槽内容出口。\n\n- **Props**\n\n  ```ts\n  interface SlotProps {\n    /**\n     * 任何传递给 <slot> 的 prop 都可以作为作用域插槽\n     * 的参数传递\n     */\n    [key: string]: any\n    /**\n     * 保留，用于指定插槽名。\n     */\n    name?: string\n  }\n  ```\n\n- **详细信息**\n\n  `<slot>` 元素可以使用 `name` attribute 来指定插槽名。当没有指定 `name` 时，将会渲染默认插槽。传递给插槽元素的附加 attributes 将作为插槽 props，传递给父级中定义的作用域插槽。\n\n  元素本身将被其所匹配的插槽内容替换。\n\n  Vue 模板里的 `<slot>` 元素会被编译到 JavaScript，因此不要与[原生 `<slot>` 元素](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot)进行混淆。\n\n- **参考**[组件 - 插槽](/guide/components/slots)\n\n## `<template>` {#template}\n\n当我们想要使用内置指令而不在 DOM 中渲染元素时，`<template>` 标签可以作为占位符使用。\n\n- **详细信息**\n\n  对 `<template>` 的特殊处理只有在它与以下任一指令一起使用时才会被触发：\n\n  - `v-if`、`v-else-if` 或 `v-else`\n  - `v-for`\n  - `v-slot`\n\n  如果这些指令都不存在，那么它将被渲染成一个[原生的 `<template>` 元素](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template)。\n\n  带有 `v-for` 的 `<template>` 也可以有一个 [`key` 属性](/api/built-in-special-attributes#key)。所有其他的属性和指令都将被丢弃，因为没有相应的元素，它们就没有意义。\n\n  单文件组件使用[顶层的 `<template>` 标签](/api/sfc-spec#language-blocks)来包裹整个模板。这种用法与上面描述的 `<template>` 使用方式是有区别的。该顶层标签不是模板本身的一部分，不支持指令等模板语法。\n\n- **参考**\n  - [指南 - `<template>` 上的 `v-if`](/guide/essentials/conditional#v-if-on-template)\n  - [指南 - `<template>` 上的 `v-for`](/guide/essentials/list#v-for-on-template)\n  - [指南 - 具名插槽](/guide/components/slots#named-slots)",
          "questions": [
            "`<component>` 元素的作用是什么？",
            "`is` prop 的作用是什么？",
            "`<slot>` 元素的作用是什么？",
            "`<template>` 标签在什么情况下会被特殊处理？",
            "`<template>` 标签可以有哪些指令？",
            "`<slot>` 元素可以有哪些属性？",
            "`<component>` 元素可以渲染哪些内容？",
            "`<component>` 元素的 `is` prop 可以绑定到哪些内容？",
            "在动态创建的原生元素上使用 `v-model` 会出现什么问题？",
            "顶层的 `<template>` 标签与普通的 `<template>` 标签有什么区别？"
          ]
        }
      ]
    },
    {
      "file_name": "built-in-special-attributes.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 内置的特殊 Attributes {#built-in-special-attributes}\n\n## key {#key}\n\n`key` 这个特殊的 attribute 主要作为 Vue 的虚拟 DOM 算法提示，在比较新旧节点列表时用于识别 vnode。\n\n- **预期**：`number | string | symbol`\n\n- **详细信息**\n\n  在没有 key 的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新/复用相同类型的元素。如果传了 key，则将根据 key 的变化顺序来重新排列元素，并且将始终移除/销毁 key 已经不存在的元素。\n\n  同一个父元素下的子元素必须具有**唯一的 key**。重复的 key 将会导致渲染异常。\n\n  最常见的用例是与 `v-for` 结合：\n\n  ```vue-html\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">...</li>\n  </ul>\n  ```\n\n  也可以用于强制替换一个元素/组件而不是复用它。当你想这么做时它可能会很有用：\n\n  - 在适当的时候触发组件的生命周期钩子\n  - 触发过渡\n\n  举例来说：\n\n  ```vue-html\n  <transition>\n    <span :key=\"text\">{{ text }}</span>\n  </transition>\n  ```\n\n  当 `text` 变化时，`<span>` 总是会被替换而不是更新，因此 transition 将会被触发。\n\n- **参考**[指南 - 列表渲染 - 通过 `key` 管理状态](/guide/essentials/list#maintaining-state-with-key)\n\n## ref {#ref}\n\n用于注册[模板引用](/guide/essentials/template-refs)。\n\n- **预期**：`string | Function`\n\n- **详细信息**\n\n  `ref` 用于注册元素或子组件的引用。\n\n  使用选项式 API，引用将被注册在组件的 `this.$refs` 对象里：\n\n  ```vue-html\n  <!-- 存储为 this.$refs.p -->\n  <p ref=\"p\">hello</p>\n  ```\n\n  使用组合式 API，引用将存储在与名字匹配的 ref 里：\n\n  ```vue\n  <script setup>\n  import { ref } from 'vue'\n\n  const p = ref()\n  </script>\n\n  <template>\n    <p ref=\"p\">hello</p>\n  </template>\n  ```\n\n  如果用于普通 DOM 元素，引用将是元素本身；如果用于子组件，引用将是子组件的实例。\n\n  或者 `ref` 可以接收一个函数值，用于对存储引用位置的完全控制：\n\n  ```vue-html\n  <ChildComponent :ref=\"(el) => child = el\" />\n  ```\n\n  关于 ref 注册时机的重要说明：因为 ref 本身是作为渲染函数的结果来创建的，必须等待组件挂载后才能对它进行访问。\n\n  `this.$refs` 也是非响应式的，因此你不应该尝试在模板中使用它来进行数据绑定。\n\n- **参考**\n  - [指南 - 模板引用](/guide/essentials/template-refs)\n  - [指南 - 为模板引用标注类型](/guide/typescript/composition-api#typing-template-refs) <sup class=\"vt-badge ts\" />\n  - [指南 - 为组件模板引用标注类型](/guide/typescript/composition-api#typing-component-template-refs) <sup class=\"vt-badge ts\" />\n\n## is {#is}\n\n用于绑定[动态组件](/guide/essentials/component-basics#dynamic-components)。\n\n- **预期**：`string | Component`\n\n- **用于原生元素** <sup class=\"vt-badge\">3.1+</sup>\n\n  当 `is` attribute 用于原生 HTML 元素时，它将被当作 [Customized built-in element](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example)，其为原生 web 平台的特性。\n\n  但是，在这种用例中，你可能需要 Vue 用其组件来替换原生元素，如 [DOM 内模板解析注意事项](/guide/essentials/component-basics#in-dom-template-parsing-caveats)所述。你可以在 `is` attribute 的值中加上 `vue:` 前缀，这样 Vue 就会把该元素渲染为 Vue 组件：\n\n  ```vue-html\n  <table>\n    <tr is=\"vue:my-row-component\"></tr>\n  </table>\n  ```\n\n- **参考**\n\n  - [内置特殊元素 - `<component>`](/api/built-in-special-elements#component)\n  - [动态组件](/guide/essentials/component-basics#dynamic-components)",
          "questions": [
            "什么是 key 属性？它在 Vue 中有什么作用？",
            "key 属性的预期值是什么？为什么？",
            "在没有 key 的情况下，Vue 会使用什么算法来更新元素？",
            "为什么同一个父元素下的子元素必须具有唯一的 key？",
            "key 属性可以用于哪些场景？",
            "什么是 ref 属性？它在 Vue 中有什么作用？",
            "ref 属性的预期值是什么？为什么？",
            "ref 属性可以接收哪些值？分别有什么作用？",
            "ref 注册时机有什么重要说明？",
            "在模板中可以使用 this.$refs 进行数据绑定吗？为什么？"
          ]
        }
      ]
    },
    {
      "file_name": "built-in-components.md",
      "question_count": 10,
      "documents": [
        {
          "content": "---\npageClass: api\n---\n\n# 内置组件 {#built-in-components}\n\n:::info 组件注册和使用\n内置组件无需注册便可以直接在模板中使用。它们也支持 tree-shake：仅在使用时才会包含在构建中。\n\n在[渲染函数](/guide/extras/render-function)中使用它们时，需要显式导入。例如：\n\n```js\nimport { h, Transition } from 'vue'\n\nh(Transition, {\n  /* props */\n})\n```\n\n:::\n\n## `<Transition>` {#transition}\n\n为**单个**元素或组件提供动画过渡效果。\n\n- **Props**\n\n  ```ts\n  interface TransitionProps {\n    /**\n     * 用于自动生成过渡 CSS class 名。\n     * 例如 `name: 'fade'` 将自动扩展为 `.fade-enter`、\n     * `.fade-enter-active` 等。\n     */\n    name?: string\n    /**\n     * 是否应用 CSS 过渡 class。\n     * 默认：true\n     */\n    css?: boolean\n    /**\n     * 指定要等待的过渡事件类型\n     * 来确定过渡结束的时间。\n     * 默认情况下会自动检测\n     * 持续时间较长的类型。\n     */\n    type?: 'transition' | 'animation'\n    /**\n     * 显式指定过渡的持续时间。\n     * 默认情况下是等待过渡效果的根元素的第一个 `transitionend`\n     * 或`animationend`事件。\n     */\n    duration?: number | { enter: number; leave: number }\n    /**\n     * 控制离开/进入过渡的时序。\n     * 默认情况下是同时的。\n     */\n    mode?: 'in-out' | 'out-in' | 'default'\n    /**\n     * 是否对初始渲染使用过渡。\n     * 默认：false\n     */\n    appear?: boolean\n\n    /**\n     * 用于自定义过渡 class 的 prop。\n     * 在模板中使用短横线命名，例如：enter-from-class=\"xxx\"\n     */\n    enterFromClass?: string\n    enterActiveClass?: string\n    enterToClass?: string\n    appearFromClass?: string\n    appearActiveClass?: string\n    appearToClass?: string\n    leaveFromClass?: string\n    leaveActiveClass?: string\n    leaveToClass?: string\n  }\n  ```\n\n- **事件**\n\n  - `@before-enter`\n  - `@before-leave`\n  - `@enter`\n  - `@leave`\n  - `@appear`\n  - `@after-enter`\n  - `@after-leave`\n  - `@after-appear`\n  - `@enter-cancelled`\n  - `@leave-cancelled` (`v-show` only)\n  - `@appear-cancelled`\n\n- **示例**\n\n  简单元素：\n\n  ```vue-html\n  <Transition>\n    <div v-if=\"ok\">toggled content</div>\n  </Transition>\n  ```\n\n  通过改变 `key` 属性来强制过度执行：\n\n  ```vue-html\n  <Transition>\n    <div :key=\"text\">{{ text }}</div>\n  </Transition>\n  ```\n\n  动态组件，初始渲染时带有过渡模式 + 动画出现：\n\n  ```vue-html\n  <Transition name=\"fade\" mode=\"out-in\" appear>\n    <component :is=\"view\"></component>\n  </Transition>\n  ```\n\n  监听过渡事件：\n\n  ```vue-html\n  <Transition @after-enter=\"onTransitionComplete\">\n    <div v-show=\"ok\">toggled content</div>\n  </Transition>\n  ```\n\n- **参考** [`<Transition>` 指南](/guide/built-ins/transition)\n\n## `<TransitionGroup>` {#transitiongroup}\n\n为列表中的**多个**元素或组件提供过渡效果。\n\n- **Props**\n\n  `<TransitionGroup>` 拥有与 `<Transition>` 除了 `mode` 以外所有的 props，并增加了两个额外的 props：\n\n  ```ts\n  interface TransitionGroupProps extends Omit<TransitionProps, 'mode'> {\n    /**\n     * 如果未定义，则渲染为片段 (fragment)。\n     */\n    tag?: string\n    /**\n     * 用于自定义过渡期间被应用的 CSS class。\n     * 在模板中使用 kebab-case，例如 move-class=\"xxx\"\n     */\n    moveClass?: string\n  }\n  ```\n\n- **事件**\n\n  `<TransitionGroup>` 抛出与 `<Transition>` 相同的事件。\n\n- **详细信息**\n\n  默认情况下，`<TransitionGroup>` 不会渲染一个容器 DOM 元素，但是可以通过 `tag` prop 启用。\n\n  注意，每个 `<transition-group>` 的子节点必须有[**独立的 key**](/guide/essentials/list#maintaining-state-with-key)，动画才能正常工作。\n\n  `<TransitionGroup>` 支持通过 CSS transform 控制移动效果。当一个子节点在屏幕上的位置在更新之后发生变化时，它会被添加一个使其位移的 CSS class (基于 `name` attribute 推导，或使用 `move-class` prop 显式配置)。如果使其位移的 class 被添加时 CSS 的 `transform` 属性是“可过渡的”，那么该元素会基于 [FLIP 技巧](https://aerotwist.com/blog/flip-your-animations/)平滑地到达动画终点。\n\n- **示例**\n\n  ```vue-html\n  <TransitionGroup tag=\"ul\" name=\"slide\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </TransitionGroup>\n  ```\n\n- **参考**[指南 - TransitionGroup](/guide/built-ins/transition-group)\n\n## `<KeepAlive>` {#keepalive}\n\n缓存包裹在其中的动态切换组件。\n\n- **Props**\n\n  ```ts\n  interface KeepAliveProps {\n    /**\n     * 如果指定，则只有与 `include` 名称\n     * 匹配的组件才会被缓存。\n     */\n    include?: MatchPattern\n    /**\n     * 任何名称与 `exclude`\n     * 匹配的组件都不会被缓存。\n     */\n    exclude?: MatchPattern\n    /**\n     * 最多可以缓存多少组件实例。\n     */\n    max?: number | string\n  }\n\n  type MatchPattern = string | RegExp | (string | RegExp)[]\n  ```\n\n- **详细信息**\n\n  `<KeepAlive>` 包裹动态组件时，会缓存不活跃的组件实例，而不是销毁它们。\n\n  任何时候都只能有一个活跃组件实例作为 `<KeepAlive>` 的直接子节点。\n\n  当一个组件在 `<KeepAlive>` 中被切换时，它的 `activated` 和 `deactivated` 生命周期钩子将被调用，用来替代 `mounted` 和 `unmounted`。这适用于 `<KeepAlive>` 的直接子节点及其所有子孙节点。\n\n- **示例**\n\n  基本用法：\n\n  ```vue-html\n  <KeepAlive>\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n\n  与 `v-if` / `v-else` 分支一起使用时，同一时间只能有一个组件被渲染：\n\n  ```vue-html\n  <KeepAlive>\n    <comp-a v-if=\"a > 1\"></comp-a>\n    <comp-b v-else></comp-b>\n  </KeepAlive>\n  ```\n\n  与 `<Transition>` 一起使用：\n\n  ```vue-html\n  <Transition>\n    <KeepAlive>\n      <component :is=\"view\"></component>\n    </KeepAlive>\n  </Transition>\n  ```\n\n  使用 `include` / `exclude`：\n\n  ```vue-html\n  <!-- 用逗号分隔的字符串 -->\n  <KeepAlive include=\"a,b\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n\n  <!-- 正则表达式 (使用 `v-bind`) -->\n  <KeepAlive :include=\"/a|b/\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n\n  <!-- 数组 (使用 `v-bind`) -->\n  <KeepAlive :include=\"['a', 'b']\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n\n  使用 `max`：\n\n  ```vue-html\n  <KeepAlive :max=\"10\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n\n- **参考**[指南 - KeepAlive](/guide/built-ins/keep-alive)\n\n## `<Teleport>` {#teleport}\n\n将其插槽内容渲染到 DOM 中的另一个位置。\n\n- **Props**\n\n  ```ts\n  interface TeleportProps {\n    /**\n     * 必填项。指定目标容器。\n     * 可以是选择器或实际元素。\n     */\n    to: string | HTMLElement\n    /**\n     * 当值为 `true` 时，内容将保留在其原始位置\n     * 而不是移动到目标容器中。\n     * 可以动态更改。\n     */\n    disabled?: boolean\n  }\n  ```\n\n- **示例**\n\n  指定目标容器：\n\n  ```vue-html\n  <teleport to=\"#some-id\" />\n  <teleport to=\".some-class\" />\n  <teleport to=\"[data-teleport]\" />\n  ```\n\n  有条件地禁用：\n\n  ```vue-html\n  <teleport to=\"#popup\" :disabled=\"displayVideoInline\">\n    <video src=\"./my-movie.mp4\">\n  </teleport>\n  ```\n\n- **参考**[指南 - Teleport](/guide/built-ins/teleport)\n\n## `<Suspense>` <sup class=\"vt-badge experimental\" /> {#suspense}\n\n用于协调对组件树中嵌套的异步依赖的处理。\n\n- **Props**\n\n  ```ts\n  interface SuspenseProps {\n    timeout?: string | number\n  }\n  ```\n\n- **事件**\n\n  - `@resolve`\n  - `@pending`\n  - `@fallback`\n\n- **详细信息**\n\n  `<Suspense>` 接受两个插槽：`#default` 和 `#fallback`。它将在内存中渲染默认插槽的同时展示后备插槽内容。\n\n  如果在渲染时遇到异步依赖项 ([异步组件](/guide/components/async)和具有 [`async setup()`](/guide/built-ins/suspense#async-setup) 的组件)，它将等到所有异步依赖项解析完成时再显示默认插槽。\n\n- **参考**[指南 - Suspense](/guide/built-ins/suspense)",
          "questions": [
            "`<Transition>` 组件有哪些 props 和事件？",
            "`<TransitionGroup>` 组件有哪些 props 和事件？",
            "`<KeepAlive>` 组件有哪些 props 和用法示例？",
            "`<Teleport>` 组件有哪些 props 和用法示例？",
            "`<Suspense>` 组件的作用是什么？有哪些 props 和事件？",
            "`<Transition>` 组件的 `appear` prop 有什么作用？",
            "`<Transition>` 组件的 `mode` prop 有哪些取值？",
            "`<TransitionGroup>` 组件的子节点需要满足什么条件才能正常工作？",
            "`<KeepAlive>` 组件的 `activated` 和 `deactivated` 生命周期钩子分别在什么时候被调用？",
            "`<Teleport>` 组件的 `disabled` prop 有什么作用？"
          ]
        }
      ]
    },
    {
      "file_name": "render-function.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# 渲染函数 API {#render-function-apis}\n\n## h() {#h}\n\n创建虚拟 DOM 节点 (vnode)。\n\n- **类型**\n\n  ```ts\n  // 完整参数签名\n  function h(\n    type: string | Component,\n    props?: object | null,\n    children?: Children | Slot | Slots\n  ): VNode\n\n  // 省略 props\n  function h(type: string | Component, children?: Children | Slot): VNode\n\n  type Children = string | number | boolean | VNode | null | Children[]\n\n  type Slot = () => Children\n\n  type Slots = { [name: string]: Slot }\n  ```\n\n  > 为了便于阅读，对类型进行了简化。\n\n- **详细信息**\n\n  第一个参数既可以是一个字符串 (用于原生元素) 也可以是一个 Vue 组件定义。第二个参数是要传递的 prop，第三个参数是子节点。\n\n  当创建一个组件的 vnode 时，子节点必须以插槽函数进行传递。如果组件只有默认槽，可以使用单个插槽函数进行传递。否则，必须以插槽函数的对象形式来传递。\n\n  为了方便阅读，当子节点不是插槽对象时，可以省略 prop 参数。\n\n- **示例**\n\n  创建原生元素：\n\n  ```js\n  import { h } from 'vue'\n\n  // 除了 type 外，其他参数都是可选的\n  h('div')\n  h('div', { id: 'foo' })\n\n  // attribute 和 property 都可以用于 prop\n  // Vue 会自动选择正确的方式来分配它\n  h('div', { class: 'bar', innerHTML: 'hello' })\n\n  // class 与 style 可以像在模板中一样\n  // 用数组或对象的形式书写\n  h('div', { class: [foo, { bar }], style: { color: 'red' } })\n\n  // 事件监听器应以 onXxx 的形式书写\n  h('div', { onClick: () => {} })\n\n  // children 可以是一个字符串\n  h('div', { id: 'foo' }, 'hello')\n\n  // 没有 prop 时可以省略不写\n  h('div', 'hello')\n  h('div', [h('span', 'hello')])\n\n  // children 数组可以同时包含 vnode 和字符串\n  h('div', ['hello', h('span', 'hello')])\n  ```\n\n  创建组件：\n\n  ```js\n  import Foo from './Foo.vue'\n\n  // 传递 prop\n  h(Foo, {\n    // 等价于 some-prop=\"hello\"\n    someProp: 'hello',\n    // 等价于 @update=\"() => {}\"\n    onUpdate: () => {}\n  })\n\n  // 传递单个默认插槽\n  h(Foo, () => 'default slot')\n\n  // 传递具名插槽\n  // 注意，需要使用 `null` 来避免\n  // 插槽对象被当作是 prop\n  h(MyComponent, null, {\n    default: () => 'default slot',\n    foo: () => h('div', 'foo'),\n    bar: () => [h('span', 'one'), h('span', 'two')]\n  })\n  ```\n\n- **参考**[指南 - 渲染函数 - 创建 VNode](/guide/extras/render-function#creating-vnodes)\n\n## mergeProps() {#mergeprops}\n\n合并多个 props 对象，用于处理含有特定的 props 参数的情况。\n\n- **类型**\n\n  ```ts\n  function mergeProps(...args: object[]): object\n  ```\n\n- **详细信息**\n\n  `mergeProps()` 支持以下特定 props 参数的处理，将它们合并成一个对象。\n\n  - `class`\n  - `style`\n  - `onXxx` 事件监听器——多个同名的事件监听器将被合并到一个数组。\n\n  如果你不需要合并行为而是简单覆盖，可以使用原生 object spread 语法来代替。\n\n- **示例**\n\n  ```js\n  import { mergeProps } from 'vue'\n\n  const one = {\n    class: 'foo',\n    onClick: handlerA\n  }\n\n  const two = {\n    class: { bar: true },\n    onClick: handlerB\n  }\n\n  const merged = mergeProps(one, two)\n  /**\n   {\n     class: 'foo bar',\n     onClick: [handlerA, handlerB]\n   }\n   */\n  ```\n\n## cloneVNode() {#clonevnode}\n\n克隆一个 vnode。\n\n- **类型**\n\n  ```ts\n  function cloneVNode(vnode: VNode, extraProps?: object): VNode\n  ```\n\n- **详细信息**\n\n  返回一个克隆的 vnode，可在原有基础上添加一些额外的 prop。\n\n  Vnode 被认为是一旦创建就不能修改的，你不应该修改已创建的 vnode 的 prop，而应该附带不同的/额外的 prop 来克隆它。\n\n  Vnode 具有特殊的内部属性，因此克隆它并不像 object spread 一样简单。`cloneVNode()` 处理了大部分这样的内部逻辑。\n\n- **示例**\n\n  ```js\n  import { h, cloneVNode } from 'vue'\n\n  const original = h('div')\n  const cloned = cloneVNode(original, { id: 'foo' })\n  ```\n\n## isVNode() {#isvnode}\n\n判断一个值是否为 vnode 类型。\n\n- **类型**\n\n  ```ts\n  function isVNode(value: unknown): boolean\n  ```\n\n## resolveComponent() {#resolvecomponent}\n\n按名称手动解析已注册的组件。\n\n- **类型**\n\n  ```ts\n  function resolveComponent(name: string): Component | string\n  ```\n\n- **详细信息**\n\n  **备注：如果你可以直接引入组件就不需使用此方法。**\n\n  为了能从正确的组件上下文进行解析，`resolveComponent()` 必须在<span class=\"composition-api\"> `setup()` 或</span>渲染函数内调用。\n\n  如果组件未找到，会抛出一个运行时警告，并返回组件名字符串。\n\n- **示例**\n\n  <div class=\"composition-api\">\n\n  ```js\n  import { h, resolveComponent } from 'vue'\n\n  export default {\n    setup() {\n      const ButtonCounter = resolveComponent('ButtonCounter')\n\n      return () => {\n        return h(ButtonCounter)\n      }\n    }\n  }\n  ```\n\n  </div>\n  <div class=\"options-api\">\n\n  ```js\n  import { h, resolveComponent } from 'vue'\n\n  export default {\n    render() {\n      const ButtonCounter = resolveComponent('ButtonCounter')\n      return h(ButtonCounter)\n    }\n  }\n  ```\n\n  </div>\n\n- **参考**[指南 - 渲染函数 - 组件](/guide/extras/render-function#components)\n\n## resolveDirective() {#resolvedirective}\n\n按名称手动解析已注册的指令。\n\n- **类型**\n\n  ```ts\n  function resolveDirective(name: string): Directive | undefined\n  ```\n\n- **详细信息**\n\n  **备注：如果你可以直接引入指令就不需使用此方法。**\n\n  为了能从正确的组件上下文进行解析，`resolveDirective()` 必须在<span class=\"composition-api\"> `setup()` 或</span>渲染函数内调用。\n\n  如果指令没有找到，会抛出一个运行时警告，并返回 `undefined`。\n\n- **参考**[指南 - 渲染函数 - 自定义指令](/guide/extras/render-function#custom-directives)\n\n## withDirectives() {#withdirectives}\n\n用于给 vnode 增加自定义指令。\n\n- **类型**\n\n  ```ts\n  function withDirectives(\n    vnode: VNode,\n    directives: DirectiveArguments\n  ): VNode\n\n  // [Directive, value, argument, modifiers]\n  type DirectiveArguments = Array<\n    | [Directive]\n    | [Directive, any]\n    | [Directive, any, string]\n    | [Directive, any, string, DirectiveModifiers]\n  >\n  ```\n\n- **详细信息**\n\n  用自定义指令包装一个现有的 vnode。第二个参数是自定义指令数组。每个自定义指令也可以表示为 `[Directive, value, argument, modifiers]` 形式的数组。如果不需要，可以省略数组的尾元素。\n\n- **示例**\n\n  ```js\n  import { h, withDirectives } from 'vue'\n\n  // 一个自定义指令\n  const pin = {\n    mounted() {\n      /* ... */\n    },\n    updated() {\n      /* ... */\n    }\n  }\n\n  // <div v-pin:top.animate=\"200\"></div>\n  const vnode = withDirectives(h('div'), [\n    [pin, 200, 'top', { animate: true }]\n  ])\n  ```\n\n- **参考**[指南 - 渲染函数 - 自定义指令](/guide/extras/render-function#custom-directives)\n\n## withModifiers() {#withmodifiers}\n\n用于向事件处理函数添加内置 [`v-on` 修饰符](/guide/essentials/event-handling#event-modifiers)。\n\n- **类型**\n\n  ```ts\n  function withModifiers(fn: Function, modifiers: string[]): Function\n  ```\n\n- **示例**\n\n  ```js\n  import { h, withModifiers } from 'vue'\n\n  const vnode = h('button', {\n    // 等价于 v-on:click.stop.prevent\n    onClick: withModifiers(() => {\n      // ...\n    }, ['stop', 'prevent'])\n  })\n  ```\n\n- **参考**[指南 - 渲染函数 - 事件修饰符](/guide/extras/render-function#event-modifiers)",
          "questions": [
            "`h()` 函数的第一个参数可以是什么类型？",
            "`h()` 函数的第二个参数是什么？是否可选？",
            "`h()` 函数的第三个参数是什么？是否可选？",
            "如何创建一个组件的 vnode？",
            "`mergeProps()` 函数支持哪些特定的 props 参数的处理？",
            "为什么不应该修改已创建的 vnode 的 prop？",
            "`resolveComponent()` 函数必须在哪些地方调用？",
            "如果指令没有找到，`resolveDirective()` 函数会返回什么？",
            "`withDirectives()` 函数的第二个参数是什么类型？",
            "`withModifiers()` 函数用于向事件处理函数添加哪些内置修饰符？"
          ]
        }
      ]
    }
  ]
}
