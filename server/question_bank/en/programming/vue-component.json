{
  "question_type": "short",
  "designated_role": "examiner",
  "icon": "mdi-vuejs",
  "description": "A Vue component is a fundamental part of Vue.js for building user interfaces",
  "link": "https://vuejs.org/guide/components/registration.html",
  "total_question_count": 150,
  "files": [
    {
      "file_name": "async.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Async Components {#async-components}\n\n## Basic Usage {#basic-usage}\n\nIn large applications, we may need to divide the app into smaller chunks and only load a component from the server when it's needed. To make that possible, Vue has a [`defineAsyncComponent`](/api/general#defineasynccomponent) function:\n\n```js\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComp = defineAsyncComponent(() => {\n  return new Promise((resolve, reject) => {\n    // ...load component from server\n    resolve(/* loaded component */)\n  })\n})\n// ... use `AsyncComp` like a normal component\n```\n\nAs you can see, `defineAsyncComponent` accepts a loader function that returns a Promise. The Promise's `resolve` callback should be called when you have retrieved your component definition from the server. You can also call `reject(reason)` to indicate the load has failed.\n\n[ES module dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) also returns a Promise, so most of the time we will use it in combination with `defineAsyncComponent`. Bundlers like Vite and webpack also support the syntax (and will use it as bundle split points), so we can use it to import Vue SFCs:\n\n```js\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComp = defineAsyncComponent(() =>\n  import('./components/MyComponent.vue')\n)\n```\n\nThe resulting `AsyncComp` is a wrapper component that only calls the loader function when it is actually rendered on the page. In addition, it will pass along any props and slots to the inner component, so you can use the async wrapper to seamlessly replace the original component while achieving lazy loading.\n\nAs with normal components, async components can be [registered globally](/guide/components/registration#global-registration) using `app.component()`:\n\n```js\napp.component('MyComponent', defineAsyncComponent(() =>\n  import('./components/MyComponent.vue')\n))\n```\n\n<div class=\"options-api\">\n\nYou can also use `defineAsyncComponent` when [registering a component locally](/guide/components/registration#local-registration):\n\n```vue\n<script>\nimport { defineAsyncComponent } from 'vue'\n\nexport default {\n  components: {\n    AdminPage: defineAsyncComponent(() =>\n      import('./components/AdminPageComponent.vue')\n    )\n  }\n}\n</script>\n\n<template>\n  <AdminPage />\n</template>\n```\n\n</div>\n\n<div class=\"composition-api\">\n\nThey can also be defined directly inside their parent component:\n\n```vue\n<script setup>\nimport { defineAsyncComponent } from 'vue'\n\nconst AdminPage = defineAsyncComponent(() =>\n  import('./components/AdminPageComponent.vue')\n)\n</script>\n\n<template>\n  <AdminPage />\n</template>\n```\n\n</div>\n\n## Loading and Error States {#loading-and-error-states}\n\nAsynchronous operations inevitably involve loading and error states - `defineAsyncComponent()` supports handling these states via advanced options:\n\n```js\nconst AsyncComp = defineAsyncComponent({\n  // the loader function\n  loader: () => import('./Foo.vue'),\n\n  // A component to use while the async component is loading\n  loadingComponent: LoadingComponent,\n  // Delay before showing the loading component. Default: 200ms.\n  delay: 200,\n\n  // A component to use if the load fails\n  errorComponent: ErrorComponent,\n  // The error component will be displayed if a timeout is\n  // provided and exceeded. Default: Infinity.\n  timeout: 3000\n})\n```\n\nIf a loading component is provided, it will be displayed first while the inner component is being loaded. There is a default 200ms delay before the loading component is shown - this is because on fast networks, an instant loading state may get replaced too fast and end up looking like a flicker.\n\nIf an error component is provided, it will be displayed when the Promise returned by the loader function is rejected. You can also specify a timeout to show the error component when the request is taking too long.\n\n## Using with Suspense {#using-with-suspense}\n\nAsync components can be used with the `<Suspense>` built-in component. The interaction between `<Suspense>` and async components is documented in the [dedicated chapter for `<Suspense>`](/guide/built-ins/suspense).",
          "questions": [
            "What is the purpose of dividing an app into smaller chunks in large applications?",
            "What is the function used in Vue to make loading a component from the server possible?",
            "What does the loader function in `defineAsyncComponent` accept?",
            "When should the Promise's `resolve` callback be called in `defineAsyncComponent`?",
            "What is the purpose of calling `reject(reason)` in `defineAsyncComponent`?",
            "What is the benefit of using ES module dynamic import in combination with `defineAsyncComponent`?",
            "How does the resulting `AsyncComp` wrapper component work?",
            "Can async components be registered globally? If so, how?",
            "How can `defineAsyncComponent` be used when registering a component locally?",
            "How can async components be defined directly inside their parent component?"
          ]
        }
      ]
    },
    {
      "file_name": "props.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# Props {#props}\n\n> This page assumes you've already read the [Components Basics](/guide/essentials/component-basics). Read that first if you are new to components.\n\n<div class=\"options-api\">\n  <VueSchoolLink href=\"https://vueschool.io/lessons/vue-3-reusable-components-with-props\" title=\"Free Vue.js Props Lesson\"/>\n</div>\n\n## Props Declaration {#props-declaration}\n\nVue components require explicit props declaration so that Vue knows what external props passed to the component should be treated as fallthrough attributes (which will be discussed in [its dedicated section](/guide/components/attrs)).\n\n<div class=\"composition-api\">\n\nIn SFCs using `<script setup>`, props can be declared using the `defineProps()` macro:\n\n```vue\n<script setup>\nconst props = defineProps(['foo'])\n\nconsole.log(props.foo)\n</script>\n```\n\nIn non-`<script setup>` components, props are declared using the [`props`](/api/options-state#props) option:\n\n```js\nexport default {\n  props: ['foo'],\n  setup(props) {\n    // setup() receives props as the first argument.\n    console.log(props.foo)\n  }\n}\n```\n\nNotice the argument passed to `defineProps()` is the same as the value provided to the `props` options: the same props options API is shared between the two declaration styles.\n\n</div>\n\n<div class=\"options-api\">\n\nProps are declared using the [`props`](/api/options-state#props) option:\n\n```js\nexport default {\n  props: ['foo'],\n  created() {\n    // props are exposed on `this`\n    console.log(this.foo)\n  }\n}\n```\n\n</div>\n\nIn addition to declaring props using an array of strings, we can also use the object syntax:\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}\n```\n\n</div>\n<div class=\"composition-api\">\n\n```js\n// in <script setup>\ndefineProps({\n  title: String,\n  likes: Number\n})\n```\n\n```js\n// in non-<script setup>\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}\n```\n\n</div>\n\nFor each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.\n\nThis not only documents your component, but will also warn other developers using your component in the browser console if they pass the wrong type. We will discuss more details about [prop validation](#prop-validation) further down this page.\n\n<div class=\"options-api\">\n\nSee also: [Typing Component Props](/guide/typescript/options-api#typing-component-props) <sup class=\"vt-badge ts\" />\n\n</div>\n\n<div class=\"composition-api\">\n\nIf you are using TypeScript with `<script setup>`, it's also possible to declare props using pure type annotations:\n\n```vue\n<script setup lang=\"ts\">\ndefineProps<{\n  title?: string\n  likes?: number\n}>()\n</script>\n```\n\nMore details: [Typing Component Props](/guide/typescript/composition-api#typing-component-props) <sup class=\"vt-badge ts\" />\n\n</div>\n\n## Prop Passing Details {#prop-passing-details}\n\n### Prop Name Casing {#prop-name-casing}\n\nWe declare long prop names using camelCase because this avoids having to use quotes when using them as property keys, and allows us to reference them directly in template expressions because they are valid JavaScript identifiers:\n\n<div class=\"composition-api\">\n\n```js\ndefineProps({\n  greetingMessage: String\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    greetingMessage: String\n  }\n}\n```\n\n</div>\n\n```vue-html\n<span>{{ greetingMessage }}</span>\n```\n\nTechnically, you can also use camelCase when passing props to a child component (except in [in-DOM templates](/guide/essentials/component-basics#in-dom-template-parsing-caveats)). However, the convention is using kebab-case in all cases to align with HTML attributes:\n\n```vue-html\n<MyComponent greeting-message=\"hello\" />\n```\n\nWe use [PascalCase for component tags](/guide/components/registration#component-name-casing) when possible because it improves template readability by differentiating Vue components from native elements. However, there isn't as much practical benefit in using camelCase when passing props, so we choose to follow each language's conventions.\n\n### Static vs. Dynamic Props {#static-vs-dynamic-props}\n\nSo far, you've seen props passed as static values, like in:\n\n```vue-html\n<BlogPost title=\"My journey with Vue\" />\n```\n\nYou've also seen props assigned dynamically with `v-bind` or its `:` shortcut, such as in:\n\n```vue-html\n<!-- Dynamically assign the value of a variable -->\n<BlogPost :title=\"post.title\" />\n\n<!-- Dynamically assign the value of a complex expression -->\n<BlogPost :title=\"post.title + ' by ' + post.author.name\" />\n```\n\n### Passing Different Value Types {#passing-different-value-types}\n\nIn the two examples above, we happen to pass string values, but _any_ type of value can be passed to a prop.\n\n#### Number {#number}\n\n```vue-html\n<!-- Even though `42` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.       -->\n<BlogPost :likes=\"42\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :likes=\"post.likes\" />\n```\n\n#### Boolean {#boolean}\n\n```vue-html\n<!-- Including the prop with no value will imply `true`. -->\n<BlogPost is-published />\n\n<!-- Even though `false` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.          -->\n<BlogPost :is-published=\"false\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :is-published=\"post.isPublished\" />\n```\n\n#### Array {#array}\n\n```vue-html\n<!-- Even though the array is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.            -->\n<BlogPost :comment-ids=\"[234, 266, 273]\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :comment-ids=\"post.commentIds\" />\n```\n\n#### Object {#object}\n\n```vue-html\n<!-- Even though the object is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.             -->\n<BlogPost\n  :author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :author=\"post.author\" />\n```\n\n### Binding Multiple Properties Using an Object {#binding-multiple-properties-using-an-object}\n\nIf you want to pass all the properties of an object as props, you can use [`v-bind` without an argument](/guide/essentials/template-syntax#dynamically-binding-multiple-attributes) (`v-bind` instead of `:prop-name`). For example, given a `post` object:\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  data() {\n    return {\n      post: {\n        id: 1,\n        title: 'My Journey with Vue'\n      }\n    }\n  }\n}\n```\n\n</div>\n<div class=\"composition-api\">\n\n```js\nconst post = {\n  id: 1,\n  title: 'My Journey with Vue'\n}\n```\n\n</div>\n\nThe following template:\n\n```vue-html\n<BlogPost v-bind=\"post\" />\n```\n\nWill be equivalent to:\n\n```vue-html\n<BlogPost :id=\"post.id\" :title=\"post.title\" />\n```\n\n## One-Way Data Flow {#one-way-data-flow}\n\nAll props form a **one-way-down binding** between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.\n\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should **not** attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console:\n\n<div class=\"composition-api\">\n\n```js\nconst props = defineProps(['foo'])\n\n// ❌ warning, props are readonly!\nprops.foo = 'bar'\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: ['foo'],\n  created() {\n    // ❌ warning, props are readonly!\n    this.foo = 'bar'\n  }\n}\n```\n\n</div>\n\nThere are usually two cases where it's tempting to mutate a prop:\n\n1. **The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards.** In this case, it's best to define a local data property that uses the prop as its initial value:\n\n   <div class=\"composition-api\">\n\n   ```js\n   const props = defineProps(['initialCounter'])\n\n   // counter only uses props.initialCounter as the initial value;\n   // it is disconnected from future prop updates.\n   const counter = ref(props.initialCounter)\n   ```\n\n   </div>\n   <div class=\"options-api\">\n\n   ```js\n   export default {\n     props: ['initialCounter'],\n     data() {\n       return {\n         // counter only uses this.initialCounter as the initial value;\n         // it is disconnected from future prop updates.\n         counter: this.initialCounter\n       }\n     }\n   }\n   ```\n\n   </div>\n\n2. **The prop is passed in as a raw value that needs to be transformed.** In this case, it's best to define a computed property using the prop's value:\n\n   <div class=\"composition-api\">\n\n   ```js\n   const props = defineProps(['size'])\n\n   // computed property that auto-updates when the prop changes\n   const normalizedSize = computed(() => props.size.trim().toLowerCase())\n   ```\n\n   </div>\n   <div class=\"options-api\">\n\n   ```js\n   export default {\n     props: ['size'],\n     computed: {\n       // computed property that auto-updates when the prop changes\n       normalizedSize() {\n         return this.size.trim().toLowerCase()\n       }\n     }\n   }\n   ```\n\n   </div>\n\n### Mutating Object / Array Props {#mutating-object-array-props}\n\nWhen objects and arrays are passed as props, while the child component cannot mutate the prop binding, it **will** be able to mutate the object or array's nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations.\n\nThe main drawback of such mutations is that it allows the child component to affect parent state in a way that isn't obvious to the parent component, potentially making it more difficult to reason about the data flow in the future. As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design. In most cases, the child should [emit an event](/guide/components/events) to let the parent perform the mutation.",
          "questions": [
            "What is the purpose of explicit props declaration in Vue components?",
            "How can props be declared using the `defineProps()` macro in SFCs using `<script setup>`?",
            "How are props declared in non-`<script setup>` components?",
            "What is the difference between declaring props using an array of strings and using the object syntax?",
            "What is the key and value in the object declaration syntax for declaring props?",
            "What is the benefit of declaring props using the object syntax?",
            "What is the convention for naming props in Vue components?",
            "What is the one-way data flow in Vue components?",
            "Why should you not attempt to mutate a prop inside a child component?",
            "What is the drawback of mutating object/array props in Vue components?"
          ]
        },
        {
          "content": "## Prop Validation {#prop-validation}\n\nComponents can specify requirements for their props, such as the types you've already seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that is intended to be used by others.\n\nTo specify prop validations, you can provide an object with validation requirements to the <span class=\"composition-api\">`defineProps()` macro</span><span class=\"options-api\">`props` option</span>, instead of an array of strings. For example:\n\n<div class=\"composition-api\">\n\n```js\ndefineProps({\n  // Basic type check\n  //  (`null` and `undefined` values will allow any type)\n  propA: Number,\n  // Multiple possible types\n  propB: [String, Number],\n  // Required string\n  propC: {\n    type: String,\n    required: true\n  },\n  // Number with a default value\n  propD: {\n    type: Number,\n    default: 100\n  },\n  // Object with a default value\n  propE: {\n    type: Object,\n    // Object or array defaults must be returned from\n    // a factory function. The function receives the raw\n    // props received by the component as the argument.\n    default(rawProps) {\n      return { message: 'hello' }\n    }\n  },\n  // Custom validator function\n  propF: {\n    validator(value) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // Function with a default value\n  propG: {\n    type: Function,\n    // Unlike object or array default, this is not a factory \n    // function - this is a function to serve as a default value\n    default() {\n      return 'Default function'\n    }\n  }\n})\n```\n\n:::tip\nCode inside the `defineProps()` argument **cannot access other variables declared in `<script setup>`**, because the entire expression is moved to an outer function scope when compiled.\n:::\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    // Basic type check\n    //  (`null` and `undefined` values will allow any type)\n    propA: Number,\n    // Multiple possible types\n    propB: [String, Number],\n    // Required string\n    propC: {\n      type: String,\n      required: true\n    },\n    // Number with a default value\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // Object with a default value\n    propE: {\n      type: Object,\n      // Object or array defaults must be returned from\n      // a factory function. The function receives the raw\n      // props received by the component as the argument.\n      default(rawProps) {\n        return { message: 'hello' }\n      }\n    },\n    // Custom validator function\n    propF: {\n      validator(value) {\n        // The value must match one of these strings\n        return ['success', 'warning', 'danger'].includes(value)\n      }\n    },\n    // Function with a default value\n    propG: {\n      type: Function,\n      // Unlike object or array default, this is not a factory \n      // function - this is a function to serve as a default value\n      default() {\n        return 'Default function'\n      }\n    }\n  }\n}\n```\n\n</div>\n\nAdditional details:\n\n- All props are optional by default, unless `required: true` is specified.\n\n- An absent optional prop other than `Boolean` will have `undefined` value.\n\n- The `Boolean` absent props will be cast to `false`. You can change this by setting a `default` for it — i.e.: `default: undefined` to behave as a non-Boolean prop.\n\n- If a `default` value is specified, it will be used if the resolved prop value is `undefined` - this includes both when the prop is absent, or an explicit `undefined` value is passed.\n\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\n\n<div class=\"composition-api\">\n\nIf using [Type-based props declarations](/api/sfc-script-setup#type-only-props-emit-declarations) <sup class=\"vt-badge ts\" />, Vue will try its best to compile the type annotations into equivalent runtime prop declarations. For example, `defineProps<{ msg: string }>` will be compiled into `{ msg: { type: String, required: true }}`.\n\n</div>\n<div class=\"options-api\">\n\n::: tip Note\nNote that props are validated **before** a component instance is created, so instance properties (e.g. `data`, `computed`, etc.) will not be available inside `default` or `validator` functions.\n:::\n\n</div>\n\n### Runtime Type Checks {#runtime-type-checks}\n\nThe `type` can be one of the following native constructors:\n\n- `String`\n- `Number`\n- `Boolean`\n- `Array`\n- `Object`\n- `Date`\n- `Function`\n- `Symbol`\n\nIn addition, `type` can also be a custom class or constructor function and the assertion will be made with an `instanceof` check. For example, given the following class:\n\n```js\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n  }\n}\n```\n\nYou could use it as a prop's type:\n\n<div class=\"composition-api\">\n\n```js\ndefineProps({\n  author: Person\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    author: Person\n  }\n}\n```\n\n</div>\n\nVue will use `instanceof Person` to validate whether the value of the `author` prop is indeed an instance of the `Person` class.\n\n## Boolean Casting {#boolean-casting}\n\nProps with `Boolean` type have special casting rules to mimic the behavior of native boolean attributes. Given a `<MyComponent>` with the following declaration:\n\n<div class=\"composition-api\">\n\n```js\ndefineProps({\n  disabled: Boolean\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    disabled: Boolean\n  }\n}\n```\n\n</div>\n\nThe component can be used like this:\n\n```vue-html\n<!-- equivalent of passing :disabled=\"true\" -->\n<MyComponent disabled />\n\n<!-- equivalent of passing :disabled=\"false\" -->\n<MyComponent />\n```\n\nWhen a prop is declared to allow multiple types, the casting rules for `Boolean` will also be applied. However, there is an edge when both `String` and `Boolean` are allowed - the Boolean casting rule only applies if Boolean appears before String:\n\n<div class=\"composition-api\">\n\n```js\n// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, Number]\n})\n  \n// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, String]\n})\n  \n// disabled will be casted to true\ndefineProps({\n  disabled: [Number, Boolean]\n})\n  \n// disabled will be parsed as an empty string (disabled=\"\")\ndefineProps({\n  disabled: [String, Boolean]\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Boolean, Number]\n  }\n}\n  \n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Boolean, String]\n  }\n}\n  \n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Number, Boolean]\n  }\n}\n  \n// disabled will be parsed as an empty string (disabled=\"\")\nexport default {\n  props: {\n    disabled: [String, Boolean]\n  }\n}\n```\n\n</div>",
          "questions": [
            "What is prop validation in Vue components?",
            "How can you specify prop validations in Vue components?",
            "Can you provide an object with validation requirements to the `props` option in Vue components?",
            "What are the different types of prop validations that can be specified in Vue components?",
            "What happens when a prop validation fails in Vue components?",
            "What are the default values for absent optional props in Vue components?",
            "How can you change the default value for absent Boolean props in Vue components?",
            "When are props validated in Vue components?",
            "What are the native constructors that can be used as prop types in Vue components?",
            "Can custom classes or constructor functions be used as prop types in Vue components?"
          ]
        }
      ]
    },
    {
      "file_name": "provide-inject.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# Provide / Inject {#provide-inject}\n\n> This page assumes you've already read the [Components Basics](/guide/essentials/component-basics). Read that first if you are new to components.\n\n## Prop Drilling {#prop-drilling}\n\nUsually, when we need to pass data from the parent to a child component, we use [props](/guide/components/props). However, imagine the case where we have a large component tree, and a deeply nested component needs something from a distant ancestor component. With only props, we would have to pass the same prop across the entire parent chain:\n\n![prop drilling diagram](./images/prop-drilling.png)\n\n<!-- https://www.figma.com/file/yNDTtReM2xVgjcGVRzChss/prop-drilling -->\n\nNotice although the `<Footer>` component may not care about these props at all, it still needs to declare and pass them along just so `<DeepChild>` can access them. If there is a longer parent chain, more components would be affected along the way. This is called \"props drilling\" and definitely isn't fun to deal with.\n\nWe can solve props drilling with `provide` and `inject`. A parent component can serve as a **dependency provider** for all its descendants. Any component in the descendant tree, regardless of how deep it is, can **inject** dependencies provided by components up in its parent chain.\n\n![Provide/inject scheme](./images/provide-inject.png)\n\n<!-- https://www.figma.com/file/PbTJ9oXis5KUawEOWdy2cE/provide-inject -->\n\n## Provide {#provide}\n\n<div class=\"composition-api\">\n\nTo provide data to a component's descendants, use the [`provide()`](/api/composition-api-dependency-injection#provide) function:\n\n```vue\n<script setup>\nimport { provide } from 'vue'\n\nprovide(/* key */ 'message', /* value */ 'hello!')\n</script>\n```\n\nIf not using `<script setup>`, make sure `provide()` is called synchronously inside `setup()`:\n\n```js\nimport { provide } from 'vue'\n\nexport default {\n  setup() {\n    provide(/* key */ 'message', /* value */ 'hello!')\n  }\n}\n```\n\nThe `provide()` function accepts two arguments. The first argument is called the **injection key**, which can be a string or a `Symbol`. The injection key is used by descendant components to lookup the desired value to inject. A single component can call `provide()` multiple times with different injection keys to provide different values.\n\nThe second argument is the provided value. The value can be of any type, including reactive state such as refs:\n\n```js\nimport { ref, provide } from 'vue'\n\nconst count = ref(0)\nprovide('key', count)\n```\n\nProviding reactive values allows the descendant components using the provided value to establish a reactive connection to the provider component.\n\n</div>\n\n<div class=\"options-api\">\n\nTo provide data to a component's descendants, use the [`provide`](/api/options-composition#provide) option:\n\n```js\nexport default {\n  provide: {\n    message: 'hello!'\n  }\n}\n```\n\nFor each property in the `provide` object, the key is used by child components to locate the correct value to inject, while the value is what ends up being injected.\n\nIf we need to provide per-instance state, for example data declared via the `data()`, then `provide` must use a function value:\n\n```js{7-12}\nexport default {\n  data() {\n    return {\n      message: 'hello!'\n    }\n  },\n  provide() {\n    // use function syntax so that we can access `this`\n    return {\n      message: this.message\n    }\n  }\n}\n```\n\nHowever, do note this does **not** make the injection reactive. We will discuss [making injections reactive](#working-with-reactivity) below.\n\n</div>\n\n## App-level Provide {#app-level-provide}\n\nIn addition to providing data in a component, we can also provide at the app level:\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n\napp.provide(/* key */ 'message', /* value */ 'hello!')\n```\n\nApp-level provides are available to all components rendered in the app. This is especially useful when writing [plugins](/guide/reusability/plugins), as plugins typically wouldn't be able to provide values using components.\n\n## Inject {#inject}\n\n<div class=\"composition-api\">\n\nTo inject data provided by an ancestor component, use the [`inject()`](/api/composition-api-dependency-injection#inject) function:\n\n```vue\n<script setup>\nimport { inject } from 'vue'\n\nconst message = inject('message')\n</script>\n```\n\nIf the provided value is a ref, it will be injected as-is and will **not** be automatically unwrapped. This allows the injector component to retain the reactivity connection to the provider component.\n\n[Full provide + inject Example with Reactivity](https://play.vuejs.org/#eNqFUUFugzAQ/MrKF1IpxfeIVKp66Kk/8MWFDXYFtmUbpArx967BhURRU9/WOzO7MzuxV+fKcUB2YlWovXYRAsbBvQije2d9hAk8Xo7gvB11gzDDxdseCuIUG+ZN6a7JjZIvVRIlgDCcw+d3pmvTglz1okJ499I0C3qB1dJQT9YRooVaSdNiACWdQ5OICj2WwtTWhAg9hiBbhHNSOxQKu84WT8LkNQ9FBhTHXyg1K75aJHNUROxdJyNSBVBp44YI43NvG+zOgmWWYGt7dcipqPhGZEe2ef07wN3lltD+lWN6tNkV/37+rdKjK2rzhRTt7f3u41xhe37/xJZGAL2PLECXa9NKdD/a6QTTtGnP88LgiXJtYv4BaLHhvg==)\n\nAgain, if not using `<script setup>`, `inject()` should only be called synchronously inside `setup()`:\n\n```js\nimport { inject } from 'vue'\n\nexport default {\n  setup() {\n    const message = inject('message')\n    return { message }\n  }\n}\n```\n\n</div>\n\n<div class=\"options-api\">\n\nTo inject data provided by an ancestor component, use the [`inject`](/api/options-composition#inject) option:\n\n```js\nexport default {\n  inject: ['message'],\n  created() {\n    console.log(this.message) // injected value\n  }\n}\n```\n\nInjections are resolved **before** the component's own state, so you can access injected properties in `data()`:\n\n```js\nexport default {\n  inject: ['message'],\n  data() {\n    return {\n      // initial data based on injected value\n      fullMessage: this.message\n    }\n  }\n}\n```\n\n[Full provide + inject example](https://play.vuejs.org/#eNqNkcFqwzAQRH9l0EUthOhuRKH00FO/oO7B2JtERZaEvA4F43+vZCdOTAIJCImRdpi32kG8h7A99iQKobs6msBvpTNt8JHxcTC2wS76FnKrJpVLZelKR39TSUO7qreMoXRA7ZPPkeOuwHByj5v8EqI/moZeXudCIBL30Z0V0FLXVXsqIA9krU8R+XbMR9rS0mqhS4KpDbZiSgrQc5JKQqvlRWzEQnyvuc9YuWbd4eXq+TZn0IvzOeKr8FvsNcaK/R6Ocb9Uc4FvefpE+fMwP0wH8DU7wB77nIo6x6a2hvNEME5D0CpbrjnHf+8excI=)\n\n### Injection Aliasing \\* {#injection-aliasing}\n\nWhen using the array syntax for `inject`, the injected properties are exposed on the component instance using the same key. In the example above, the property was provided under the key `\"message\"`, and injected as `this.message`. The local key is the same as the injection key.\n\nIf we want to inject the property using a different local key, we need to use the object syntax for the `inject` option:\n\n```js\nexport default {\n  inject: {\n    /* local key */ localMessage: {\n      from: /* injection key */ 'message'\n    }\n  }\n}\n```\n\nHere, the component will locate a property provided with the key `\"message\"`, and then expose it as `this.localMessage`.\n\n</div>\n\n### Injection Default Values {#injection-default-values}\n\nBy default, `inject` assumes that the injected key is provided somewhere in the parent chain. In the case where the key is not provided, there will be a runtime warning.\n\nIf we want to make an injected property work with optional providers, we need to declare a default value, similar to props:\n\n<div class=\"composition-api\">\n\n```js\n// `value` will be \"default value\"\n// if no data matching \"message\" was provided\nconst value = inject('message', 'default value')\n```\n\nIn some cases, the default value may need to be created by calling a function or instantiating a new class. To avoid unnecessary computation or side effects in case the optional value is not used, we can use a factory function for creating the default value:\n\n```js\nconst value = inject('key', () => new ExpensiveClass(), true)\n```\n\nThe third parameter indicates the default value should be treated as a factory function.\n\n</div>\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  // object syntax is required\n  // when declaring default values for injections\n  inject: {\n    message: {\n      from: 'message', // this is optional if using the same key for injection\n      default: 'default value'\n    },\n    user: {\n      // use a factory function for non-primitive values that are expensive\n      // to create, or ones that should be unique per component instance.\n      default: () => ({ name: 'John' })\n    }\n  }\n}\n```\n\n</div>",
          "questions": [
            "What is prop drilling and why is it not ideal?",
            "How can we solve prop drilling using provide and inject?",
            "What is the injection key used for in provide and inject?",
            "Can a single component call provide() multiple times with different injection keys?",
            "What types of values can be provided using provide()?",
            "How can we provide data at the app level using provide()?",
            "What is the purpose of inject()?",
            "How can we use inject() to access a value provided by an ancestor component?",
            "What happens if the injected key is not provided somewhere in the parent chain?",
            "How can we declare a default value for an injected property using inject()?"
          ]
        },
        {
          "content": "## Working with Reactivity {#working-with-reactivity}\n\n<div class=\"composition-api\">\n\nWhen using reactive provide / inject values, **it is recommended to keep any mutations to reactive state inside of the _provider_ whenever possible**. This ensures that the provided state and its possible mutations are co-located in the same component, making it easier to maintain in the future.\n\nThere may be times when we need to update the data from an injector component. In such cases, we recommend providing a function that is responsible for mutating the state:\n\n```vue{7-9,13}\n<!-- inside provider component -->\n<script setup>\nimport { provide, ref } from 'vue'\n\nconst location = ref('North Pole')\n\nfunction updateLocation() {\n  location.value = 'South Pole'\n}\n\nprovide('location', {\n  location,\n  updateLocation\n})\n</script>\n```\n\n```vue{5}\n<!-- in injector component -->\n<script setup>\nimport { inject } from 'vue'\n\nconst { location, updateLocation } = inject('location')\n</script>\n\n<template>\n  <button @click=\"updateLocation\">{{ location }}</button>\n</template>\n```\n\nFinally, you can wrap the provided value with [`readonly()`](/api/reactivity-core#readonly) if you want to ensure that the data passed through `provide` cannot be mutated by the injector component.\n\n```vue\n<script setup>\nimport { ref, provide, readonly } from 'vue'\n\nconst count = ref(0)\nprovide('read-only-count', readonly(count))\n</script>\n```\n\n</div>\n\n<div class=\"options-api\">\n\nIn order to make injections reactively linked to the provider, we need to provide a computed property using the [computed()](/api/reactivity-core#computed) function:\n\n```js{10}\nimport { computed } from 'vue'\n\nexport default {\n  data() {\n    return {\n      message: 'hello!'\n    }\n  },\n  provide() {\n    return {\n      // explicitly provide a computed property\n      message: computed(() => this.message)\n    }\n  }\n}\n```\n\n[Full provide + inject Example with Reactivity](https://play.vuejs.org/#eNqNUctqwzAQ/JVFFyeQxnfjBEoPPfULqh6EtYlV9EKWTcH43ytZtmPTQA0CsdqZ2dlRT16tPXctkoKUTeWE9VeqhbLGeXirheRwc0ZBds7HKkKzBdBDZZRtPXIYJlzqU40/I4LjjbUyIKmGEWw0at8UgZrUh1PscObZ4ZhQAA596/RcAShsGnbHArIapTRBP74O8Up060wnOO5QmP0eAvZyBV+L5jw1j2tZqsMp8yWRUHhUVjKPoQIohQ460L0ow1FeKJlEKEnttFweijJfiORElhCf5f3umObb0B9PU/I7kk17PJj7FloN/2t7a2Pj/Zkdob+x8gV8ZlMs2de/8+14AXwkBngD9zgVqjg2rNXPvwjD+EdlHilrn8MvtvD1+Q==)\n\nThe `computed()` function is typically used in Composition API components, but can also be used to complement certain use cases in Options API. You can learn more about its usage by reading the [Reactivity Fundamentals](/guide/essentials/reactivity-fundamentals) and [Computed Properties](/guide/essentials/computed) with the API Preference set to Composition API.\n\n:::warning Temporary Config Required\nThe above usage requires setting `app.config.unwrapInjectedRef = true` to make injections automatically unwrap computed refs. This will become the default behavior in Vue 3.3 and this config is introduced temporarily to avoid breakage. It will no longer be required after 3.3.\n:::\n\n</div>\n\n## Working with Symbol Keys {#working-with-symbol-keys}\n\nSo far, we have been using string injection keys in the examples. If you are working in a large application with many dependency providers, or you are authoring components that are going to be used by other developers, it is best to use Symbol injection keys to avoid potential collisions.\n\nIt's recommended to export the Symbols in a dedicated file:\n\n```js\n// keys.js\nexport const myInjectionKey = Symbol()\n```\n\n<div class=\"composition-api\">\n\n```js\n// in provider component\nimport { provide } from 'vue'\nimport { myInjectionKey } from './keys.js'\n\nprovide(myInjectionKey, {\n  /* data to provide */\n})\n```\n\n```js\n// in injector component\nimport { inject } from 'vue'\nimport { myInjectionKey } from './keys.js'\n\nconst injected = inject(myInjectionKey)\n```\n\nSee also: [Typing Provide / Inject](/guide/typescript/composition-api#typing-provide-inject) <sup class=\"vt-badge ts\" />\n\n</div>\n\n<div class=\"options-api\">\n\n```js\n// in provider component\nimport { myInjectionKey } from './keys.js'\n\nexport default {\n  provide() {\n    return {\n      [myInjectionKey]: {\n        /* data to provide */\n      }\n    }\n  }\n}\n```\n\n```js\n// in injector component\nimport { myInjectionKey } from './keys.js'\n\nexport default {\n  inject: {\n    injected: { from: myInjectionKey }\n  }\n}\n```\n\n</div>",
          "questions": [
            "What is the recommended approach for keeping mutations to reactive state when using reactive provide/inject values?",
            "Why is it recommended to keep mutations to reactive state inside of the provider?",
            "What is the purpose of providing a function responsible for mutating the state?",
            "How can you update the data from an injector component?",
            "What is the purpose of wrapping the provided value with `readonly()`?",
            "How can you make injections reactively linked to the provider?",
            "What is the `computed()` function used for in Composition API components?",
            "Can the `computed()` function be used in Options API components?",
            "Why is it best to use Symbol injection keys instead of string injection keys in large applications with many dependency providers?",
            "How can you avoid potential collisions when using Symbol injection keys?"
          ]
        }
      ]
    },
    {
      "file_name": "attrs.md",
      "question_count": 10,
      "documents": [
        {
          "content": "---\noutline: deep\n---\n\n# Fallthrough Attributes {#fallthrough-attributes}\n\n> This page assumes you've already read the [Components Basics](/guide/essentials/component-basics). Read that first if you are new to components.\n\n## Attribute Inheritance {#attribute-inheritance}\n\nA \"fallthrough attribute\" is an attribute or `v-on` event listener that is passed to a component, but is not explicitly declared in the receiving component's [props](./props) or [emits](./events#declaring-emitted-events). Common examples of this include `class`, `style`, and `id` attributes.\n\nWhen a component renders a single root element, fallthrough attributes will be automatically added to the root element's attributes. For example, given a `<MyButton>` component with the following template:\n\n```vue-html\n<!-- template of <MyButton> -->\n<button>click me</button>\n```\n\nAnd a parent using this component with:\n\n```vue-html\n<MyButton class=\"large\" />\n```\n\nThe final rendered DOM would be:\n\n```html\n<button class=\"large\">click me</button>\n```\n\nHere, `<MyButton>` did not declare `class` as an accepted prop. Therefore, `class` is treated as a fallthrough attribute and automatically added to `<MyButton>`'s root element.\n\n### `class` and `style` Merging {#class-and-style-merging}\n\nIf the child component's root element already has existing `class` or `style` attributes, it will be merged with the `class` and `style` values that are inherited from the parent. Suppose we change the template of `<MyButton>` in the previous example to:\n\n```vue-html\n<!-- template of <MyButton> -->\n<button class=\"btn\">click me</button>\n```\n\nThen the final rendered DOM would now become:\n\n```html\n<button class=\"btn large\">click me</button>\n```\n\n### `v-on` Listener Inheritance {#v-on-listener-inheritance}\n\nThe same rule applies to `v-on` event listeners:\n\n```vue-html\n<MyButton @click=\"onClick\" />\n```\n\nThe `click` listener will be added to the root element of `<MyButton>`, i.e. the native `<button>` element. When the native `<button>` is clicked, it will trigger the `onClick` method of the parent component. If the native `<button>` already has a `click` listener bound with `v-on`, then both listeners will trigger.\n\n### Nested Component Inheritance {#nested-component-inheritance}\n\nIf a component renders another component as its root node, for example, we refactored `<MyButton>` to render a `<BaseButton>` as its root:\n\n```vue-html\n<!-- template of <MyButton/> that simply renders another component -->\n<BaseButton />\n```\n\nThen the fallthrough attributes received by `<MyButton>` will be automatically forwarded to `<BaseButton>`.\n\nNote that:\n\n1. Forwarded attributes do not include any attributes that are declared as props, or `v-on` listeners of declared events by `<MyButton>` - in other words, the declared props and listeners have been \"consumed\" by `<MyButton>`.\n\n2. Forwarded attributes may be accepted as props by `<BaseButton>`, if declared by it.\n\n## Disabling Attribute Inheritance {#disabling-attribute-inheritance}\n\nIf you do **not** want a component to automatically inherit attributes, you can set `inheritAttrs: false` in the component's options.\n\n<div class=\"composition-api\">\n\n Since 3.3 you can also use [`defineOptions`](/api/sfc-script-setup#defineoptions) directly in `<script setup>`:\n\n```vue\n<script setup>\ndefineOptions({\n  inheritAttrs: false\n})\n// ...setup logic\n</script>\n```\n\n</div>\n\nThe common scenario for disabling attribute inheritance is when attributes need to be applied to other elements besides the root node. By setting the `inheritAttrs` option to `false`, you can take full control over where the fallthrough attributes should be applied.\n\nThese fallthrough attributes can be accessed directly in template expressions as `$attrs`:\n\n```vue-html\n<span>Fallthrough attributes: {{ $attrs }}</span>\n```\n\nThe `$attrs` object includes all attributes that are not declared by the component's `props` or `emits` options (e.g., `class`, `style`, `v-on` listeners, etc.).\n\nSome notes:\n\n- Unlike props, fallthrough attributes preserve their original casing in JavaScript, so an attribute like `foo-bar` needs to be accessed as `$attrs['foo-bar']`.\n\n- A `v-on` event listener like `@click` will be exposed on the object as a function under `$attrs.onClick`.\n\nUsing our `<MyButton>` component example from the [previous section](#attribute-inheritance) - sometimes we may need to wrap the actual `<button>` element with an extra `<div>` for styling purposes:\n\n```vue-html\n<div class=\"btn-wrapper\">\n  <button class=\"btn\">click me</button>\n</div>\n```\n\nWe want all fallthrough attributes like `class` and `v-on` listeners to be applied to the inner `<button>`, not the outer `<div>`. We can achieve this with `inheritAttrs: false` and `v-bind=\"$attrs\"`:\n\n```vue-html{2}\n<div class=\"btn-wrapper\">\n  <button class=\"btn\" v-bind=\"$attrs\">click me</button>\n</div>\n```\n\nRemember that [`v-bind` without an argument](/guide/essentials/template-syntax#dynamically-binding-multiple-attributes) binds all the properties of an object as attributes of the target element.\n\n## Attribute Inheritance on Multiple Root Nodes {#attribute-inheritance-on-multiple-root-nodes}\n\nUnlike components with a single root node, components with multiple root nodes do not have an automatic attribute fallthrough behavior. If `$attrs` are not bound explicitly, a runtime warning will be issued.\n\n```vue-html\n<CustomLayout id=\"custom-layout\" @click=\"changeValue\" />\n```\n\nIf `<CustomLayout>` has the following multi-root template, there will be a warning because Vue cannot be sure where to apply the fallthrough attributes:\n\n```vue-html\n<header>...</header>\n<main>...</main>\n<footer>...</footer>\n```\n\nThe warning will be suppressed if `$attrs` is explicitly bound:\n\n```vue-html{2}\n<header>...</header>\n<main v-bind=\"$attrs\">...</main>\n<footer>...</footer>\n```\n\n## Accessing Fallthrough Attributes in JavaScript {#accessing-fallthrough-attributes-in-javascript}\n\n<div class=\"composition-api\">\n\nIf needed, you can access a component's fallthrough attributes in `<script setup>` using the `useAttrs()` API:\n\n```vue\n<script setup>\nimport { useAttrs } from 'vue'\n\nconst attrs = useAttrs()\n</script>\n```\n\nIf not using `<script setup>`, `attrs` will be exposed as a property of the `setup()` context:\n\n```js\nexport default {\n  setup(props, ctx) {\n    // fallthrough attributes are exposed as ctx.attrs\n    console.log(ctx.attrs)\n  }\n}\n```\n\nNote that although the `attrs` object here always reflects the latest fallthrough attributes, it isn't reactive (for performance reasons). You cannot use watchers to observe its changes. If you need reactivity, use a prop. Alternatively, you can use `onUpdated()` to perform side effects with the latest `attrs` on each update.\n\n</div>\n\n<div class=\"options-api\">\n\nIf needed, you can access a component's fallthrough attributes via the `$attrs` instance property:\n\n```js\nexport default {\n  created() {\n    console.log(this.$attrs)\n  }\n}\n```\n\n</div>",
          "questions": [
            "What is a fallthrough attribute in Vue components?",
            "Which attributes are commonly fallthrough attributes?",
            "What happens when a fallthrough attribute is passed to a component that does not declare it as a prop or emit?",
            "What is the final rendered DOM when a component with a single root element receives a fallthrough attribute?",
            "How are `class` and `style` attributes merged when a component receives fallthrough attributes?",
            "What happens when a `v-on` event listener is passed as a fallthrough attribute to a component?",
            "What happens when a component renders another component as its root node and receives fallthrough attributes?",
            "How can you disable attribute inheritance in a component?",
            "How can you access fallthrough attributes in a component's JavaScript code?",
            "What happens when a component with multiple root nodes receives fallthrough attributes and `$attrs` is not explicitly bound?"
          ]
        }
      ]
    },
    {
      "file_name": "slots.md",
      "question_count": 40,
      "documents": [
        {
          "content": "# Slots {#slots}\n\n> This page assumes you've already read the [Components Basics](/guide/essentials/component-basics). Read that first if you are new to components.\n\n<VueSchoolLink href=\"https://vueschool.io/lessons/vue-3-component-slots\" title=\"Free Vue.js Slots Lesson\"/>\n\n## Slot Content and Outlet {#slot-content-and-outlet}\n\nWe have learned that components can accept props, which can be JavaScript values of any type. But how about template content? In some cases, we may want to pass a template fragment to a child component, and let the child component render the fragment within its own template.\n\nFor example, we may have a `<FancyButton>` component that supports usage like this:\n\n```vue-html{2}\n<FancyButton>\n  Click me! <!-- slot content -->\n</FancyButton>\n```\n\nThe template of `<FancyButton>` looks like this:\n\n```vue-html{2}\n<button class=\"fancy-btn\">\n  <slot></slot> <!-- slot outlet -->\n</button>\n```\n\nThe `<slot>` element is a **slot outlet** that indicates where the parent-provided **slot content** should be rendered.\n\n![slot diagram](./images/slots.png)\n\n<!-- https://www.figma.com/file/LjKTYVL97Ck6TEmBbstavX/slot -->\n\nAnd the final rendered DOM:\n\n```html\n<button class=\"fancy-btn\">Click me!</button>\n```\n\n<div class=\"composition-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNpdUdlqAyEU/ZVbQ0kLMdNsXabTQFvoV8yLcRkkjopLSQj596oTwqRvnuM9y9UT+rR2/hs5qlHjqZM2gOch2m2rZW+NC/BDND1+xRCMBuFMD9N5NeKyeNrqphrUSZdA4L1VJPCEAJrRdCEAvpWke+g5NHcYg1cmADU6cB0A4zzThmYckqimupqiGfpXILe/zdwNhaki3n+0SOR5vAu6ReU++efUajtqYGJQ/FIg5w8Wt9FlOx+OKh/nV1c4ZVNqlHE1TIQQ7xnvCN13zkTNalBSc+Jw5wiTac2H1WLDeDeDyXrJVm9LWG7uE3hev3AhHge1cYwnO200L4QljEnd1bCxB1g82UNhe+I6qQs5kuGcE30NrxeaRudzOWtkemeXuHP5tLIKOv8BN+mw3w==)\n\n</div>\n<div class=\"options-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNpdUdtOwzAM/RUThAbSurIbl1ImARJf0ZesSapoqROlKdo07d9x0jF1SHmIT+xzcY7sw7nZTy9Zwcqu9tqFTYW6ddYH+OZYHz77ECyC8raFySwfYXFsUiFAhXKfBoRUvDcBjhGtLbGgxNAVcLziOlVIp8wvelQE2TrDg6QKoBx1JwDgy+h6B62E8ibLoDM2kAAGoocsiz1VKMfmCCrzCymbsn/GY95rze1grja8694rpmJ/tg1YsfRO/FE134wc2D4YeTYQ9QeKa+mUrgsHE6+zC+vfjoz1Bdwqpd5iveX1rvG2R1GA0Si5zxrPhaaY98v5WshmCrerhVi+LmCxvqPiafUslXoYpq0XkuiQ1p4Ax4XQ2BSwdnuYP7p9QlvuG40JHI1lUaenv3o5w3Xvu2jOWU179oQNn5aisNMvLBvDOg==)\n\n</div>\n\nWith slots, the `<FancyButton>` is responsible for rendering the outer `<button>` (and its fancy styling), while the inner content is provided by the parent component.\n\nAnother way to understand slots is by comparing them to JavaScript functions:\n\n```js\n// parent component passing slot content\nFancyButton('Click me!')\n\n// FancyButton renders slot content in its own template\nfunction FancyButton(slotContent) {\n  return `<button class=\"fancy-btn\">\n      ${slotContent}\n    </button>`\n}\n```\n\nSlot content is not just limited to text. It can be any valid template content. For example, we can pass in multiple elements, or even other components:\n\n```vue-html\n<FancyButton>\n  <span style=\"color:red\">Click me!</span>\n  <AwesomeIcon name=\"plus\" />\n</FancyButton>\n```\n\n<div class=\"composition-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNp1UmtOwkAQvspQYtCEgrx81EqCJibeoX+W7bRZaHc3+1AI4QyewH8ewvN4Aa/gbgtNIfFf5+vMfI/ZXbCQcvBmMYiCWFPFpAGNxsp5wlkphTLwQjjdPlljBIdMiRJ6g2EL88O9pnnxjlqU+EpbzS3s0BwPaypH4gqDpSyIQVcBxK3VFQDwXDC6hhJdlZi4zf3fRKwl4aDNtsDHJKCiECqiW8KTYH5c1gEnwnUdJ9rCh/XeM6Z42AgN+sFZAj6+Ux/LOjFaEK2diMz3h0vjNfj/zokuhPFU3lTdfcpShVOZcJ+DZgHs/HxtCrpZlj34eknoOlfC8jSCgnEkKswVSRlyczkZzVLM+9CdjtPJ/RjGswtX3ExvMcuu6mmhUnTruOBYAZKkKeN5BDO5gdG13FRoSVTOeAW2xkLPY3UEdweYWqW9OCkYN6gctq9uXllx2Z09CJ9dJwzBascI7nBYihWDldUGMqEgdTVIq6TQqCEMfUpNSD+fX7/fH+3b7P8AdGP6wA==)\n\n</div>\n<div class=\"options-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNptUltu2zAQvMpGQZEWsOzGiftQ1QBpgQK9g35oaikwkUiCj9aGkTPkBPnLIXKeXCBXyJKKBdoIoA/tYGd3doa74tqY+b+ARVXUjltp/FWj5GC09fCHKb79FbzXCoTVA5zNFxkWaWdT8/V/dHrAvzxrzrC3ZoBG4SYRWhQs9B52EeWapihU3lWwyxfPDgbfNYq+ejEppcLjYHrmkSqAOqMmAOB3L/ktDEhV4+v8gMR/l1M7wxQ4v+3xZ1Nw3Wtb8S1TTXG1H3cCJIO69oxc5mLUcrSrXkxSi1lxZGT0//CS9Wg875lzJELE/nLto4bko69dr31cFc8auw+3JHvSEfQ7nwbsHY9HwakQ4kes14zfdlYH1VbQS4XMlp1lraRMPl6cr1rsZnB6uWwvvi9hufpAxZfLryjEp5GtbYs0TlGICTCsbaXqKliZDZx/NpuEDsx2UiUwo5VxT6Dkv73BPFgXxRktlUdL2Jh6OoW8O3pX0buTsoTgaCNQcDjoGwk3wXkQ2tJLGzSYYI126KAso0uTSc8Pjy9P93k2d6+NyRKa)\n\n</div>\n\nBy using slots, our `<FancyButton>` is more flexible and reusable. We can now use it in different places with different inner content, but all with the same fancy styling.\n\nVue components' slot mechanism is inspired by the [native Web Component `<slot>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot), but with additional capabilities that we will see later.\n\n## Render Scope {#render-scope}\n\nSlot content has access to the data scope of the parent component, because it is defined in the parent. For example:\n\n```vue-html\n<span>{{ message }}</span>\n<FancyButton>{{ message }}</FancyButton>\n```\n\nHere both <span v-pre>`{{ message }}`</span> interpolations will render the same content.\n\nSlot content does **not** have access to the child component's data. Expressions in Vue templates can only access the scope it is defined in, consistent with JavaScript's lexical scoping. In other words:\n\n> Expressions in the parent template only have access to the parent scope; expressions in the child template only have access to the child scope.",
          "questions": [
            "What is a slot outlet in Vue components?",
            "How can we pass a template fragment to a child component in Vue?",
            "Can slot content be any valid template content in Vue?",
            "What is the purpose of the `<slot>` element in Vue?",
            "How does the slot mechanism in Vue components differ from the native Web Component `<slot>` element?",
            "Does slot content have access to the child component's data in Vue?",
            "What is the benefit of using slots in Vue components?",
            "Can we pass multiple elements or other components as slot content in Vue?",
            "What is the scope of slot content in Vue components?",
            "What is the relationship between expressions in the parent template and the child template in Vue?"
          ]
        },
        {
          "content": "## Fallback Content {#fallback-content}\n\nThere are cases when it's useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a `<SubmitButton>` component:\n\n```vue-html\n<button type=\"submit\">\n  <slot></slot>\n</button>\n```\n\nWe might want the text \"Submit\" to be rendered inside the `<button>` if the parent didn't provide any slot content. To make \"Submit\" the fallback content, we can place it in between the `<slot>` tags:\n\n```vue-html{3}\n<button type=\"submit\">\n  <slot>\n    Submit <!-- fallback content -->\n  </slot>\n</button>\n```\n\nNow when we use `<SubmitButton>` in a parent component, providing no content for the slot:\n\n```vue-html\n<SubmitButton />\n```\n\nThis will render the fallback content, \"Submit\":\n\n```html\n<button type=\"submit\">Submit</button>\n```\n\nBut if we provide content:\n\n```vue-html\n<SubmitButton>Save</SubmitButton>\n```\n\nThen the provided content will be rendered instead:\n\n```html\n<button type=\"submit\">Save</button>\n```\n\n<div class=\"composition-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNp1kMsKwjAQRX9lzMaNbfcSC/oL3WbT1ikU8yKZFEX8d5MGgi2YVeZxZ86dN7taWy8B2ZlxP7rZEnikYFuhZ2WNI+jCoGa6BSKjYXJGwbFufpNJfhSaN1kflTEgVFb2hDEC4IeqguARpl7KoR8fQPgkqKpc3Wxo1lxRWWeW+Y4wBk9x9V9d2/UL8g1XbOJN4WAntodOnrecQ2agl8WLYH7tFyw5olj10iR3EJ+gPCxDFluj0YS6EAqKR8mi9M3Td1ifLxWShcU=)\n\n</div>\n<div class=\"options-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNp1UEEOwiAQ/MrKxYu1d4Mm+gWvXChuk0YKpCyNxvh3lxIb28SEA8zuDDPzEucQ9mNCcRAymqELdFKu64MfCK6p6Tu6JCLvoB18D9t9/Qtm4lY5AOXwMVFu2OpkCV4ZNZ51HDqKhwLAQjIjb+X4yHr+mh+EfbCakF8AclNVkCJCq61ttLkD4YOgqsp0YbGesJkVBj92NwSTIrH3v7zTVY8oF8F4SdazD7ET69S5rqXPpnigZ8CjEnHaVyInIp5G63O6XIGiIlZMzrGMd8RVfR0q4lIKKV+L+srW+wNTTZq3)\n\n</div>\n\n## Named Slots {#named-slots}\n\nThere are times when it's useful to have multiple slot outlets in a single component. For example, in a `<BaseLayout>` component with the following template:\n\n```vue-html\n<div class=\"container\">\n  <header>\n    <!-- We want header content here -->\n  </header>\n  <main>\n    <!-- We want main content here -->\n  </main>\n  <footer>\n    <!-- We want footer content here -->\n  </footer>\n</div>\n```\n\nFor these cases, the `<slot>` element has a special attribute, `name`, which can be used to assign a unique ID to different slots so you can determine where content should be rendered:\n\n```vue-html\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n\nA `<slot>` outlet without `name` implicitly has the name \"default\".\n\nIn a parent component using `<BaseLayout>`, we need a way to pass multiple slot content fragments, each targeting a different slot outlet. This is where **named slots** come in.\n\nTo pass a named slot, we need to use a `<template>` element with the `v-slot` directive, and then pass the name of the slot as an argument to `v-slot`:\n\n```vue-html\n<BaseLayout>\n  <template v-slot:header>\n    <!-- content for the header slot -->\n  </template>\n</BaseLayout>\n```\n\n`v-slot` has a dedicated shorthand `#`, so `<template v-slot:header>` can be shortened to just `<template #header>`. Think of it as \"render this template fragment in the child component's 'header' slot\".\n\n![named slots diagram](./images/named-slots.png)\n\n<!-- https://www.figma.com/file/2BhP8gVZevttBu9oUmUUyz/named-slot -->\n\nHere's the code passing content for all three slots to `<BaseLayout>` using the shorthand syntax:\n\n```vue-html\n<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <template #default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>\n```\n\nWhen a component accepts both a default slot and named slots, all top-level non-`<template>` nodes are implicitly treated as content for the default slot. So the above can also be written as:\n\n```vue-html\n<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <!-- implicit default slot -->\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>\n```\n\nNow everything inside the `<template>` elements will be passed to the corresponding slots. The final rendered HTML will be:\n\n```html\n<div class=\"container\">\n  <header>\n    <h1>Here might be a page title</h1>\n  </header>\n  <main>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </main>\n  <footer>\n    <p>Here's some contact info</p>\n  </footer>\n</div>\n```\n\n<div class=\"composition-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNp9UsFuwjAM/RWrHLgMOi5o6jIkdtphn9BLSF0aKU2ixEVjiH+fm8JoQdvRfu/5xS8+ZVvvl4cOsyITUQXtCSJS5zel1a13geBdRvyUR9cR1MG1MF/mt1YvnZdW5IOWVVwQtt5IQq4AxI2cau5ccZg1KCsMlz4jzWrzgQGh1fuGYIcgwcs9AmkyKHKGLyPykcfD1Apr2ZmrHUN+s+U5Qe6D9A3ULgA1bCK1BeUsoaWlyPuVb3xbgbSOaQGcxRH8v3XtHI0X8mmfeYToWkxmUhFoW7s/JvblJLERmj1l0+T7T5tqK30AZWSMb2WW3LTFUGZXp/u8o3EEVrbI9AFjLn8mt38fN9GIPrSp/p4/Yoj7OMZ+A/boN9KInPeZZpAOLNLRDAsPZDgN4p0L/NQFOV/Ayn9x6EZXMFNKvQ4E5YwLBczW6/WlU3NIi6i/sYDn5Qu2qX1OF51MsvMPkrIEHg==)\n\n</div>\n<div class=\"options-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNp9UkFuwjAQ/MoqHLiUpFxQlaZI9NRDn5CLSTbEkmNb9oKgiL934wRwQK3ky87O7njGPicba9PDHpM8KXzlpKV1qWVnjSP4FB6/xcnsCRpnOpin2R3qh+alBig1HgO9xkbsFcG5RyvDOzRq8vkAQLSury+l5lNkN1EuCDurBCFXAMWdH2pGrn2YtShqdCPOnXa5/kKH0MldS7BFEGDFDoEkKSwybo8rskjjaevo4L7Wrje8x4mdE7aFxjiglkWE1GxQE9tLi8xO+LoGoQ3THLD/qP2/dGMMxYZs8DP34E2HQUxUBFI35o+NfTlJLOomL8n04frXns7W8gCVEt5/lElQkxpdmVyVHvP2yhBo0SHThx5z+TEZvl1uMlP0oU3nH/kRo3iMI9Ybes960UyRsZ9pBuGDeTqpwfBAvn7NrXF81QUZm8PSHjl0JWuYVVX1PhAqo4zLYbZarUak4ZAWXv5gDq/pG3YBHn50EEkuv5irGBk=)\n\n</div>\n\nAgain, it may help you understand named slots better using the JavaScript function analogy:\n\n```js\n// passing multiple slot fragments with different names\nBaseLayout({\n  header: `...`,\n  default: `...`,\n  footer: `...`\n})\n\n// <BaseLayout> renders them in different places\nfunction BaseLayout(slots) {\n  return `<div class=\"container\">\n      <header>${slots.header}</header>\n      <main>${slots.default}</main>\n      <footer>${slots.footer}</footer>\n    </div>`\n}\n```\n\n## Dynamic Slot Names {#dynamic-slot-names}\n\n[Dynamic directive arguments](/guide/essentials/template-syntax.md#dynamic-arguments) also work on `v-slot`, allowing the definition of dynamic slot names:\n\n```vue-html\n<base-layout>\n  <template v-slot:[dynamicSlotName]>\n    ...\n  </template>\n\n  <!-- with shorthand -->\n  <template #[dynamicSlotName]>\n    ...\n  </template>\n</base-layout>\n```\n\nDo note the expression is subject to the [syntax constraints](/guide/essentials/template-syntax#directives) of dynamic directive arguments.",
          "questions": [
            "What is fallback content in Vue components?",
            "How can you specify fallback content for a slot in Vue components?",
            "Can you provide an example of using fallback content in a Vue component?",
            "What is a named slot in Vue components?",
            "How can you define a named slot in a Vue component?",
            "Can you provide an example of using named slots in a Vue component?",
            "What is the shorthand syntax for passing content to a named slot in a Vue component?",
            "What is a dynamic slot name in Vue components?",
            "How can you define a dynamic slot name in a Vue component?",
            "What are the syntax constraints for dynamic directive arguments in Vue components?"
          ]
        },
        {
          "content": "## Scoped Slots {#scoped-slots}\n\nAs discussed in [Render Scope](#render-scope), slot content does not have access to state in the child component.\n\nHowever, there are cases where it could be useful if a slot's content can make use of data from both the parent scope and the child scope. To achieve that, we need a way for the child to pass data to a slot when rendering it.\n\nIn fact, we can do exactly that - we can pass attributes to a slot outlet just like passing props to a component:\n\n```vue-html\n<!-- <MyComponent> template -->\n<div>\n  <slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>\n```\n\nReceiving the slot props is a bit different when using a single default slot vs. using named slots. We are going to show how to receive props using a single default slot first, by using `v-slot` directly on the child component tag:\n\n```vue-html\n<MyComponent v-slot=\"slotProps\">\n  {{ slotProps.text }} {{ slotProps.count }}\n</MyComponent>\n```\n\n![scoped slots diagram](./images/scoped-slots.svg)\n\n<!-- https://www.figma.com/file/QRneoj8eIdL1kw3WQaaEyc/scoped-slot -->\n\n<div class=\"composition-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNp9kMEKgzAMhl8l9OJlU3aVOhg7C3uAXsRlTtC2tFE2pO++dA5xMnZqk+b/8/2dxMnadBxQ5EL62rWWwCMN9qh021vjCMrn2fBNoya4OdNDkmarXhQnSstsVrOOC8LedhVhrEiuHca97wwVSsTj4oz1SvAUgKJpgqWZEj4IQoCvZm0Gtgghzss1BDvIbFkqdmID+CNdbbQnaBwitbop0fuqQSgguWPXmX+JePe1HT/QMtJBHnE51MZOCcjfzPx04JxsydPzp2Szxxo7vABY1I/p)\n\n</div>\n<div class=\"options-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNqFkNFqxCAQRX9l8CUttAl9DbZQ+rzQD/AlJLNpwKjoJGwJ/nvHpAnusrAg6FzHO567iE/nynlCUQsZWj84+lBmGJ31BKffL8sng4bg7O0IRVllWnpWKAOgDF7WBx2em0kTLElt975QbwLkhkmIyvCS1TGXC8LR6YYwVSTzH8yvQVt6VyJt3966oAR38XhaFjjEkvBCECNcia2d2CLyOACZQ7CDrI6h4kXcAF7lcg+za6h5et4JPdLkzV4B9B6RBtOfMISmxxqKH9TarrGtATxMgf/bDfM/qExEUCdEDuLGXAmoV06+euNs2JK7tyCrzSNHjX9aurQf)\n\n</div>\n\nThe props passed to the slot by the child are available as the value of the corresponding `v-slot` directive, which can be accessed by expressions inside the slot.\n\nYou can think of a scoped slot as a function being passed into the child component. The child component then calls it, passing props as arguments:\n\n```js\nMyComponent({\n  // passing the default slot, but as a function\n  default: (slotProps) => {\n    return `${slotProps.text} ${slotProps.count}`\n  }\n})\n\nfunction MyComponent(slots) {\n  const greetingMessage = 'hello'\n  return `<div>${\n    // call the slot function with props!\n    slots.default({ text: greetingMessage, count: 1 })\n  }</div>`\n}\n```\n\nIn fact, this is very close to how scoped slots are compiled, and how you would use scoped slots in manual [render functions](/guide/extras/render-function).\n\nNotice how `v-slot=\"slotProps\"` matches the slot function signature. Just like with function arguments, we can use destructuring in `v-slot`:\n\n```vue-html\n<MyComponent v-slot=\"{ text, count }\">\n  {{ text }} {{ count }}\n</MyComponent>\n```\n\n### Named Scoped Slots {#named-scoped-slots}\n\nNamed scoped slots work similarly - slot props are accessible as the value of the `v-slot` directive: `v-slot:name=\"slotProps\"`. When using the shorthand, it looks like this:\n\n```vue-html\n<MyComponent>\n  <template #header=\"headerProps\">\n    {{ headerProps }}\n  </template>\n\n  <template #default=\"defaultProps\">\n    {{ defaultProps }}\n  </template>\n\n  <template #footer=\"footerProps\">\n    {{ footerProps }}\n  </template>\n</MyComponent>\n```\n\nPassing props to a named slot:\n\n```vue-html\n<slot name=\"header\" message=\"hello\"></slot>\n```\n\nNote the `name` of a slot won't be included in the props because it is reserved - so the resulting `headerProps` would be `{ message: 'hello' }`.\n\nIf you are mixing named slots with the default scoped slot, you need to use an explicit `<template>` tag for the default slot. Attempting to place the `v-slot` directive directly on the component will result in a compilation error. This is to avoid any ambiguity about the scope of the props of the default slot. For example:\n\n```vue-html\n<!-- This template won't compile -->\n<template>\n  <MyComponent v-slot=\"{ message }\">\n    <p>{{ message }}</p>\n    <template #footer>\n      <!-- message belongs to the default slot, and is not available here -->\n      <p>{{ message }}</p>\n    </template>\n  </MyComponent>\n</template>\n```\n\nUsing an explicit `<template>` tag for the default slot helps to make it clear that the `message` prop is not available inside the other slot:\n\n```vue-html\n<template>\n  <MyComponent>\n    <!-- Use explicit default slot -->\n    <template #default=\"{ message }\">\n      <p>{{ message }}</p>\n    </template>\n\n    <template #footer>\n      <p>Here's some contact info</p>\n    </template>\n  </MyComponent>\n</template>\n```",
          "questions": [
            "What is the purpose of scoped slots in Vue?",
            "Can slot content access state in the child component? Why or why not?",
            "How can a child component pass data to a slot when rendering it?",
            "What is the syntax for passing attributes to a slot outlet?",
            "How do you receive slot props when using a single default slot?",
            "How do you receive slot props when using named slots?",
            "What is the difference between using an explicit `<template>` tag for the default slot versus placing the `v-slot` directive directly on the component?",
            "Can you use destructuring in `v-slot`? Give an example.",
            "What is the function signature of a scoped slot?",
            "How are scoped slots compiled and how would you use them in manual render functions?"
          ]
        },
        {
          "content": "### Fancy List Example {#fancy-list-example}\n\nYou may be wondering what would be a good use case for scoped slots. Here's an example: imagine a `<FancyList>` component that renders a list of items - it may encapsulate the logic for loading remote data, using the data to display a list, or even advanced features like pagination or infinite scrolling. However, we want it to be flexible with how each item looks and leave the styling of each item to the parent component consuming it. So the desired usage may look like this:\n\n```vue-html\n<FancyList :api-url=\"url\" :per-page=\"10\">\n  <template #item=\"{ body, username, likes }\">\n    <div class=\"item\">\n      <p>{{ body }}</p>\n      <p>by {{ username }} | {{ likes }} likes</p>\n    </div>\n  </template>\n</FancyList>\n```\n\nInside `<FancyList>`, we can render the same `<slot>` multiple times with different item data (notice we are using `v-bind` to pass an object as slot props):\n\n```vue-html\n<ul>\n  <li v-for=\"item in items\">\n    <slot name=\"item\" v-bind=\"item\"></slot>\n  </li>\n</ul>\n```\n\n<div class=\"composition-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNqFU2Fv0zAQ/StHJtROapNuZTBCNwnQQKBpTGxCQss+uMml8+bYlu2UlZL/zjlp0lQa40sU3/nd3Xv3vA7eax0uSwziYGZTw7UDi67Up4nkhVbGwScm09U5tw5yowoYhFEX8cBBImdRgyQMHRwWWjCHdAKYbdFM83FpxEkS0DcJINZoxpotkCIHkySo7xOixcMep19KrmGustUISotGsgJHIPgDWqg6DKEyvoRUMGsJ4HG9HGX16bqpAlU1izy5baqDFegYweYroMttMwLAHx/Y9Kyan36RWUTN2+mjXfpbrei8k6SjdSuBYFOlMaNI6AeAtcflSrqx5b8xhkl4jMU7H0yVUCaGvVeH8+PjKYWqWnpf5DQYBTtb+fc612Awh2qzzGaBiUyVpBVpo7SFE8gw5xIv/Wl4M9gsbjCCQbuywe3+FuXl9iiqO7xpElEEhUofKFQo2mTGiFiOLr3jcpFImuiaF6hKNxzuw8lpw7kuEy6ZKJGK3TR6NluLYXBVqwRXQjkLn0ueIc3TLonyZ0sm4acqKVovKIbDCVQjGsb1qvyg2telU4Yzz6eHv6ARBWdwjVqUNCbbFjqgQn6aW1J8RKfJhDg+5/lStG4QHJZjnpO5XjT0BMqFu+uZ81yxjEQJw7A1kOA76FyZjaWBy0akvu8tCQKeQ+d7wsy5zLpz1FlzU3kW1QP+x40ApWgWAySEJTv6/NitNMkllcTakwCaZZ5ADEf6cROas/RhYVQps5igEpkZLwzRROmG04OjDBcj7+Js+vYQDo9e0uH1qzeY5/s1vtaaqG969+vTTrsmBTMLLv12nuy7l+d5W673SBzxkzlfhPdWSXokdZMkSFWhuUDzTTtOnk6CuG2fBEwI9etrHXOmRLJUE0/vMH14In5vH30sCS4Nkr+WmARdztHQ6Jr02dUFPtJ/lyxUVgq6/UzyO1olSj9jc+0DcaWxe/fqab/UT51Uu7Znjw6lbUn5QWtR6vtJQM//4zPUt+NOw+lGzCqo/gLm1QS8)\n\n</div>\n<div class=\"options-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNqNVNtq20AQ/ZWpQnECujhO0qaqY+hD25fQl4RCifKwllbKktXushcT1/W/d1bSSnYJNCCEZmbPmcuZ1S76olS6cTTKo6UpNVN2VQjWKqktfCOi3N4yY6HWsoVZmo0eD5kVAqAQ9KU7XNGaOG5h572lRAZBhTV574CJzJv7QuCzzMaMaFjaKk4sRQtgOeUmiiVO85siwncRQa6oThRpKHrO50XUnUdEwMMJw08M7mAtq20MzlAtSEtj4OyZGkweMIiq2AZKToxBgMcdxDCqVrueBfb7ZaaOQiOspZYgbL0FPBySIQD+eMeQc99/HJIsM0weqs+O258mjfZREE1jt5yCKaWiFXpSX0A/5loKmxj2m+YwT69p+7kXg0udw8nlYn19fYGufvSeZBXF0ZGmR2vwmrJKS4WiPswGWWYxzIIgs8fYH6mIJadnQXdNrdMiWAB+yJ7gsXdgLfjqcK10wtJqgmYZ+spnpGgl6up5oaa2fGKi6U8Yau9ZS6Wzpwi7WU1p7BMzaZcLbuBh0q2XM4fZXTc+uOPSGvjuWEWxlaAexr9uiIBf0qG3Uy6HxXwo9B+mn47CvbNSM+LHccDxAyvmjMA9Vdxh1WQiO0eywBVGEaN3Pj972wVxPKwOZ7BJWI2b+K5rOOVUNPbpYJNvJalwZmmahm3j7AhdSz3sPzDRS3R4SQwOCXxP4yVBzJqJarSzcY8H5mXWFfif1QVwPGjGcQWTLp7YrcLxCfyDdAuMW0cq30AOV+plcK1J+dxoXJkqR6igRCeNxjbxp3N6cX5V0Sb2K19dfFrA4uo9Gh8uP9K6Puvw3eyx9SH3IT/qPCZpiW6Y8Gq9mvekrutAN96o/V99ALPj)\n\n</div>\n\n### Renderless Components {#renderless-components}\n\nThe `<FancyList>` use case we discussed above encapsulates both reusable logic (data fetching, pagination etc.) and visual output, while delegating part of the visual output to the consumer component via scoped slots.\n\nIf we push this concept a bit further, we can come up with components that only encapsulate logic and do not render anything by themselves - visual output is fully delegated to the consumer component with scoped slots. We call this type of component a **Renderless Component**.\n\nAn example renderless component could be one that encapsulates the logic of tracking the current mouse position:\n\n```vue-html\n<MouseTracker v-slot=\"{ x, y }\">\n  Mouse is at: {{ x }}, {{ y }}\n</MouseTracker>\n```\n\n<div class=\"composition-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNqNUcFqhDAQ/ZUhF12w2rO4Cz301t5aaCEX0dki1SQko6uI/96J7i4qLPQQmHmZ9+Y9ZhQvxsRdiyIVmStsZQgcUmtOUlWN0ZbgXbcOP2xe/KKFs9UNBHGyBj09kCpLFj4zuSFsTJ0T+o6yjUb35GpNRylG6CMYYJKCpwAkzWNQOcgphZG/YZoiX/DQNAttFjMrS+6LRCT2rh6HGsHiOQKtmKIIS19+qmZpYLrmXIKxM1Vo5Yj9HD0vfD7ckGGF3LDWlOyHP/idYPQCfdzldTtjscl/8MuDww78lsqHVHdTYXjwCpdKlfoS52X52qGit8oRKrRhwHYdNrrDILouPbCNVZCtgJ1n/6Xx8JYAmT8epD3fr5cC0oGLQYpkd4zpD27R0vA=)\n\n</div>\n<div class=\"options-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNqVUU1rwzAM/SvCl7SQJTuHdLDDbttthw18MbW6hjW2seU0oeS/T0lounQfUDBGepaenvxO4tG5rIkoClGGra8cPUhT1c56ghcbA756tf1EDztva0iy/Ds4NCbSAEiD7diicafigeA0oFvLPAYNhWICYEE5IL00fMp8Hs0JYe0OinDIqFyIaO7CwdJGihO0KXTcLriK59NYBlUARTyMn6Hv0yHgIp7ARAvl3FXm8yCRiuu1Fv/x23JakVqtz3t5pOjNOQNoC7hPz0nHyRSzEr7Ghxppb/XlZ6JjRlzhTAlA+ypkLWwAM6c+8G2BdzP+/pPbRkOoL/KOldH2mCmtnxr247kKhAb9KuHKgLVtMEkn2knG+sIVzV9sfmy8hfB/swHKwV0oWja4lQKKjoNOivzKrf4L/JPqaQ==)\n\n</div>\n\nWhile an interesting pattern, most of what can be achieved with Renderless Components can be achieved in a more efficient fashion with Composition API, without incurring the overhead of extra component nesting. Later, we will see how we can implement the same mouse tracking functionality as a [Composable](/guide/reusability/composables).\n\nThat said, scoped slots are still useful in cases where we need to both encapsulate logic **and** compose visual output, like in the `<FancyList>` example.",
          "questions": [
            "What is the purpose of scoped slots in Vue?",
            "Can you provide an example of a component that uses scoped slots?",
            "What is a renderless component in Vue?",
            "How does a renderless component differ from a regular component?",
            "Can you provide an example of a renderless component?",
            "What is the benefit of using a renderless component?",
            "How can you achieve the same functionality as a renderless component using the Composition API?",
            "In what cases are scoped slots useful?",
            "How do you pass data to a scoped slot in Vue?",
            "How does a renderless component delegate visual output to the consumer component?"
          ]
        }
      ]
    },
    {
      "file_name": "registration.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Component Registration {#component-registration}\n\n> This page assumes you've already read the [Components Basics](/guide/essentials/component-basics). Read that first if you are new to components.\n\n<VueSchoolLink href=\"https://vueschool.io/lessons/vue-3-global-vs-local-vue-components\" title=\"Free Vue.js Component Registration Lesson\"/>\n\nA Vue component needs to be \"registered\" so that Vue knows where to locate its implementation when it is encountered in a template. There are two ways to register components: global and local.\n\n## Global Registration {#global-registration}\n\nWe can make components available globally in the current [Vue application](/guide/essentials/application) using the `app.component()` method:\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n\napp.component(\n  // the registered name\n  'MyComponent',\n  // the implementation\n  {\n    /* ... */\n  }\n)\n```\n\nIf using SFCs, you will be registering the imported `.vue` files:\n\n```js\nimport MyComponent from './App.vue'\n\napp.component('MyComponent', MyComponent)\n```\n\nThe `app.component()` method can be chained:\n\n```js\napp\n  .component('ComponentA', ComponentA)\n  .component('ComponentB', ComponentB)\n  .component('ComponentC', ComponentC)\n```\n\nGlobally registered components can be used in the template of any component within this application:\n\n```vue-html\n<!-- this will work in any component inside the app -->\n<ComponentA/>\n<ComponentB/>\n<ComponentC/>\n```\n\nThis even applies to all subcomponents, meaning all three of these components will also be available _inside each other_.\n\n## Local Registration {#local-registration}\n\nWhile convenient, global registration has a few drawbacks:\n\n1. Global registration prevents build systems from removing unused components (a.k.a \"tree-shaking\"). If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.\n\n2. Global registration makes dependency relationships less explicit in large applications. It makes it difficult to locate a child component's implementation from a parent component using it. This can affect long-term maintainability similar to using too many global variables.\n\nLocal registration scopes the availability of the registered components to the current component only. It makes the dependency relationship more explicit, and is more tree-shaking friendly.\n\n<div class=\"composition-api\">\n\nWhen using SFC with `<script setup>`, imported components can be locally used without registration:\n\n```vue\n<script setup>\nimport ComponentA from './ComponentA.vue'\n</script>\n\n<template>\n  <ComponentA />\n</template>\n```\n\nIn non-`<script setup>`, you will need to use the `components` option:\n\n```js\nimport ComponentA from './ComponentA.js'\n\nexport default {\n  components: {\n    ComponentA\n  },\n  setup() {\n    // ...\n  }\n}\n```\n\n</div>\n<div class=\"options-api\">\n\nLocal registration is done using the `components` option:\n\n```vue\n<script>\nimport ComponentA from './ComponentA.vue'\n\nexport default {\n  components: {\n    ComponentA\n  }\n}\n</script>\n\n<template>\n  <ComponentA />\n</template>\n```\n\n</div>\n\nFor each property in the `components` object, the key will be the registered name of the component, while the value will contain the implementation of the component. The above example is using the ES2015 property shorthand and is equivalent to:\n\n```js\nexport default {\n  components: {\n    ComponentA: ComponentA\n  }\n  // ...\n}\n```\n\nNote that **locally registered components are _not_ also available in descendant components**. In this case, `ComponentA` will be made available to the current component only, not any of its child or descendant components.\n\n## Component Name Casing {#component-name-casing}\n\nThroughout the guide, we are using PascalCase names when registering components. This is because:\n\n1. PascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.\n\n2. `<PascalCase />` makes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).\n\nThis is the recommended style when working with SFC or string templates. However, as discussed in [in-DOM Template Parsing Caveats](/guide/essentials/component-basics#in-dom-template-parsing-caveats), PascalCase tags are not usable in in-DOM templates.\n\nLuckily, Vue supports resolving kebab-case tags to components registered using PascalCase. This means a component registered as `MyComponent` can be referenced in the template via both `<MyComponent>` and `<my-component>`. This allows us to use the same JavaScript component registration code regardless of template source.",
          "questions": [
            "What is component registration in Vue?",
            "What are the two ways to register components in Vue?",
            "How can we make components available globally in Vue?",
            "What is the `app.component()` method used for in Vue?",
            "How can we register imported `.vue` files in Vue?",
            "What are the drawbacks of global registration in Vue?",
            "How does local registration differ from global registration in Vue?",
            "How can we locally use imported components without registration in Vue?",
            "How can we register components locally in Vue using the `components` option?",
            "What is the recommended naming convention for Vue components and why?"
          ]
        }
      ]
    },
    {
      "file_name": "v-model.md",
      "question_count": 30,
      "documents": [
        {
          "content": "# Component v-model {#component-v-model}\n\n`v-model` can be used on a component to implement a two-way binding.\n\nFirst let's revisit how `v-model` is used on a native element:\n\n```vue-html\n<input v-model=\"searchText\" />\n```\n\nUnder the hood, the template compiler expands `v-model` to the more verbose equivalent for us. So the above code does the same as the following:\n\n```vue-html\n<input\n  :value=\"searchText\"\n  @input=\"searchText = $event.target.value\"\n/>\n```\n\nWhen used on a component, `v-model` instead expands to this:\n\n```vue-html\n<CustomInput\n  :model-value=\"searchText\"\n  @update:model-value=\"newValue => searchText = newValue\"\n/>\n```\n\nFor this to actually work though, the `<CustomInput>` component must do two things:\n\n1. Bind the `value` attribute of a native `<input>` element to the `modelValue` prop\n2. When a native `input` event is triggered, emit an `update:modelValue` custom event with the new value\n\nHere's that in action:\n\n<div class=\"options-api\">\n\n```vue\n<!-- CustomInput.vue -->\n<script>\nexport default {\n  props: ['modelValue'],\n  emits: ['update:modelValue']\n}\n</script>\n\n<template>\n  <input\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n</div>\n<div class=\"composition-api\">\n\n```vue\n<!-- CustomInput.vue -->\n<script setup>\ndefineProps(['modelValue'])\ndefineEmits(['update:modelValue'])\n</script>\n\n<template>\n  <input\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n</div>\n\nNow `v-model` should work perfectly with this component:\n\n```vue-html\n<CustomInput v-model=\"searchText\" />\n```\n\n<div class=\"options-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNqFkctqwzAQRX9lEAEn4Np744aWrvoD3URdiHiSGvRCHpmC8b93JDfGKYGCkJjXvTrSJF69r8aIohHtcA69p6O0vfEuELzFgZx5tz4SXIIzUFT1JpfGCmmlxe/c3uFFRU0wSQtwdqxh0dLQwHSnNJep3ilS+8PSCxCQYrC3CMDgMKgrNlB8odaOXVJ2TgdvvNp6vSwHhMZrRcgRQLs1G5+M61A/S/ErKQXUR5immwXMWW1VEKX4g3j3Mo9QfXCeKU9FtvpQmp/lM0Oi6RP/qYieebHZNvyL0acLLODNmGYSxCogxVJ6yW1c2iWz/QOnEnY48kdUpMIVGSllD8t8zVZb+PkHqPG4iw==)\n\n</div>\n<div class=\"composition-api\">\n\n[Try it in the Playground](https://play.vuejs.org/#eNp9j81qwzAQhF9lEQE7kNp344SW0kNvPfVS9WDidSrQH9LKF+N37yoOxoSQm7QzO9/sJN68r8aEohFtPAflCSJS8idplfEuEEwQcIAZhuAMFGwtVuk9RXLm0/pEN7mqN7Ocy2YAac/ORgKDMXYXhGOOLIs/1NoVe2nbekEzlD+ExuuOkH8A7ZYxvhjXoz5KcUuSAuoTTNOaPM85bU0QB3HX58GdPQ7K4ldwPpY/xZXw3Wmu/svVFvHDKMpi8j3HNneeZ/VVBucXQDPmjVx+XZdikV6vNpZ2yKTyAecAOxzRUkVduCCfkqf7Zb9m1Pbo+R9ZkqZn)\n\n</div>\n\nAnother way of implementing `v-model` within this component is to use a writable `computed` property with both a getter and a setter. The `get` method should return the `modelValue` property and the `set` method should emit the corresponding event:\n\n<div class=\"options-api\">\n\n```vue\n<!-- CustomInput.vue -->\n<script>\nexport default {\n  props: ['modelValue'],\n  emits: ['update:modelValue'],\n  computed: {\n    value: {\n      get() {\n        return this.modelValue\n      },\n      set(value) {\n        this.$emit('update:modelValue', value)\n      }\n    }\n  }\n}\n</script>\n\n<template>\n  <input v-model=\"value\" />\n</template>\n```\n\n</div>\n<div class=\"composition-api\">\n\n```vue\n<!-- CustomInput.vue -->\n<script setup>\nimport { computed } from 'vue'\n\nconst props = defineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\n\nconst value = computed({\n  get() {\n    return props.modelValue\n  },\n  set(value) {\n    emit('update:modelValue', value)\n  }\n})\n</script>\n\n<template>\n  <input v-model=\"value\" />\n</template>\n```\n\n</div>\n\n## `v-model` arguments {#v-model-arguments}\n\nBy default, `v-model` on a component uses `modelValue` as the prop and `update:modelValue` as the event. We can modify these names passing an argument to `v-model`:\n\n```vue-html\n<MyComponent v-model:title=\"bookTitle\" />\n```\n\nIn this case, the child component should expect a `title` prop and emit an `update:title` event to update the parent value:\n\n<div class=\"composition-api\">\n\n```vue\n<!-- MyComponent.vue -->\n<script setup>\ndefineProps(['title'])\ndefineEmits(['update:title'])\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"title\"\n    @input=\"$emit('update:title', $event.target.value)\"\n  />\n</template>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNp9kE1rwzAMhv+KMIW00DXsGtKyMXYc7D7vEBplM8QfOHJoCfnvk+1QsjJ2svVKevRKk3h27jAGFJWoh7NXjmBACu4kjdLOeoIJPHYwQ+ethoJLi1vq7fpi+WfQ0JI+lCstcrkYQJqzNQMBKeoRjhG4LcYHbVvsofFfQUcCXhrteix20tRl9sIuOCBkvSHkCKD+fjxN04Ka57rkOOlrMwu7SlVHKdIrBZRcWpc3ntiLO7t/nKHFThl899YN248ikYpP9pj1V60o6sG1TMwDU/q/FZRxgeIPgK4uGcQLSZGlamz6sHKd1afUxOoGeeT298A9bHCMKxBfE3mTSNjl1vud5x8qNa76)\n\n</div>\n<div class=\"options-api\">\n\n```vue\n<!-- MyComponent.vue -->\n<script>\nexport default {\n  props: ['title'],\n  emits: ['update:title']\n}\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"title\"\n    @input=\"$emit('update:title', $event.target.value)\"\n  />\n</template>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNqFUNFqwzAM/BVhCm6ha9hryMrGnvcFdR9Mo26B2DGuHFJC/n2yvZakDAohtuTTne5G8eHcrg8oSlFdTr5xtFe2Ma7zBF/Xz45vFi3B2XcG5K6Y9eKYVFZZHBK8xrMOLcGoLMDphrqUMC6Ypm18rzXp9SZjATxS8PZWAVBDLZYg+xfT1diC9t/BxGEctHFtlI2wKR78468q7ttzQcgoTcgVQPXzuh/HzAnTVBVcp/58qz+lMqHelEinElAwtCrufGIrHhJYBPdfEs53jkM4yEQpj8k+miYmc5DBcRKYZeXxqZXGukDZPF1dWhQHUiK3yl63YbZ97r6nIe6uoup6KbmFFfbRCnHGyI4iwyaPPnqffgGMlsEM)\n\n</div>",
          "questions": [
            "What is the purpose of `v-model` on a component?",
            "How does `v-model` work on a native element?",
            "What does `v-model` expand to when used on a component?",
            "What must a component do for `v-model` to work with it?",
            "How can you implement `v-model` within a component using a writable computed property?",
            "What are the default prop and event names used by `v-model` on a component?",
            "How can you modify the prop and event names used by `v-model` on a component?",
            "What should a child component expect when `v-model` is used with a modified prop and event name?",
            "What is the purpose of the `modelValue` prop and `update:modelValue` event?",
            "What is the purpose of the `value` attribute and `input` event on a native `<input>` element?"
          ]
        },
        {
          "content": "## Multiple `v-model` bindings {#multiple-v-model-bindings}\n\nBy leveraging the ability to target a particular prop and event as we learned before with [`v-model` arguments](#v-model-arguments), we can now create multiple `v-model` bindings on a single component instance.\n\nEach `v-model` will sync to a different prop, without the need for extra options in the component:\n\n```vue-html\n<UserName\n  v-model:first-name=\"first\"\n  v-model:last-name=\"last\"\n/>\n```\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\ndefineProps({\n  firstName: String,\n  lastName: String\n})\n\ndefineEmits(['update:firstName', 'update:lastName'])\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"firstName\"\n    @input=\"$emit('update:firstName', $event.target.value)\"\n  />\n  <input\n    type=\"text\"\n    :value=\"lastName\"\n    @input=\"$emit('update:lastName', $event.target.value)\"\n  />\n</template>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNqNUc1qwzAMfhVjCk6hTdg1pGWD7bLDGIydlh1Cq7SGxDaOEjaC332yU6cdFNpLsPRJ348y8idj0qEHnvOi21lpkHWAvdmWSrZGW2Qjs1Azx2qrWyZoVMzQZwf2rWrhhKVZbHhGGivVTqsOWS0tfTeeKBGv+qjEMkJNdUaeNXigyCYjZIEKhNY0FQJVjBXHh+04nvicY/QOBM4VGUFhJHrwBWPDutV7aPKwslbU35Q8FCX/P+GJ4oB/T3hGpEU2m+ArfpnxytX2UEsF71abLhk9QxDzCzn7QCvVYeW7XuGyWSpH0eP6SyuxS75Eb/akOpn302LFYi8SiO8bJ5PK9DhFxV/j0yH8zOnzoWr6+SbhbifkMSwSsgByk1zzsoABFKZY2QNgGpiW57Pdrx2z3JCeI99Svvxh7g8muf2x)\n\n</div>\n<div class=\"options-api\">\n\n```vue\n<script>\nexport default {\n  props: {\n    firstName: String,\n    lastName: String\n  },\n  emits: ['update:firstName', 'update:lastName']\n}\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"firstName\"\n    @input=\"$emit('update:firstName', $event.target.value)\"\n  />\n  <input\n    type=\"text\"\n    :value=\"lastName\"\n    @input=\"$emit('update:lastName', $event.target.value)\"\n  />\n</template>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNqNkk1rg0AQhv/KIAETSJRexYYWeuqhl9JTt4clmSSC7i7rKCnif+/ObtYkELAiujPzztejQ/JqTNZ3mBRJ2e5sZWgrVNUYbQm+WrQfskE4WN1AmuXRwQmpUELh2Qv3eJBdTTAIBbDTLluhoraA4VpjXHNwL0kuV0EIYJE6q6IFcKhsSwWk7/qkUq/nq5be+aa5JztGfrmHu8t8GtoZhI2pJaGzAMrT03YYQk0YR3BnruSOZe5CXhKnC3X7TaP3WBc+ZaOc/1kk3hDJvYILRQGfQzx3Rct8GiJZJ7fA7gg/AmesNszMrUIXFpxbwCfZSh09D0Hc7tbN6sAWm4qZf6edcZgxrMHSdA3RF7PTn1l8lTIdhbXp1/CmhOeJRNHLupv4eIaXyItPdJEFD7R8NM0Ce/d/ZCTtESnzlVZXhP/vHbeZaT0tPdf59uONfx7mDVM=)\n\n</div>\n\n## Handling `v-model` modifiers {#handling-v-model-modifiers}\n\nWhen we were learning about form input bindings, we saw that `v-model` has [built-in modifiers](/guide/essentials/forms#modifiers) - `.trim`, `.number` and `.lazy`. In some cases, you might also want the `v-model` on your custom input component to support custom modifiers.\n\nLet's create an example custom modifier, `capitalize`, that capitalizes the first letter of the string provided by the `v-model` binding:\n\n```vue-html\n<MyComponent v-model.capitalize=\"myText\" />\n```\n\nModifiers added to a component `v-model` will be provided to the component via the `modelModifiers` prop. In the below example, we have created a component that contains a `modelModifiers` prop that defaults to an empty object:\n\n<div class=\"composition-api\">\n\n```vue{4,9}\n<script setup>\nconst props = defineProps({\n  modelValue: String,\n  modelModifiers: { default: () => ({}) }\n})\n\ndefineEmits(['update:modelValue'])\n\nconsole.log(props.modelModifiers) // { capitalize: true }\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n</div>\n<div class=\"options-api\">\n\n```vue{11}\n<script>\nexport default {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  emits: ['update:modelValue'],\n  created() {\n    console.log(this.modelModifiers) // { capitalize: true }\n  }\n}\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n</div>\n\nNotice the component's `modelModifiers` prop contains `capitalize` and its value is `true` - due to it being set on the `v-model` binding `v-model.capitalize=\"myText\"`.\n\nNow that we have our prop set up, we can check the `modelModifiers` object keys and write a handler to change the emitted value. In the code below we will capitalize the string whenever the `<input />` element fires an `input` event.\n\n<div class=\"composition-api\">\n\n```vue{11-13}\n<script setup>\nconst props = defineProps({\n  modelValue: String,\n  modelModifiers: { default: () => ({}) }\n})\n\nconst emit = defineEmits(['update:modelValue'])\n\nfunction emitValue(e) {\n  let value = e.target.value\n  if (props.modelModifiers.capitalize) {\n    value = value.charAt(0).toUpperCase() + value.slice(1)\n  }\n  emit('update:modelValue', value)\n}\n</script>\n\n<template>\n  <input type=\"text\" :value=\"modelValue\" @input=\"emitValue\" />\n</template>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNp9Us1Og0AQfpUJF5ZYqV4JNTaNxyYmVi/igdCh3QR2N7tDIza8u7NLpdU0nmB+v5/ZY7Q0Jj10GGVR7iorDYFD6sxDoWRrtCU4gsUaBqitbiHm1ngqrfuV5j+Fik7ldH6R83u5GaBQlVaOoO03+Emw8BtFHCeFyucjKMNxQNiapiTkCGCzlw6kMh1BVRpJZSO/0AEe0Pa0l2oHve6AYdBmvj+/ZHO4bfUWm/Q8uSiiEb6IYM4A+XxCi2bRH9ZX3BgVGKuNYwFbrKXCZx+Jo0cPcG9l02EGL2SZ3mxKr/VW1hKty9hMniy7hjIQCSweQByHBIZCDWzGDwi20ps0Yjxx4MR73Jktc83OOPFHGKk7VZHUKkyFgsAEAqcG2Qif4WWYUml3yOp8wldlDSLISX+TvPDstAemLeGbVvvSLkncJSnpV2PQrkqHLOfmVHeNrFDcMz3w0iBQE1cUzMYBbuS2f55CPj4D6o0/I41HzMKsP+u0kLOPoZWzkx1X7j18A8s0DEY=)\n\n</div>\n<div class=\"options-api\">\n\n```vue{13-15}\n<script>\nexport default {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  emits: ['update:modelValue'],\n  methods: {\n    emitValue(e) {\n      let value = e.target.value\n      if (this.modelModifiers.capitalize) {\n        value = value.charAt(0).toUpperCase() + value.slice(1)\n      }\n      this.$emit('update:modelValue', value)\n    }\n  }\n}\n</script>\n\n<template>\n  <input type=\"text\" :value=\"modelValue\" @input=\"emitValue\" />\n</template>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNqFks1qg0AQgF9lkIKGpqa9iikNOefUtJfaw6KTZEHdZR1DbPDdO7saf0qgIq47//PNXL2N1uG5Ri/y4io1UtNrUspCK0Owa7aK/0osCQ5GFeCHq4nMuvlJCZCUeHEOGR5EnRNcrTS92VURXGex2qXVZ4JEsOhsAQxSbcrbDaBo9nihCHyXAaC1B3/4jVdDoXwhLHQuCPkGsD/JCmSpa4JUaEkilz9YAZ7RNHSS5REaVQPXgCay9vG0rPNToTLMw9FznXhdHYkHK04Qr4Zs3tL7g2JG8B4QbZS2LLqGXK5PkdcYwTsZrs1R6RU7lcmDRDPaM7AuWARMbf0KwbVdTNk4dyyk5f3l15r5YjRm8b+dQYF0UtkY1jo4fYDDLAByZBxWCmvAkIQ5IvdoBTcLeYCAiVbhvNwJvEk4GIK5M0xPwmwoeF6EpD60RrMVFXJXj72+ymWKwUvfXt+gfVzGB1tzcKfDZec+o/LfxsTdtlCj7bSpm3Xk4tjpD8FZ+uZMWTowu7MW7S+CWR77)\n\n</div>",
          "questions": [
            "How can you create multiple `v-model` bindings on a single component instance?",
            "What is the purpose of `v-model` arguments?",
            "Can you create custom modifiers for `v-model` on a custom input component?",
            "How can you access the `modelModifiers` prop in a component?",
            "What is the default value of the `modelModifiers` prop?",
            "How can you handle `v-model` modifiers in a custom input component?",
            "What is the purpose of the `update:modelValue` event?",
            "How can you capitalize the first letter of a string provided by a `v-model` binding?",
            "What is the purpose of the `defineProps` function?",
            "What is the purpose of the `defineEmits` function?"
          ]
        },
        {
          "content": "### Modifiers for `v-model` with arguments {#modifiers-for-v-model-with-arguments}\n\nFor `v-model` bindings with both argument and modifiers, the generated prop name will be `arg + \"Modifiers\"`. For example:\n\n```vue-html\n<MyComponent v-model:title.capitalize=\"myText\">\n```\n\nThe corresponding declarations should be:\n\n<div class=\"composition-api\">\n\n```js\nconst props = defineProps(['title', 'titleModifiers'])\ndefineEmits(['update:title'])\n\nconsole.log(props.titleModifiers) // { capitalize: true }\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: ['title', 'titleModifiers'],\n  emits: ['update:title'],\n  created() {\n    console.log(this.titleModifiers) // { capitalize: true }\n  }\n}\n```\n\n</div>\n\nHere's another example of using modifiers with multiple `v-model` with different arguments:\n\n```vue-html\n<UserName\n  v-model:first-name.capitalize=\"first\"\n  v-model:last-name.uppercase=\"last\"\n/>\n```\n\n<div class=\"composition-api\">\n\n```vue{5,6,10,11}\n<script setup>\nconst props = defineProps({\n  firstName: String,\n  lastName: String,\n  firstNameModifiers: { default: () => ({}) },\n  lastNameModifiers: { default: () => ({}) }\n})\ndefineEmits(['update:firstName', 'update:lastName'])\n\nconsole.log(props.firstNameModifiers) // { capitalize: true }\nconsole.log(props.lastNameModifiers) // { uppercase: true}\n</script>\n```\n\n</div>\n<div class=\"options-api\">\n\n```vue{15,16}\n<script>\nexport default {\n  props: {\n    firstName: String,\n    lastName: String,\n    firstNameModifiers: {\n      default: () => ({})\n    },\n    lastNameModifiers: {\n      default: () => ({})\n    }\n  },\n  emits: ['update:firstName', 'update:lastName'],\n  created() {\n    console.log(this.firstNameModifiers) // { capitalize: true }\n    console.log(this.lastNameModifiers) // { uppercase: true}\n  }\n}\n</script>\n```\n\n</div>",
          "questions": [
            "What is the generated prop name for `v-model` bindings with both argument and modifiers?",
            "Can you provide an example of using modifiers with multiple `v-model` with different arguments?",
            "What should be the corresponding declarations for `MyComponent v-model:title.capitalize=\"myText\"`?",
            "How do you define props and emits for `v-model` bindings with both argument and modifiers in the Composition API?",
            "How do you define props and emits for `v-model` bindings with both argument and modifiers in the Options API?",
            "What is the purpose of `arg + \"Modifiers\"` in `v-model` bindings with both argument and modifiers?",
            "What is the value of `props.titleModifiers` in `MyComponent v-model:title.capitalize=\"myText\"`?",
            "What is the value of `props.firstNameModifiers` and `props.lastNameModifiers` in `<UserName v-model:first-name.capitalize=\"first\" v-model:last-name.uppercase=\"last\"/>`?",
            "What is the difference between `defineProps` and `defineEmits` in the Composition API?",
            "Can you use modifiers with `v-bind`? Why or why not?"
          ]
        }
      ]
    },
    {
      "file_name": "events.md",
      "question_count": 10,
      "documents": [
        {
          "content": "<script setup>\nimport { onMounted } from 'vue'\n\nif (typeof window !== 'undefined') {\n  const hash = window.location.hash\n\n  // The docs for v-model used to be part of this page. Attempt to redirect outdated links.\n  if ([\n    '#usage-with-v-model',\n    '#v-model-arguments',\n    '#multiple-v-model-bindings',\n    '#handling-v-model-modifiers'\n  ].includes(hash)) {\n    onMounted(() => {\n      window.location = './v-model.html' + hash\n    })\n  }\n}\n</script>\n# Component Events {#component-events}\n\n> This page assumes you've already read the [Components Basics](/guide/essentials/component-basics). Read that first if you are new to components.\n\n<div class=\"options-api\">\n  <VueSchoolLink href=\"https://vueschool.io/lessons/defining-custom-events-emits\" title=\"Free Vue.js Lesson on Defining Custom Events\"/>\n</div>\n\n## Emitting and Listening to Events {#emitting-and-listening-to-events}\n\nA component can emit custom events directly in template expressions (e.g. in a `v-on` handler) using the built-in `$emit` method:\n\n```vue-html\n<!-- MyComponent -->\n<button @click=\"$emit('someEvent')\">click me</button>\n```\n\n<div class=\"options-api\">\n\nThe `$emit()` method is also available on the component instance as `this.$emit()`:\n\n```js\nexport default {\n  methods: {\n    submit() {\n      this.$emit('someEvent')\n    }\n  }\n}\n```\n\n</div>\n\nThe parent can then listen to it using `v-on`:\n\n```vue-html\n<MyComponent @some-event=\"callback\" />\n```\n\nThe `.once` modifier is also supported on component event listeners:\n\n```vue-html\n<MyComponent @some-event.once=\"callback\" />\n```\n\nLike components and props, event names provide an automatic case transformation. Notice we emitted a camelCase event, but can listen for it using a kebab-cased listener in the parent. As with [props casing](/guide/components/props#prop-name-casing), we recommend using kebab-cased event listeners in templates.\n\n:::tip\nUnlike native DOM events, component emitted events do **not** bubble. You can only listen to the events emitted by a direct child component. If there is a need to communicate between sibling or deeply nested components, use an external event bus or a [global state management solution](/guide/scaling-up/state-management).\n:::\n\n## Event Arguments {#event-arguments}\n\nIt's sometimes useful to emit a specific value with an event. For example, we may want the `<BlogPost>` component to be in charge of how much to enlarge the text by. In those cases, we can pass extra arguments to `$emit` to provide this value:\n\n```vue-html\n<button @click=\"$emit('increaseBy', 1)\">\n  Increase by 1\n</button>\n```\n\nThen, when we listen to the event in the parent, we can use an inline arrow function as the listener, which allows us to access the event argument:\n\n```vue-html\n<MyButton @increase-by=\"(n) => count += n\" />\n```\n\nOr, if the event handler is a method:\n\n```vue-html\n<MyButton @increase-by=\"increaseCount\" />\n```\n\nThen the value will be passed as the first parameter of that method:\n\n<div class=\"options-api\">\n\n```js\nmethods: {\n  increaseCount(n) {\n    this.count += n\n  }\n}\n```\n\n</div>\n<div class=\"composition-api\">\n\n```js\nfunction increaseCount(n) {\n  count.value += n\n}\n```\n\n</div>\n\n:::tip\nAll extra arguments passed to `$emit()` after the event name will be forwarded to the listener. For example, with `$emit('foo', 1, 2, 3)` the listener function will receive three arguments.\n:::\n\n## Declaring Emitted Events {#declaring-emitted-events}\n\nA component can explicitly declare the events it will emit using the <span class=\"composition-api\">[`defineEmits()`](/api/sfc-script-setup#defineprops-defineemits) macro</span><span class=\"options-api\">[`emits`](/api/options-state#emits) option</span>:\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\ndefineEmits(['inFocus', 'submit'])\n</script>\n```\n\nThe `$emit` method that we used in the `<template>` isn't accessible within the `<script setup>` section of a component, but `defineEmits()` returns an equivalent function that we can use instead:\n\n```vue\n<script setup>\nconst emit = defineEmits(['inFocus', 'submit'])\n\nfunction buttonClick() {\n  emit('submit')\n}\n</script>\n```\n\nThe `defineEmits()` macro **cannot** be used inside a function, it must be placed directly within `<script setup>`, as in the example above.\n\nIf you're using an explicit `setup` function instead of `<script setup>`, events should be declared using the [`emits`](/api/options-state#emits) option, and the `emit` function is exposed on the `setup()` context:\n\n```js\nexport default {\n  emits: ['inFocus', 'submit'],\n  setup(props, ctx) {\n    ctx.emit('submit')\n  }\n}\n```\n\nAs with other properties of the `setup()` context, `emit` can safely be destructured:\n\n```js\nexport default {\n  emits: ['inFocus', 'submit'],\n  setup(props, { emit }) {\n    emit('submit')\n  }\n}\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  emits: ['inFocus', 'submit']\n}\n```\n\n</div>\n\nThe `emits` option also supports an object syntax, which allows us to perform runtime validation of the payload of the emitted events:\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nconst emit = defineEmits({\n  submit(payload) {\n    // return `true` or `false` to indicate\n    // validation pass / fail\n  }\n})\n</script>\n```\n\nIf you are using TypeScript with `<script setup>`, it's also possible to declare emitted events using pure type annotations:\n\n```vue\n<script setup lang=\"ts\">\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n</script>\n```\n\nMore details: [Typing Component Emits](/guide/typescript/composition-api#typing-component-emits) <sup class=\"vt-badge ts\" />\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  emits: {\n    submit(payload) {\n      // return `true` or `false` to indicate\n      // validation pass / fail\n    }\n  }\n}\n```\n\nSee also: [Typing Component Emits](/guide/typescript/options-api#typing-component-emits) <sup class=\"vt-badge ts\" />\n\n</div>\n\nAlthough optional, it is recommended to define all emitted events in order to better document how a component should work. It also allows Vue to exclude known listeners from [fallthrough attributes](/guide/components/attrs#v-on-listener-inheritance), avoiding edge cases caused by DOM events manually dispatched by 3rd party code.\n\n:::tip\nIf a native event (e.g., `click`) is defined in the `emits` option, the listener will now only listen to component-emitted `click` events and no longer respond to native `click` events.\n:::\n\n## Events Validation {#events-validation}\n\nSimilar to prop type validation, an emitted event can be validated if it is defined with the object syntax instead of the array syntax.\n\nTo add validation, the event is assigned a function that receives the arguments passed to the <span class=\"options-api\">`this.$emit`</span><span class=\"composition-api\">`emit`</span> call and returns a boolean to indicate whether the event is valid or not.\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nconst emit = defineEmits({\n  // No validation\n  click: null,\n\n  // Validate submit event\n  submit: ({ email, password }) => {\n    if (email && password) {\n      return true\n    } else {\n      console.warn('Invalid submit event payload!')\n      return false\n    }\n  }\n})\n\nfunction submitForm(email, password) {\n  emit('submit', { email, password })\n}\n</script>\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  emits: {\n    // No validation\n    click: null,\n\n    // Validate submit event\n    submit: ({ email, password }) => {\n      if (email && password) {\n        return true\n      } else {\n        console.warn('Invalid submit event payload!')\n        return false\n      }\n    }\n  },\n  methods: {\n    submitForm(email, password) {\n      this.$emit('submit', { email, password })\n    }\n  }\n}\n```\n\n</div>",
          "questions": [
            "What is the purpose of the `$emit` method in Vue components?",
            "How can a parent component listen to a custom event emitted by a child component?",
            "Is it possible to use the `.once` modifier on component event listeners? If so, how?",
            "Do component emitted events bubble like native DOM events? Explain.",
            "How can extra arguments be passed to `$emit` when emitting an event?",
            "Can a component explicitly declare the events it will emit? If so, how?",
            "What is the purpose of the `emits` option in Vue components?",
            "How can emitted events be validated in Vue components?",
            "Is it recommended to define all emitted events in a Vue component? Why or why not?",
            "How can an outdated link be redirected to a new page in Vue?"
          ]
        }
      ]
    }
  ]
}
