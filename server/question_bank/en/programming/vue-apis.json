{
  "question_type": "short",
  "designated_role": "examiner",
  "icon": "mdi-vuejs",
  "description": "The core API details of Vue 3 framework explain how to use these APIs to create and manage Vue components, handle state, lifecycle hooks, and so on",
  "link": "https://vuejs.org/api/",
  "total_question_count": 200,
  "files": [
    {
      "file_name": "utility-types.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Utility Types {#utility-types}\n\n:::info\nThis page only lists a few commonly used utility types that may need explanation for their usage. For a full list of exported types, consult the [source code](https://github.com/vuejs/core/blob/main/packages/runtime-core/src/index.ts#L131).\n:::\n\n## PropType\\<T> {#proptype-t}\n\nUsed to annotate a prop with more advanced types when using runtime props declarations.\n\n- **Example**\n\n  ```ts\n  import type { PropType } from 'vue'\n\n  interface Book {\n    title: string\n    author: string\n    year: number\n  }\n\n  export default {\n    props: {\n      book: {\n        // provide more specific type to `Object`\n        type: Object as PropType<Book>,\n        required: true\n      }\n    }\n  }\n  ```\n\n- **See also** [Guide - Typing Component Props](/guide/typescript/options-api#typing-component-props)\n\n## MaybeRef\\<T> {#mayberef}\n\nAlias for `T | Ref<T>`. Useful for annotating arguments of [Composables](/guide/reusability/composables.html).\n\n- Only supported in 3.3+.\n\n## MaybeRefOrGetter\\<T> {#maybereforgetter}\n\nAlias for `T | Ref<T> | (() => T)`. Useful for annotating arguments of [Composables](/guide/reusability/composables.html).\n\n- Only supported in 3.3+.\n\n## ExtractPropTypes\\<T> {#extractproptypes}\n\nExtract prop types from a runtime props options object. The extracted types are internal facing - i.e. the resolved props received by the component. This means boolean props and props with default values are always defined, even if they are not required.\n\nTo extract public facing props, i.e. props that the parent is allowed to pass, use [`ExtractPublicPropTypes`](#extractpublicproptypes).\n\n- **Example**\n\n  ```ts\n  const propsOptions = {\n    foo: String,\n    bar: Boolean,\n    baz: {\n      type: Number,\n      required: true\n    },\n    qux: {\n      type: Number,\n      default: 1\n    }\n  } as const\n\n  type Props = ExtractPropTypes<typeof propsOptions>\n  // {\n  //   foo?: string,\n  //   bar: boolean,\n  //   baz: number,\n  //   qux: number\n  // }\n  ```\n\n## ExtractPublicPropTypes\\<T> {#extractpublicproptypes}\n\nExtract prop types from a runtime props options object. The extracted types are public facing - i.e. the props that the parent is allowed to pass.\n\n- **Example**\n\n  ```ts\n  const propsOptions = {\n    foo: String,\n    bar: Boolean,\n    baz: {\n      type: Number,\n      required: true\n    },\n    qux: {\n      type: Number,\n      default: 1\n    }\n  } as const\n\n  type Props = ExtractPublicPropTypes<typeof propsOptions>\n  // {\n  //   foo?: string,\n  //   bar?: boolean,\n  //   baz: number,\n  //   qux?: number\n  // }\n  ```\n\n## ComponentCustomProperties {#componentcustomproperties}\n\nUsed to augment the component instance type to support custom global properties.\n\n- **Example**\n\n  ```ts\n  import axios from 'axios'\n\n  declare module 'vue' {\n    interface ComponentCustomProperties {\n      $http: typeof axios\n      $translate: (key: string) => string\n    }\n  }\n  ```\n\n  :::tip\n  Augmentations must be placed in a module `.ts` or `.d.ts` file. See [Type Augmentation Placement](/guide/typescript/options-api#augmenting-global-properties) for more details.\n  :::\n\n- **See also** [Guide - Augmenting Global Properties](/guide/typescript/options-api#augmenting-global-properties)\n\n## ComponentCustomOptions {#componentcustomoptions}\n\nUsed to augment the component options type to support custom options.\n\n- **Example**\n\n  ```ts\n  import { Route } from 'vue-router'\n\n  declare module 'vue' {\n    interface ComponentCustomOptions {\n      beforeRouteEnter?(to: any, from: any, next: () => void): void\n    }\n  }\n  ```\n\n  :::tip\n  Augmentations must be placed in a module `.ts` or `.d.ts` file. See [Type Augmentation Placement](/guide/typescript/options-api#augmenting-global-properties) for more details.\n  :::\n\n- **See also** [Guide - Augmenting Custom Options](/guide/typescript/options-api#augmenting-custom-options)\n\n## ComponentCustomProps {#componentcustomprops}\n\nUsed to augment allowed TSX props in order to use non-declared props on TSX elements.\n\n- **Example**\n\n  ```ts\n  declare module 'vue' {\n    interface ComponentCustomProps {\n      hello?: string\n    }\n  }\n\n  export {}\n  ```\n\n  ```tsx\n  // now works even if hello is not a declared prop\n  <MyComponent hello=\"world\" />\n  ```\n\n  :::tip\n  Augmentations must be placed in a module `.ts` or `.d.ts` file. See [Type Augmentation Placement](/guide/typescript/options-api#augmenting-global-properties) for more details.\n  :::\n\n## CSSProperties {#cssproperties}\n\nUsed to augment allowed values in style property bindings.\n\n- **Example**\n\n  Allow any custom CSS property\n\n  ```ts\n  declare module 'vue' {\n    interface CSSProperties {\n      [key: `--${string}`]: string\n    }\n  }\n  ```\n\n  ```tsx\n  <div style={ { '--bg-color': 'blue' } }>\n  ```\n\n  ```html\n  <div :style=\"{ '--bg-color': 'blue' }\"></div>\n  ```\n\n:::tip\nAugmentations must be placed in a module `.ts` or `.d.ts` file. See [Type Augmentation Placement](/guide/typescript/options-api#augmenting-global-properties) for more details.\n:::\n\n:::info See also\nSFC `<style>` tags support linking CSS values to dynamic component state using the `v-bind` CSS function. This allows for custom properties without type augmentation.\n\n- [v-bind() in CSS](/api/sfc-css-features#v-bind-in-css)\n  :::",
          "questions": [
            "What is the purpose of the `PropType<T>` utility type?",
            "Can you provide an example of using `PropType<T>` to annotate a prop?",
            "What is the `MaybeRef<T>` utility type used for?",
            "What is the difference between `MaybeRef<T>` and `MaybeRefOrGetter<T>`?",
            "What is the purpose of the `ExtractPropTypes<T>` utility type?",
            "How can you extract public facing props using `ExtractPublicPropTypes<T>`?",
            "What is the `ComponentCustomProperties` utility type used for?",
            "Can you provide an example of using `ComponentCustomProperties` to add custom global properties?",
            "What is the `CSSProperties` utility type used for?",
            "Can you provide an example of using `CSSProperties` to allow custom CSS properties in style bindings?"
          ]
        }
      ]
    },
    {
      "file_name": "application.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# Application API {#application-api}\n\n## createApp() {#createapp}\n\nCreates an application instance.\n\n- **Type**\n\n  ```ts\n  function createApp(rootComponent: Component, rootProps?: object): App\n  ```\n\n- **Details**\n\n  The first argument is the root component. The second optional argument is the props to be passed to the root component.\n\n- **Example**\n\n  With inline root component:\n\n  ```js\n  import { createApp } from 'vue'\n\n  const app = createApp({\n    /* root component options */\n  })\n  ```\n\n  With imported component:\n\n  ```js\n  import { createApp } from 'vue'\n  import App from './App.vue'\n\n  const app = createApp(App)\n  ```\n\n- **See also** [Guide - Creating a Vue Application](/guide/essentials/application)\n\n## createSSRApp() {#createssrapp}\n\nCreates an application instance in [SSR Hydration](/guide/scaling-up/ssr#client-hydration) mode. Usage is exactly the same as `createApp()`.\n\n## app.mount() {#app-mount}\n\nMounts the application instance in a container element.\n\n- **Type**\n\n  ```ts\n  interface App {\n    mount(rootContainer: Element | string): ComponentPublicInstance\n  }\n  ```\n\n- **Details**\n\n  The argument can either be an actual DOM element or a CSS selector (the first matched element will be used). Returns the root component instance.\n\n  If the component has a template or a render function defined, it will replace any existing DOM nodes inside the container. Otherwise, if the runtime compiler is available, the `innerHTML` of the container will be used as the template.\n\n  In SSR hydration mode, it will hydrate the existing DOM nodes inside the container. If there are [mismatches](/guide/scaling-up/ssr#hydration-mismatch), the existing DOM nodes will be morphed to match the expected output.\n\n  For each app instance, `mount()` can only be called once.\n\n- **Example**\n\n  ```js\n  import { createApp } from 'vue'\n  const app = createApp(/* ... */)\n\n  app.mount('#app')\n  ```\n\n  Can also mount to an actual DOM element:\n\n  ```js\n  app.mount(document.body.firstChild)\n  ```\n\n## app.unmount() {#app-unmount}\n\nUnmounts a mounted application instance, triggering the unmount lifecycle hooks for all components in the application's component tree.\n\n- **Type**\n\n  ```ts\n  interface App {\n    unmount(): void\n  }\n  ```\n\n## app.component() {#app-component}\n\nRegisters a global component if passing both a name string and a component definition, or retrieves an already registered one if only the name is passed.\n\n- **Type**\n\n  ```ts\n  interface App {\n    component(name: string): Component | undefined\n    component(name: string, component: Component): this\n  }\n  ```\n\n- **Example**\n\n  ```js\n  import { createApp } from 'vue'\n\n  const app = createApp({})\n\n  // register an options object\n  app.component('my-component', {\n    /* ... */\n  })\n\n  // retrieve a registered component\n  const MyComponent = app.component('my-component')\n  ```\n\n- **See also** [Component Registration](/guide/components/registration)\n\n## app.directive() {#app-directive}\n\nRegisters a global custom directive if passing both a name string and a directive definition, or retrieves an already registered one if only the name is passed.\n\n- **Type**\n\n  ```ts\n  interface App {\n    directive(name: string): Directive | undefined\n    directive(name: string, directive: Directive): this\n  }\n  ```\n\n- **Example**\n\n  ```js\n  import { createApp } from 'vue'\n\n  const app = createApp({\n    /* ... */\n  })\n\n  // register (object directive)\n  app.directive('my-directive', {\n    /* custom directive hooks */\n  })\n\n  // register (function directive shorthand)\n  app.directive('my-directive', () => {\n    /* ... */\n  })\n\n  // retrieve a registered directive\n  const myDirective = app.directive('my-directive')\n  ```\n\n- **See also** [Custom Directives](/guide/reusability/custom-directives)\n\n## app.use() {#app-use}\n\nInstalls a [plugin](/guide/reusability/plugins).\n\n- **Type**\n\n  ```ts\n  interface App {\n    use(plugin: Plugin, ...options: any[]): this\n  }\n  ```\n\n- **Details**\n\n  Expects the plugin as the first argument, and optional plugin options as the second argument.\n\n  The plugin can either be an object with an `install()` method, or just a function that will be used as the `install()` method. The options (second argument of `app.use()`) will be passed along to the plugin's `install()` method.\n\n  When `app.use()` is called on the same plugin multiple times, the plugin will be installed only once.\n\n- **Example**\n\n  ```js\n  import { createApp } from 'vue'\n  import MyPlugin from './plugins/MyPlugin'\n\n  const app = createApp({\n    /* ... */\n  })\n\n  app.use(MyPlugin)\n  ```\n\n- **See also** [Plugins](/guide/reusability/plugins)\n\n## app.mixin() {#app-mixin}\n\nApplies a global mixin (scoped to the application). A global mixin applies its included options to every component instance in the application.\n\n:::warning Not Recommended\nMixins are supported in Vue 3 mainly for backwards compatibility, due to their widespread use in ecosystem libraries. Use of mixins, especially global mixins, should be avoided in application code.\n\nFor logic reuse, prefer [Composables](/guide/reusability/composables) instead.\n:::\n\n- **Type**\n\n  ```ts\n  interface App {\n    mixin(mixin: ComponentOptions): this\n  }\n  ```\n\n## app.provide() {#app-provide}\n\nProvide a value that can be injected in all descendant components within the application.\n\n- **Type**\n\n  ```ts\n  interface App {\n    provide<T>(key: InjectionKey<T> | symbol | string, value: T): this\n  }\n  ```\n\n- **Details**\n\n  Expects the injection key as the first argument, and the provided value as the second. Returns the application instance itself.\n\n- **Example**\n\n  ```js\n  import { createApp } from 'vue'\n\n  const app = createApp(/* ... */)\n\n  app.provide('message', 'hello')\n  ```\n\n  Inside a component in the application:\n\n  <div class=\"composition-api\">\n\n  ```js\n  import { inject } from 'vue'\n\n  export default {\n    setup() {\n      console.log(inject('message')) // 'hello'\n    }\n  }\n  ```\n\n  </div>\n  <div class=\"options-api\">\n\n  ```js\n  export default {\n    inject: ['message'],\n    created() {\n      console.log(this.message) // 'hello'\n    }\n  }\n  ```\n\n  </div>\n\n- **See also**\n  - [Provide / Inject](/guide/components/provide-inject)\n  - [App-level Provide](/guide/components/provide-inject#app-level-provide)\n  - [app.runWithContext()](#app-runwithcontext)\n\n## app.runWithContext()<sup class=\"vt-badge\" data-text=\"3.3+\" /> {#app-runwithcontext}\n\nExecute a callback with the current app as injection context.\n\n- **Type**\n\n  ```ts\n  interface App {\n    runWithContext<T>(fn: () => T): T\n  }\n  ```\n\n- **Details**\n\n  Expects a callback function and runs the callback immediately. During the synchronous call of the callback,  `inject()` calls are able to look up injections from the values provided by the current app, even when there is no current active component instance. The return value of the callback will also be returned.\n\n- **Example**\n\n  ```js\n  import { inject } from 'vue'\n\n  app.provide('id', 1)\n\n  const injected = app.runWithContext(() => {\n    return inject('id')\n  })\n\n  console.log(injected) // 1\n  ```\n\n## app.version {#app-version}\n\nProvides the version of Vue that the application was created with. This is useful inside [plugins](/guide/reusability/plugins), where you might need conditional logic based on different Vue versions.\n\n- **Type**\n\n  ```ts\n  interface App {\n    version: string\n  }\n  ```\n\n- **Example**\n\n  Performing a version check inside a plugin:\n\n  ```js\n  export default {\n    install(app) {\n      const version = Number(app.version.split('.')[0])\n      if (version < 3) {\n        console.warn('This plugin requires Vue 3')\n      }\n    }\n  }\n  ```\n\n- **See also** [Global API - version](/api/general#version)\n\n## app.config {#app-config}\n\nEvery application instance exposes a `config` object that contains the configuration settings for that application. You can modify its properties (documented below) before mounting your application.\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp(/* ... */)\n\nconsole.log(app.config)\n```\n\n## app.config.errorHandler {#app-config-errorhandler}\n\nAssign a global handler for uncaught errors propagating from within the application.\n\n- **Type**\n\n  ```ts\n  interface AppConfig {\n    errorHandler?: (\n      err: unknown,\n      instance: ComponentPublicInstance | null,\n      // `info` is a Vue-specific error info,\n      // e.g. which lifecycle hook the error was thrown in\n      info: string\n    ) => void\n  }\n  ```\n\n- **Details**\n\n  The error handler receives three arguments: the error, the component instance that triggered the error, and an information string specifying the error source type.\n\n  It can capture errors from the following sources:\n\n  - Component renders\n  - Event handlers\n  - Lifecycle hooks\n  - `setup()` function\n  - Watchers\n  - Custom directive hooks\n  - Transition hooks\n\n- **Example**\n\n  ```js\n  app.config.errorHandler = (err, instance, info) => {\n    // handle error, e.g. report to a service\n  }\n  ```\n\n## app.config.warnHandler {#app-config-warnhandler}\n\nAssign a custom handler for runtime warnings from Vue.\n\n- **Type**\n\n  ```ts\n  interface AppConfig {\n    warnHandler?: (\n      msg: string,\n      instance: ComponentPublicInstance | null,\n      trace: string\n    ) => void\n  }\n  ```\n\n- **Details**\n\n  The warning handler receives the warning message as the first argument, the source component instance as the second argument, and a component trace string as the third.\n\n  It can be used to filter out specific warnings to reduce console verbosity. All Vue warnings should be addressed during development, so this is only recommended during debug sessions to focus on specific warnings among many, and should be removed once the debugging is done.\n\n  :::tip\n  Warnings only work during development, so this config is ignored in production mode.\n  :::\n\n- **Example**\n\n  ```js\n  app.config.warnHandler = (msg, instance, trace) => {\n    // `trace` is the component hierarchy trace\n  }\n  ```\n\n## app.config.performance {#app-config-performance}\n\nSet this to `true` to enable component init, compile, render and patch performance tracing in the browser devtool performance/timeline panel. Only works in development mode and in browsers that support the [performance.mark](https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark) API.\n\n- **Type:** `boolean`\n\n- **See also** [Guide - Performance](/guide/best-practices/performance)",
          "questions": [
            "What is the purpose of the `createApp()` function in the Application API?",
            "What arguments does the `createApp()` function take?",
            "What is the difference between `createApp()` and `createSSRApp()`?",
            "What is the purpose of the `mount()` function in the Application API?",
            "What arguments does the `mount()` function take?",
            "What happens if the component has a template or a render function defined in the `mount()` function?",
            "What is the purpose of the `unmount()` function in the Application API?",
            "What is the purpose of the `component()` function in the Application API?",
            "What is the purpose of the `directive()` function in the Application API?",
            "What is the purpose of the `use()` function in the Application API?"
          ]
        },
        {
          "content": "## app.config.compilerOptions {#app-config-compileroptions}\n\nConfigure runtime compiler options. Values set on this object will be passed to the in-browser template compiler and affect every component in the configured app. Note you can also override these options on a per-component basis using the [`compilerOptions` option](/api/options-rendering#compileroptions).\n\n::: warning Important\nThis config option is only respected when using the full build (i.e. the standalone `vue.js` that can compile templates in the browser). If you are using the runtime-only build with a build setup, compiler options must be passed to `@vue/compiler-dom` via build tool configurations instead.\n\n- For `vue-loader`: [pass via the `compilerOptions` loader option](https://vue-loader.vuejs.org/options.html#compileroptions). Also see [how to configure it in `vue-cli`](https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader).\n\n- For `vite`: [pass via `@vitejs/plugin-vue` options](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#options).\n  :::\n\n### app.config.compilerOptions.isCustomElement {#app-config-compileroptions-iscustomelement}\n\nSpecifies a check method to recognize native custom elements.\n\n- **Type:** `(tag: string) => boolean`\n\n- **Details**\n\n  Should return `true` if the tag should be treated as a native custom element. For a matched tag, Vue will render it as a native element instead of attempting to resolve it as a Vue component.\n\n  Native HTML and SVG tags don't need to be matched in this function - Vue's parser recognizes them automatically.\n\n- **Example**\n\n  ```js\n  // treat all tags starting with 'ion-' as custom elements\n  app.config.compilerOptions.isCustomElement = (tag) => {\n    return tag.startsWith('ion-')\n  }\n  ```\n\n- **See also** [Vue and Web Components](/guide/extras/web-components)\n\n### app.config.compilerOptions.whitespace {#app-config-compileroptions-whitespace}\n\nAdjusts template whitespace handling behavior.\n\n- **Type:** `'condense' | 'preserve'`\n\n- **Default:** `'condense'`\n\n- **Details**\n\n  Vue removes / condenses whitespace characters in templates to produce more efficient compiled output. The default strategy is \"condense\", with the following behavior:\n\n  1. Leading / ending whitespace characters inside an element are condensed into a single space.\n  2. Whitespace characters between elements that contain newlines are removed.\n  3. Consecutive whitespace characters in text nodes are condensed into a single space.\n\n  Setting this option to `'preserve'` will disable (2) and (3).\n\n- **Example**\n\n  ```js\n  app.config.compilerOptions.whitespace = 'preserve'\n  ```\n\n### app.config.compilerOptions.delimiters {#app-config-compileroptions-delimiters}\n\nAdjusts the delimiters used for text interpolation within the template.\n\n- **Type:** `[string, string]`\n\n- **Default:** `{{ \"['\\u007b\\u007b', '\\u007d\\u007d']\" }}`\n\n- **Details**\n\n  This is typically used to avoid conflicting with server-side frameworks that also use mustache syntax.\n\n- **Example**\n\n  ```js\n  // Delimiters changed to ES6 template string style\n  app.config.compilerOptions.delimiters = ['${', '}']\n  ```\n\n### app.config.compilerOptions.comments {#app-config-compileroptions-comments}\n\nAdjusts treatment of HTML comments in templates.\n\n- **Type:** `boolean`\n\n- **Default:** `false`\n\n- **Details**\n\n  By default, Vue will remove the comments in production. Setting this option to `true` will force Vue to preserve comments even in production. Comments are always preserved during development. This option is typically used when Vue is used with other libraries that rely on HTML comments.\n\n- **Example**\n\n  ```js\n  app.config.compilerOptions.comments = true\n  ```\n\n## app.config.globalProperties {#app-config-globalproperties}\n\nAn object that can be used to register global properties that can be accessed on any component instance inside the application.\n\n- **Type**\n\n  ```ts\n  interface AppConfig {\n    globalProperties: Record<string, any>\n  }\n  ```\n\n- **Details**\n\n  This is a replacement of Vue 2's `Vue.prototype` which is no longer present in Vue 3. As with anything global, this should be used sparingly.\n\n  If a global property conflicts with a component\u2019s own property, the component's own property will have higher priority.\n\n- **Usage**\n\n  ```js\n  app.config.globalProperties.msg = 'hello'\n  ```\n\n  This makes `msg` available inside any component template in the application, and also on `this` of any component instance:\n\n  ```js\n  export default {\n    mounted() {\n      console.log(this.msg) // 'hello'\n    }\n  }\n  ```\n\n- **See also** [Guide - Augmenting Global Properties](/guide/typescript/options-api#augmenting-global-properties) <sup class=\"vt-badge ts\" />\n\n## app.config.optionMergeStrategies {#app-config-optionmergestrategies}\n\nAn object for defining merging strategies for custom component options.\n\n- **Type**\n\n  ```ts\n  interface AppConfig {\n    optionMergeStrategies: Record<string, OptionMergeFunction>\n  }\n\n  type OptionMergeFunction = (to: unknown, from: unknown) => any\n  ```\n\n- **Details**\n\n  Some plugins / libraries add support for custom component options (by injecting global mixins). These options may require special merging logic when the same option needs to be \"merged\" from multiple sources (e.g. mixins or component inheritance).\n\n  A merge strategy function can be registered for a custom option by assigning it on the `app.config.optionMergeStrategies` object using the option's name as the key.\n\n  The merge strategy function receives the value of that option defined on the parent and child instances as the first and second arguments, respectively.\n\n- **Example**\n\n  ```js\n  const app = createApp({\n    // option from self\n    msg: 'Vue',\n    // option from a mixin\n    mixins: [\n      {\n        msg: 'Hello '\n      }\n    ],\n    mounted() {\n      // merged options exposed on this.$options\n      console.log(this.$options.msg)\n    }\n  })\n\n  // define a custom merge strategy for `msg`\n  app.config.optionMergeStrategies.msg = (parent, child) => {\n    return (parent || '') + (child || '')\n  }\n\n  app.mount('#app')\n  // logs 'Hello Vue'\n  ```\n\n- **See also** [Component Instance - `$options`](/api/component-instance#options)",
          "questions": [
            "What is the purpose of `app.config.compilerOptions`?",
            "How does setting `app.config.compilerOptions.isCustomElement` affect Vue's rendering of components?",
            "What is the default value of `app.config.compilerOptions.whitespace`?",
            "How can you disable the removal/condensing of whitespace characters in templates?",
            "What is the purpose of `app.config.compilerOptions.delimiters`?",
            "How can you change the delimiters used for text interpolation within the template?",
            "What is the default behavior of Vue regarding HTML comments in templates?",
            "How can you force Vue to preserve comments even in production?",
            "What is the purpose of `app.config.globalProperties`?",
            "How can you register a global property using `app.config.globalProperties`?"
          ]
        }
      ]
    },
    {
      "file_name": "reactivity-utilities.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Reactivity API: Utilities {#reactivity-api-utilities}\n\n## isRef() {#isref}\n\nChecks if a value is a ref object.\n\n- **Type**\n\n  ```ts\n  function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\n  ```\n\n  Note the return type is a [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), which means `isRef` can be used as a type guard:\n\n  ```ts\n  let foo: unknown\n  if (isRef(foo)) {\n    // foo's type is narrowed to Ref<unknown>\n    foo.value\n  }\n  ```\n\n## unref() {#unref}\n\nReturns the inner value if the argument is a ref, otherwise return the argument itself. This is a sugar function for `val = isRef(val) ? val.value : val`.\n\n- **Type**\n\n  ```ts\n  function unref<T>(ref: T | Ref<T>): T\n  ```\n\n- **Example**\n\n  ```ts\n  function useFoo(x: number | Ref<number>) {\n    const unwrapped = unref(x)\n    // unwrapped is guaranteed to be number now\n  }\n  ```\n\n## toRef() {#toref}\n\nCan be used to normalize values / refs / getters into refs (3.3+).\n\nCan also be used to create a ref for a property on a source reactive object. The created ref is synced with its source property: mutating the source property will update the ref, and vice-versa.\n\n- **Type**\n\n  ```ts\n  // normalization signature (3.3+)\n  function toRef<T>(\n    value: T\n  ): T extends () => infer R\n    ? Readonly<Ref<R>>\n    : T extends Ref\n    ? T\n    : Ref<UnwrapRef<T>>\n\n  // object property signature\n  function toRef<T extends object, K extends keyof T>(\n    object: T,\n    key: K,\n    defaultValue?: T[K]\n  ): ToRef<T[K]>\n\n  type ToRef<T> = T extends Ref ? T : Ref<T>\n  ```\n\n- **Example**\n\n  Normalization signature (3.3+):\n\n  ```js\n  // returns existing refs as-is\n  toRef(existingRef)\n\n  // creates a readonly ref that calls the getter on .value access\n  toRef(() => props.foo)\n\n  // creates normal refs from non-function values\n  // equivalent to ref(1)\n  toRef(1)\n  ```\n\n  Object property signature:\n\n  ```js\n  const state = reactive({\n    foo: 1,\n    bar: 2\n  })\n\n  // a two-way ref that syncs with the original property\n  const fooRef = toRef(state, 'foo')\n\n  // mutating the ref updates the original\n  fooRef.value++\n  console.log(state.foo) // 2\n\n  // mutating the original also updates the ref\n  state.foo++\n  console.log(fooRef.value) // 3\n  ```\n\n  Note this is different from:\n\n  ```js\n  const fooRef = ref(state.foo)\n  ```\n\n  The above ref is **not** synced with `state.foo`, because the `ref()` receives a plain number value.\n\n  `toRef()` is useful when you want to pass the ref of a prop to a composable function:\n\n  ```vue\n  <script setup>\n  import { toRef } from 'vue'\n\n  const props = defineProps(/* ... */)\n\n  // convert `props.foo` into a ref, then pass into\n  // a composable\n  useSomeFeature(toRef(props, 'foo'))\n\n  // getter syntax - recommended in 3.3+\n  useSomeFeature(toRef(() => props.foo))\n  </script>\n  ```\n\n  When `toRef` is used with component props, the usual restrictions around mutating the props still apply. Attempting to assign a new value to the ref is equivalent to trying to modify the prop directly and is not allowed. In that scenario you may want to consider using [`computed`](./reactivity-core#computed) with `get` and `set` instead. See the guide to [using `v-model` with components](/guide/components/v-model) for more information.\n\n  When using the object property signature, `toRef()` will return a usable ref even if the source property doesn't currently exist. This makes it possible to work with optional properties, which wouldn't be picked up by [`toRefs`](#torefs).\n\n## toValue() <sup class=\"vt-badge\" data-text=\"3.3+\" /> {#tovalue}\n\nNormalizes values / refs / getters to values. This is similar to [unref()](#unref), except that it also normalizes getters. If the argument is a getter, it will be invoked and its return value will be returned.\n\nThis can be used in [Composables](/guide/reusability/composables.html) to normalize an argument that can be either a value, a ref, or a getter.\n\n- **Type**\n\n  ```ts\n  function toValue<T>(source: T | Ref<T> | (() => T)): T\n  ```\n\n- **Example**\n\n  ```js\n  toValue(1) //       --> 1\n  toValue(ref(1)) //  --> 1\n  toValue(() => 1) // --> 1\n  ```\n\n  Normalizing arguments in composables:\n\n  ```ts\n  import type { MaybeRefOrGetter } from 'vue'\n\n  function useFeature(id: MaybeRefOrGetter<number>) {\n    watch(() => toValue(id), id => {\n      // react to id changes\n    })\n  }\n\n  // this composable supports any of the following:\n  useFeature(1)\n  useFeature(ref(1))\n  useFeature(() => 1)\n  ```\n\n## toRefs() {#torefs}\n\nConverts a reactive object to a plain object where each property of the resulting object is a ref pointing to the corresponding property of the original object. Each individual ref is created using [`toRef()`](#toref).\n\n- **Type**\n\n  ```ts\n  function toRefs<T extends object>(\n    object: T\n  ): {\n    [K in keyof T]: ToRef<T[K]>\n  }\n\n  type ToRef = T extends Ref ? T : Ref<T>\n  ```\n\n- **Example**\n\n  ```js\n  const state = reactive({\n    foo: 1,\n    bar: 2\n  })\n\n  const stateAsRefs = toRefs(state)\n  /*\n  Type of stateAsRefs: {\n    foo: Ref<number>,\n    bar: Ref<number>\n  }\n  */\n\n  // The ref and the original property is \"linked\"\n  state.foo++\n  console.log(stateAsRefs.foo.value) // 2\n\n  stateAsRefs.foo.value++\n  console.log(state.foo) // 3\n  ```\n\n  `toRefs` is useful when returning a reactive object from a composable function so that the consuming component can destructure/spread the returned object without losing reactivity:\n\n  ```js\n  function useFeatureX() {\n    const state = reactive({\n      foo: 1,\n      bar: 2\n    })\n\n    // ...logic operating on state\n\n    // convert to refs when returning\n    return toRefs(state)\n  }\n\n  // can destructure without losing reactivity\n  const { foo, bar } = useFeatureX()\n  ```\n\n  `toRefs` will only generate refs for properties that are enumerable on the source object at call time. To create a ref for a property that may not exist yet, use [`toRef`](#toref) instead.\n\n## isProxy() {#isproxy}\n\nChecks if an object is a proxy created by [`reactive()`](./reactivity-core#reactive), [`readonly()`](./reactivity-core#readonly), [`shallowReactive()`](./reactivity-advanced#shallowreactive) or [`shallowReadonly()`](./reactivity-advanced#shallowreadonly).\n\n- **Type**\n\n  ```ts\n  function isProxy(value: unknown): boolean\n  ```\n\n## isReactive() {#isreactive}\n\nChecks if an object is a proxy created by [`reactive()`](./reactivity-core#reactive) or [`shallowReactive()`](./reactivity-advanced#shallowreactive).\n\n- **Type**\n\n  ```ts\n  function isReactive(value: unknown): boolean\n  ```\n\n## isReadonly() {#isreadonly}\n\nChecks whether the passed value is a readonly object. The properties of a readonly object can change, but they can't be assigned directly via the passed object.\n\nThe proxies created by [`readonly()`](./reactivity-core#readonly) and [`shallowReadonly()`](./reactivity-advanced#shallowreadonly) are both considered readonly, as is a [`computed()`](./reactivity-core#computed) ref without a `set` function.\n\n- **Type**\n\n  ```ts\n  function isReadonly(value: unknown): boolean\n  ```",
          "questions": [
            "What is the purpose of the `isRef()` function in the Reactivity API Utilities?",
            "Can `isRef()` be used as a type guard? If so, how?",
            "What does the `unref()` function do in the Reactivity API Utilities?",
            "What is the return type of the `unref()` function?",
            "Can you provide an example of how to use the `unref()` function?",
            "What is the purpose of the `toRef()` function in the Reactivity API Utilities?",
            "What are the two signatures of the `toRef()` function?",
            "How can `toRef()` be used to create a ref for a property on a source reactive object?",
            "What is the purpose of the `toRefs()` function in the Reactivity API Utilities?",
            "Can you provide an example of how to use the `toRefs()` function?"
          ]
        }
      ]
    },
    {
      "file_name": "reactivity-advanced.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Reactivity API: Advanced {#reactivity-api-advanced}\n\n## shallowRef() {#shallowref}\n\nShallow version of [`ref()`](./reactivity-core#ref).\n\n- **Type**\n\n  ```ts\n  function shallowRef<T>(value: T): ShallowRef<T>\n\n  interface ShallowRef<T> {\n    value: T\n  }\n  ```\n\n- **Details**\n\n  Unlike `ref()`, the inner value of a shallow ref is stored and exposed as-is, and will not be made deeply reactive. Only the `.value` access is reactive.\n\n  `shallowRef()` is typically used for performance optimizations of large data structures, or integration with external state management systems.\n\n- **Example**\n\n  ```js\n  const state = shallowRef({ count: 1 })\n\n  // does NOT trigger change\n  state.value.count = 2\n\n  // does trigger change\n  state.value = { count: 2 }\n  ```\n\n- **See also**\n  - [Guide - Reduce Reactivity Overhead for Large Immutable Structures](/guide/best-practices/performance#reduce-reactivity-overhead-for-large-immutable-structures)\n  - [Guide - Integration with External State Systems](/guide/extras/reactivity-in-depth#integration-with-external-state-systems)\n\n## triggerRef() {#triggerref}\n\nForce trigger effects that depends on a [shallow ref](#shallowref). This is typically used after making deep mutations to the inner value of a shallow ref.\n\n- **Type**\n\n  ```ts\n  function triggerRef(ref: ShallowRef): void\n  ```\n\n- **Example**\n\n  ```js\n  const shallow = shallowRef({\n    greet: 'Hello, world'\n  })\n\n  // Logs \"Hello, world\" once for the first run-through\n  watchEffect(() => {\n    console.log(shallow.value.greet)\n  })\n\n  // This won't trigger the effect because the ref is shallow\n  shallow.value.greet = 'Hello, universe'\n\n  // Logs \"Hello, universe\"\n  triggerRef(shallow)\n  ```\n\n## customRef() {#customref}\n\nCreates a customized ref with explicit control over its dependency tracking and updates triggering.\n\n- **Type**\n\n  ```ts\n  function customRef<T>(factory: CustomRefFactory<T>): Ref<T>\n\n  type CustomRefFactory<T> = (\n    track: () => void,\n    trigger: () => void\n  ) => {\n    get: () => T\n    set: (value: T) => void\n  }\n  ```\n\n- **Details**\n\n  `customRef()` expects a factory function, which receives `track` and `trigger` functions as arguments and should return an object with `get` and `set` methods.\n\n  In general, `track()` should be called inside `get()`, and `trigger()` should be called inside `set()`. However, you have full control over when they should be called, or whether they should be called at all.\n\n- **Example**\n\n  Creating a debounced ref that only updates the value after a certain timeout after the latest set call:\n\n  ```js\n  import { customRef } from 'vue'\n\n  export function useDebouncedRef(value, delay = 200) {\n    let timeout\n    return customRef((track, trigger) => {\n      return {\n        get() {\n          track()\n          return value\n        },\n        set(newValue) {\n          clearTimeout(timeout)\n          timeout = setTimeout(() => {\n            value = newValue\n            trigger()\n          }, delay)\n        }\n      }\n    })\n  }\n  ```\n\n  Usage in component:\n\n  ```vue\n  <script setup>\n  import { useDebouncedRef } from './debouncedRef'\n  const text = useDebouncedRef('hello')\n  </script>\n\n  <template>\n    <input v-model=\"text\" />\n  </template>\n  ```\n\n  [Try it in the Playground](https://play.vuejs.org/#eNplUkFugzAQ/MqKC1SiIekxIpEq9QVV1BMXCguhBdsyaxqE/PcuGAhNfYGd3Z0ZDwzeq1K7zqB39OI205UiaJGMOieiapTUBAOYFt/wUxqRYf6OBVgotGzA30X5Bt59tX4iMilaAsIbwelxMfCvWNfSD+Gw3++fEhFHTpLFuCBsVJ0ScgUQjw6Az+VatY5PiroHo3IeaeHANlkrh7Qg1NBL43cILUmlMAfqVSXK40QUOSYmHAZHZO0KVkIZgu65kTnWp8Qb+4kHEXfjaDXkhd7DTTmuNZ7MsGyzDYbz5CgSgbdppOBFqqT4l0eX1gZDYOm057heOBQYRl81coZVg9LQWGr+IlrchYKAdJp9h0C6KkvUT3A6u8V1dq4ASqRgZnVnWg04/QWYNyYzC2rD5Y3/hkDgz8fY/cOT1ZjqizMZzGY3rDPC12KGZYyd3J26M8ny1KKx7c3X25q1c1wrZN3L9LCMWs/+AmeG6xI=)\n\n## shallowReactive() {#shallowreactive}\n\nShallow version of [`reactive()`](./reactivity-core#reactive).\n\n- **Type**\n\n  ```ts\n  function shallowReactive<T extends object>(target: T): T\n  ```\n\n- **Details**\n\n  Unlike `reactive()`, there is no deep conversion: only root-level properties are reactive for a shallow reactive object. Property values are stored and exposed as-is - this also means properties with ref values will **not** be automatically unwrapped.\n\n  :::warning Use with Caution\n  Shallow data structures should only be used for root level state in a component. Avoid nesting it inside a deep reactive object as it creates a tree with inconsistent reactivity behavior which can be difficult to understand and debug.\n  :::\n\n- **Example**\n\n  ```js\n  const state = shallowReactive({\n    foo: 1,\n    nested: {\n      bar: 2\n    }\n  })\n\n  // mutating state's own properties is reactive\n  state.foo++\n\n  // ...but does not convert nested objects\n  isReactive(state.nested) // false\n\n  // NOT reactive\n  state.nested.bar++\n  ```\n\n## shallowReadonly() {#shallowreadonly}\n\nShallow version of [`readonly()`](./reactivity-core#readonly).\n\n- **Type**\n\n  ```ts\n  function shallowReadonly<T extends object>(target: T): Readonly<T>\n  ```\n\n- **Details**\n\n  Unlike `readonly()`, there is no deep conversion: only root-level properties are made readonly. Property values are stored and exposed as-is - this also means properties with ref values will **not** be automatically unwrapped.\n\n  :::warning Use with Caution\n  Shallow data structures should only be used for root level state in a component. Avoid nesting it inside a deep reactive object as it creates a tree with inconsistent reactivity behavior which can be difficult to understand and debug.\n  :::\n\n- **Example**\n\n  ```js\n  const state = shallowReadonly({\n    foo: 1,\n    nested: {\n      bar: 2\n    }\n  })\n\n  // mutating state's own properties will fail\n  state.foo++\n\n  // ...but works on nested objects\n  isReadonly(state.nested) // false\n\n  // works\n  state.nested.bar++\n  ```\n\n## toRaw() {#toraw}\n\nReturns the raw, original object of a Vue-created proxy.\n\n- **Type**\n\n  ```ts\n  function toRaw<T>(proxy: T): T\n  ```\n\n- **Details**\n\n  `toRaw()` can return the original object from proxies created by [`reactive()`](./reactivity-core#reactive), [`readonly()`](./reactivity-core#readonly), [`shallowReactive()`](#shallowreactive) or [`shallowReadonly()`](#shallowreadonly).\n\n  This is an escape hatch that can be used to temporarily read without incurring proxy access / tracking overhead or write without triggering changes. It is **not** recommended to hold a persistent reference to the original object. Use with caution.\n\n- **Example**\n\n  ```js\n  const foo = {}\n  const reactiveFoo = reactive(foo)\n\n  console.log(toRaw(reactiveFoo) === foo) // true\n  ```\n\n## markRaw() {#markraw}\n\nMarks an object so that it will never be converted to a proxy. Returns the object itself.\n\n- **Type**\n\n  ```ts\n  function markRaw<T extends object>(value: T): T\n  ```\n\n- **Example**\n\n  ```js\n  const foo = markRaw({})\n  console.log(isReactive(reactive(foo))) // false\n\n  // also works when nested inside other reactive objects\n  const bar = reactive({ foo })\n  console.log(isReactive(bar.foo)) // false\n  ```\n\n  :::warning Use with Caution\n  `markRaw()` and shallow APIs such as `shallowReactive()` allow you to selectively opt-out of the default deep reactive/readonly conversion and embed raw, non-proxied objects in your state graph. They can be used for various reasons:\n\n  - Some values simply should not be made reactive, for example a complex 3rd party class instance, or a Vue component object.\n\n  - Skipping proxy conversion can provide performance improvements when rendering large lists with immutable data sources.\n\n  They are considered advanced because the raw opt-out is only at the root level, so if you set a nested, non-marked raw object into a reactive object and then access it again, you get the proxied version back. This can lead to **identity hazards** - i.e. performing an operation that relies on object identity but using both the raw and the proxied version of the same object:\n\n  ```js\n  const foo = markRaw({\n    nested: {}\n  })\n\n  const bar = reactive({\n    // although `foo` is marked as raw, foo.nested is not.\n    nested: foo.nested\n  })\n\n  console.log(foo.nested === bar.nested) // false\n  ```\n\n  Identity hazards are in general rare. However, to properly utilize these APIs while safely avoiding identity hazards requires a solid understanding of how the reactivity system works.\n\n  :::\n\n## effectScope() {#effectscope}\n\nCreates an effect scope object which can capture the reactive effects (i.e. computed and watchers) created within it so that these effects can be disposed together. For detailed use cases of this API, please consult its corresponding [RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md).\n\n- **Type**\n\n  ```ts\n  function effectScope(detached?: boolean): EffectScope\n\n  interface EffectScope {\n    run<T>(fn: () => T): T | undefined // undefined if scope is inactive\n    stop(): void\n  }\n  ```\n\n- **Example**\n\n  ```js\n  const scope = effectScope()\n\n  scope.run(() => {\n    const doubled = computed(() => counter.value * 2)\n\n    watch(doubled, () => console.log(doubled.value))\n\n    watchEffect(() => console.log('Count: ', doubled.value))\n  })\n\n  // to dispose all effects in the scope\n  scope.stop()\n  ```\n\n## getCurrentScope() {#getcurrentscope}\n\nReturns the current active [effect scope](#effectscope) if there is one.\n\n- **Type**\n\n  ```ts\n  function getCurrentScope(): EffectScope | undefined\n  ```\n\n## onScopeDispose() {#onscopedispose}\n\nRegisters a dispose callback on the current active [effect scope](#effectscope). The callback will be invoked when the associated effect scope is stopped.\n\nThis method can be used as a non-component-coupled replacement of `onUnmounted` in reusable composition functions, since each Vue component's `setup()` function is also invoked in an effect scope.\n\n- **Type**\n\n  ```ts\n  function onScopeDispose(fn: () => void): void\n  ```",
          "questions": [
            "What is the purpose of `shallowRef()` in the Reactivity API?",
            "How is the inner value of a shallow ref stored and exposed?",
            "What is the difference between `shallowRef()` and `ref()`?",
            "When is `shallowRef()` typically used?",
            "What is the purpose of `triggerRef()` in the Reactivity API?",
            "When is `triggerRef()` typically used?",
            "What is the purpose of `customRef()` in the Reactivity API?",
            "What arguments does `customRef()` expect?",
            "What is the purpose of `toRaw()` in the Reactivity API?",
            "What is the purpose of `markRaw()` in the Reactivity API?"
          ]
        }
      ]
    },
    {
      "file_name": "component-instance.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Component Instance {#component-instance}\n\n:::info\nThis page documents the built-in properties and methods exposed on the component public instance, i.e. `this`.\n\nAll properties listed on this page are readonly (except nested properties in `$data`).\n:::\n\n## $data {#data}\n\nThe object returned from the [`data`](./options-state#data) option, made reactive by the component. The component instance proxies access to the properties on its data object.\n\n- **Type**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $data: object\n  }\n  ```\n\n## $props {#props}\n\nAn object representing the component's current, resolved props.\n\n- **Type**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $props: object\n  }\n  ```\n\n- **Details**\n\n  Only props declared via the [`props`](./options-state#props) option will be included. The component instance proxies access to the properties on its props object.\n\n## $el {#el}\n\nThe root DOM node that the component instance is managing.\n\n- **Type**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $el: Node | undefined\n  }\n  ```\n\n- **Details**\n\n  `$el` will be `undefined` until the component is [mounted](./options-lifecycle#mounted).\n\n  - For components with a single root element, `$el` will point to that element.\n  - For components with text root, `$el` will point to the text node.\n  - For components with multiple root nodes, `$el` will be the placeholder DOM node that Vue uses to keep track of the component's position in the DOM (a text node, or a comment node in SSR hydration mode).\n\n  :::tip\n  For consistency, it is recommended to use [template refs](/guide/essentials/template-refs) for direct access to elements instead of relying on `$el`.\n  :::\n\n## $options {#options}\n\nThe resolved component options used for instantiating the current component instance.\n\n- **Type**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $options: ComponentOptions\n  }\n  ```\n\n- **Details**\n\n  The `$options` object exposes the resolved options for the current component and is the merge result of these possible sources:\n\n  - Global mixins\n  - Component `extends` base\n  - Component mixins\n\n  It is typically used to support custom component options:\n\n  ```js\n  const app = createApp({\n    customOption: 'foo',\n    created() {\n      console.log(this.$options.customOption) // => 'foo'\n    }\n  })\n  ```\n\n- **See also** [`app.config.optionMergeStrategies`](/api/application#app-config-optionmergestrategies)\n\n## $parent {#parent}\n\nThe parent instance, if the current instance has one. It will be `null` for the root instance itself.\n\n- **Type**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $parent: ComponentPublicInstance | null\n  }\n  ```\n\n## $root {#root}\n\nThe root component instance of the current component tree. If the current instance has no parents this value will be itself.\n\n- **Type**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $root: ComponentPublicInstance\n  }\n  ```\n\n## $slots {#slots}\n\nAn object representing the [slots](/guide/components/slots) passed by the parent component.\n\n- **Type**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $slots: { [name: string]: Slot }\n  }\n\n  type Slot = (...args: any[]) => VNode[]\n  ```\n\n- **Details**\n\n  Typically used when manually authoring [render functions](/guide/extras/render-function), but can also be used to detect whether a slot is present.\n\n  Each slot is exposed on `this.$slots` as a function that returns an array of vnodes under the key corresponding to that slot's name. The default slot is exposed as `this.$slots.default`.\n\n  If a slot is a [scoped slot](/guide/components/slots#scoped-slots), arguments passed to the slot functions are available to the slot as its slot props.\n\n- **See also** [Render Functions - Rendering Slots](/guide/extras/render-function#rendering-slots)\n\n## $refs {#refs}\n\nAn object of DOM elements and component instances, registered via [template refs](/guide/essentials/template-refs).\n\n- **Type**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $refs: { [name: string]: Element | ComponentPublicInstance | null }\n  }\n  ```\n\n- **See also**\n\n  - [Template refs](/guide/essentials/template-refs)\n  - [Special Attributes - ref](./built-in-special-attributes.md#ref)\n\n## $attrs {#attrs}\n\nAn object that contains the component's fallthrough attributes.\n\n- **Type**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $attrs: object\n  }\n  ```\n\n- **Details**\n\n  [Fallthrough Attributes](/guide/components/attrs) are attributes and event handlers passed by the parent component, but not declared as a prop or an emitted event by the child.\n\n  By default, everything in `$attrs` will be automatically inherited on the component's root element if there is only a single root element. This behavior is disabled if the component has multiple root nodes, and can be explicitly disabled with the [`inheritAttrs`](./options-misc#inheritattrs) option.\n\n- **See also**\n\n  - [Fallthrough Attributes](/guide/components/attrs)\n\n## $watch() {#watch}\n\nImperative API for creating watchers.\n\n- **Type**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $watch(\n      source: string | (() => any),\n      callback: WatchCallback,\n      options?: WatchOptions\n    ): StopHandle\n  }\n\n  type WatchCallback<T> = (\n    value: T,\n    oldValue: T,\n    onCleanup: (cleanupFn: () => void) => void\n  ) => void\n\n  interface WatchOptions {\n    immediate?: boolean // default: false\n    deep?: boolean // default: false\n    flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n    onTrack?: (event: DebuggerEvent) => void\n    onTrigger?: (event: DebuggerEvent) => void\n  }\n\n  type StopHandle = () => void\n  ```\n\n- **Details**\n\n  The first argument is the watch source. It can be a component property name string, a simple dot-delimited path string, or a getter function.\n\n  The second argument is the callback function. The callback receives the new value and the old value of the watched source.\n\n  - **`immediate`**: trigger the callback immediately on watcher creation. Old value will be `undefined` on the first call.\n  - **`deep`**: force deep traversal of the source if it is an object, so that the callback fires on deep mutations. See [Deep Watchers](/guide/essentials/watchers#deep-watchers).\n  - **`flush`**: adjust the callback's flush timing. See [Callback Flush Timing](/guide/essentials/watchers#callback-flush-timing) and [`watchEffect()`](/api/reactivity-core#watcheffect).\n  - **`onTrack / onTrigger`**: debug the watcher's dependencies. See [Watcher Debugging](/guide/extras/reactivity-in-depth#watcher-debugging).\n\n- **Example**\n\n  Watch a property name:\n\n  ```js\n  this.$watch('a', (newVal, oldVal) => {})\n  ```\n\n  Watch a dot-delimited path:\n\n  ```js\n  this.$watch('a.b', (newVal, oldVal) => {})\n  ```\n\n  Using getter for more complex expressions:\n\n  ```js\n  this.$watch(\n    // every time the expression `this.a + this.b` yields\n    // a different result, the handler will be called.\n    // It's as if we were watching a computed property\n    // without defining the computed property itself.\n    () => this.a + this.b,\n    (newVal, oldVal) => {}\n  )\n  ```\n\n  Stopping the watcher:\n\n  ```js\n  const unwatch = this.$watch('a', cb)\n\n  // later...\n  unwatch()\n  ```\n\n- **See also**\n  - [Options - `watch`](/api/options-state#watch)\n  - [Guide - Watchers](/guide/essentials/watchers)\n\n## $emit() {#emit}\n\nTrigger a custom event on the current instance. Any additional arguments will be passed into the listener's callback function.\n\n- **Type**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $emit(event: string, ...args: any[]): void\n  }\n  ```\n\n- **Example**\n\n  ```js\n  export default {\n    created() {\n      // only event\n      this.$emit('foo')\n      // with additional arguments\n      this.$emit('bar', 1, 2, 3)\n    }\n  }\n  ```\n\n- **See also**\n\n  - [Component - Events](/guide/components/events)\n  - [`emits` option](./options-state#emits)\n\n## $forceUpdate() {#forceupdate}\n\nForce the component instance to re-render.\n\n- **Type**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $forceUpdate(): void\n  }\n  ```\n\n- **Details**\n\n  This should be rarely needed given Vue's fully automatic reactivity system. The only cases where you may need it is when you have explicitly created non-reactive component state using advanced reactivity APIs.\n\n## $nextTick() {#nexttick}\n\nInstance-bound version of the global [`nextTick()`](./general#nexttick).\n\n- **Type**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $nextTick(callback?: (this: ComponentPublicInstance) => void): Promise<void>\n  }\n  ```\n\n- **Details**\n\n  The only difference from the global version of `nextTick()` is that the callback passed to `this.$nextTick()` will have its `this` context bound to the current component instance.\n\n- **See also** [`nextTick()`](./general#nexttick)",
          "questions": [
            "What is the `$data` property in the `ComponentPublicInstance` interface?",
            "Is the `$props` property in the `ComponentPublicInstance` interface mutable?",
            "What is the `$el` property in the `ComponentPublicInstance` interface?",
            "When will the `$el` property be `undefined`?",
            "What is the `$options` property in the `ComponentPublicInstance` interface?",
            "What are the sources that `$options` object is merged from?",
            "What is the `$parent` property in the `ComponentPublicInstance` interface?",
            "What is the `$root` property in the `ComponentPublicInstance` interface?",
            "What is the `$slots` property in the `ComponentPublicInstance` interface?",
            "What is the `$attrs` property in the `ComponentPublicInstance` interface used for?"
          ]
        }
      ]
    },
    {
      "file_name": "composition-api-lifecycle.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Composition API: Lifecycle Hooks {#composition-api-lifecycle-hooks}\n\n:::info Usage Note\nAll APIs listed on this page must be called synchronously during the `setup()` phase of a component. See [Guide - Lifecycle Hooks](/guide/essentials/lifecycle) for more details.\n:::\n\n## onMounted() {#onmounted}\n\nRegisters a callback to be called after the component has been mounted.\n\n- **Type**\n\n  ```ts\n  function onMounted(callback: () => void): void\n  ```\n\n- **Details**\n\n  A component is considered mounted after:\n\n  - All of its synchronous child components have been mounted (does not include async components or components inside `<Suspense>` trees).\n\n  - Its own DOM tree has been created and inserted into the parent container. Note it only guarantees that the component's DOM tree is in-document if the application's root container is also in-document.\n\n  This hook is typically used for performing side effects that need access to the component's rendered DOM, or for limiting DOM-related code to the client in a [server-rendered application](/guide/scaling-up/ssr).\n\n  **This hook is not called during server-side rendering.**\n\n- **Example**\n\n  Accessing an element via template ref:\n\n  ```vue\n  <script setup>\n  import { ref, onMounted } from 'vue'\n\n  const el = ref()\n\n  onMounted(() => {\n    el.value // <div>\n  })\n  </script>\n\n  <template>\n    <div ref=\"el\"></div>\n  </template>\n  ```\n\n## onUpdated() {#onupdated}\n\nRegisters a callback to be called after the component has updated its DOM tree due to a reactive state change.\n\n- **Type**\n\n  ```ts\n  function onUpdated(callback: () => void): void\n  ```\n\n- **Details**\n\n  A parent component's updated hook is called after that of its child components.\n\n  This hook is called after any DOM update of the component, which can be caused by different state changes, because multiple state changes can be batched into a single render cycle for performance reasons. If you need to access the updated DOM after a specific state change, use [nextTick()](/api/general#nexttick) instead.\n\n  **This hook is not called during server-side rendering.**\n\n  :::warning\n  Do not mutate component state in the updated hook - this will likely lead to an infinite update loop!\n  :::\n\n- **Example**\n\n  Accessing updated DOM:\n\n  ```vue\n  <script setup>\n  import { ref, onUpdated } from 'vue'\n\n  const count = ref(0)\n\n  onUpdated(() => {\n    // text content should be the same as current `count.value`\n    console.log(document.getElementById('count').textContent)\n  })\n  </script>\n\n  <template>\n    <button id=\"count\" @click=\"count++\">{{ count }}</button>\n  </template>\n  ```\n\n## onUnmounted() {#onunmounted}\n\nRegisters a callback to be called after the component has been unmounted.\n\n- **Type**\n\n  ```ts\n  function onUnmounted(callback: () => void): void\n  ```\n\n- **Details**\n\n  A component is considered unmounted after:\n\n  - All of its child components have been unmounted.\n\n  - All of its associated reactive effects (render effect and computed / watchers created during `setup()`) have been stopped.\n\n  Use this hook to clean up manually created side effects such as timers, DOM event listeners or server connections.\n\n  **This hook is not called during server-side rendering.**\n\n- **Example**\n\n  ```vue\n  <script setup>\n  import { onMounted, onUnmounted } from 'vue'\n\n  let intervalId\n  onMounted(() => {\n    intervalId = setInterval(() => {\n      // ...\n    })\n  })\n\n  onUnmounted(() => clearInterval(intervalId))\n  </script>\n  ```\n\n## onBeforeMount() {#onbeforemount}\n\nRegisters a hook to be called right before the component is to be mounted.\n\n- **Type**\n\n  ```ts\n  function onBeforeMount(callback: () => void): void\n  ```\n\n- **Details**\n\n  When this hook is called, the component has finished setting up its reactive state, but no DOM nodes have been created yet. It is about to execute its DOM render effect for the first time.\n\n  **This hook is not called during server-side rendering.**\n\n## onBeforeUpdate() {#onbeforeupdate}\n\nRegisters a hook to be called right before the component is about to update its DOM tree due to a reactive state change.\n\n- **Type**\n\n  ```ts\n  function onBeforeUpdate(callback: () => void): void\n  ```\n\n- **Details**\n\n  This hook can be used to access the DOM state before Vue updates the DOM. It is also safe to modify component state inside this hook.\n\n  **This hook is not called during server-side rendering.**\n\n## onBeforeUnmount() {#onbeforeunmount}\n\nRegisters a hook to be called right before a component instance is to be unmounted.\n\n- **Type**\n\n  ```ts\n  function onBeforeUnmount(callback: () => void): void\n  ```\n\n- **Details**\n\n  When this hook is called, the component instance is still fully functional.\n\n  **This hook is not called during server-side rendering.**\n\n## onErrorCaptured() {#onerrorcaptured}\n\nRegisters a hook to be called when an error propagating from a descendant component has been captured.\n\n- **Type**\n\n  ```ts\n  function onErrorCaptured(callback: ErrorCapturedHook): void\n\n  type ErrorCapturedHook = (\n    err: unknown,\n    instance: ComponentPublicInstance | null,\n    info: string\n  ) => boolean | void\n  ```\n\n- **Details**\n\n  Errors can be captured from the following sources:\n\n  - Component renders\n  - Event handlers\n  - Lifecycle hooks\n  - `setup()` function\n  - Watchers\n  - Custom directive hooks\n  - Transition hooks\n\n  The hook receives three arguments: the error, the component instance that triggered the error, and an information string specifying the error source type.\n\n  You can modify component state in `errorCaptured()` to display an error state to the user. However, it is important that the error state should not render the original content that caused the error; otherwise the component will be thrown into an infinite render loop.\n\n  The hook can return `false` to stop the error from propagating further. See error propagation details below.\n\n  **Error Propagation Rules**\n\n  - By default, all errors are still sent to the application-level [`app.config.errorHandler`](/api/application#app-config-errorhandler) if it is defined, so that these errors can still be reported to an analytics service in a single place.\n\n  - If multiple `errorCaptured` hooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error, in the order of bottom to top. This is similar to the bubbling mechanism of native DOM events.\n\n  - If the `errorCaptured` hook itself throws an error, both this error and the original captured error are sent to `app.config.errorHandler`.\n\n  - An `errorCaptured` hook can return `false` to prevent the error from propagating further. This is essentially saying \"this error has been handled and should be ignored.\" It will prevent any additional `errorCaptured` hooks or `app.config.errorHandler` from being invoked for this error.\n\n## onRenderTracked() <sup class=\"vt-badge dev-only\" /> {#onrendertracked}\n\nRegisters a debug hook to be called when a reactive dependency has been tracked by the component's render effect.\n\n**This hook is development-mode-only and not called during server-side rendering.**\n\n- **Type**\n\n  ```ts\n  function onRenderTracked(callback: DebuggerHook): void\n\n  type DebuggerHook = (e: DebuggerEvent) => void\n\n  type DebuggerEvent = {\n    effect: ReactiveEffect\n    target: object\n    type: TrackOpTypes /* 'get' | 'has' | 'iterate' */\n    key: any\n  }\n  ```\n\n- **See also** [Reactivity in Depth](/guide/extras/reactivity-in-depth)\n\n## onRenderTriggered() <sup class=\"vt-badge dev-only\" /> {#onrendertriggered}\n\nRegisters a debug hook to be called when a reactive dependency triggers the component's render effect to be re-run.\n\n**This hook is development-mode-only and not called during server-side rendering.**\n\n- **Type**\n\n  ```ts\n  function onRenderTriggered(callback: DebuggerHook): void\n\n  type DebuggerHook = (e: DebuggerEvent) => void\n\n  type DebuggerEvent = {\n    effect: ReactiveEffect\n    target: object\n    type: TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */\n    key: any\n    newValue?: any\n    oldValue?: any\n    oldTarget?: Map<any, any> | Set<any>\n  }\n  ```\n\n- **See also** [Reactivity in Depth](/guide/extras/reactivity-in-depth)\n\n## onActivated() {#onactivated}\n\nRegisters a callback to be called after the component instance is inserted into the DOM as part of a tree cached by [`<KeepAlive>`](/api/built-in-components#keepalive).\n\n**This hook is not called during server-side rendering.**\n\n- **Type**\n\n  ```ts\n  function onActivated(callback: () => void): void\n  ```\n\n- **See also** [Guide - Lifecycle of Cached Instance](/guide/built-ins/keep-alive#lifecycle-of-cached-instance)\n\n## onDeactivated() {#ondeactivated}\n\nRegisters a callback to be called after the component instance is removed from the DOM as part of a tree cached by [`<KeepAlive>`](/api/built-in-components#keepalive).\n\n**This hook is not called during server-side rendering.**\n\n- **Type**\n\n  ```ts\n  function onDeactivated(callback: () => void): void\n  ```\n\n- **See also** [Guide - Lifecycle of Cached Instance](/guide/built-ins/keep-alive#lifecycle-of-cached-instance)\n\n## onServerPrefetch() <sup class=\"vt-badge\" data-text=\"SSR only\" /> {#onserverprefetch}\n\nRegisters an async function to be resolved before the component instance is to be rendered on the server.\n\n- **Type**\n\n  ```ts\n  function onServerPrefetch(callback: () => Promise<any>): void\n  ```\n\n- **Details**\n\n  If the callback returns a Promise, the server renderer will wait until the Promise is resolved before rendering the component.\n\n  This hook is only called during server-side rendering can be used to perform server-only data fetching.\n\n- **Example**\n\n  ```vue\n  <script setup>\n  import { ref, onServerPrefetch, onMounted } from 'vue'\n\n  const data = ref(null)\n\n  onServerPrefetch(async () => {\n    // component is rendered as part of the initial request\n    // pre-fetch data on server as it is faster than on the client\n    data.value = await fetchOnServer(/* ... */)\n  })\n\n  onMounted(async () => {\n    if (!data.value) {\n      // if data is null on mount, it means the component\n      // is dynamically rendered on the client. Perform a\n      // client-side fetch instead.\n      data.value = await fetchOnClient(/* ... */)\n    }\n  })\n  </script>\n  ```\n\n- **See also** [Server-Side Rendering](/guide/scaling-up/ssr)",
          "questions": [
            "What is the purpose of the `onMounted()` hook in the Composition API?",
            "When is a component considered mounted?",
            "Can the `onMounted()` hook be used during server-side rendering?",
            "What is the purpose of the `onUpdated()` hook in the Composition API?",
            "When is the `onUpdated()` hook called?",
            "Is it safe to mutate component state in the `onUpdated()` hook?",
            "What is the purpose of the `onUnmounted()` hook in the Composition API?",
            "When is a component considered unmounted?",
            "What is the recommended use case for the `onUnmounted()` hook?",
            "Can the `onBeforeMount()` hook be used during server-side rendering?"
          ]
        }
      ]
    },
    {
      "file_name": "composition-api-setup.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Composition API: setup() {#composition-api-setup}\n\n## Basic Usage {#basic-usage}\n\nThe `setup()` hook serves as the entry point for Composition API usage in components in the following cases:\n\n1. Using Composition API without a build step;\n2. Integrating with Composition-API-based code in an Options API component.\n\n:::info Note\nIf you are using Composition API with Single-File Components, [`<script setup>`](/api/sfc-script-setup) is strongly recommended for a more succinct and ergonomic syntax.\n:::\n\nWe can declare reactive state using [Reactivity APIs](./reactivity-core) and expose them to the template by returning an object from `setup()`. The properties on the returned object will also be made available on the component instance (if other options are used):\n\n```vue\n<script>\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    // expose to template and other options API hooks\n    return {\n      count\n    }\n  },\n\n  mounted() {\n    console.log(this.count) // 0\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\">{{ count }}</button>\n</template>\n```\n\n[refs](/api/reactivity-core#ref) returned from `setup` are [automatically shallow unwrapped](/guide/essentials/reactivity-fundamentals#deep-reactivity) when accessed in the template so you do not need to use `.value` when accessing them. They are also unwrapped in the same way when accessed on `this`.\n\n`setup()` itself does not have access to the component instance - `this` will have a value of `undefined` inside `setup()`. You can access Composition-API-exposed values from Options API, but not the other way around.\n\n`setup()` should return an object _synchronously_. The only case when `async setup()` can be used is when the component is a descendant of a [Suspense](../guide/built-ins/suspense) component.\n\n## Accessing Props {#accessing-props}\n\nThe first argument in the `setup` function is the `props` argument. Just as you would expect in a standard component, `props` inside of a `setup` function are reactive and will be updated when new props are passed in.\n\n```js\nexport default {\n  props: {\n    title: String\n  },\n  setup(props) {\n    console.log(props.title)\n  }\n}\n```\n\nNote that if you destructure the `props` object, the destructured variables will lose reactivity. It is therefore recommended to always access props in the form of `props.xxx`.\n\nIf you really need to destructure the props, or need to pass a prop into an external function while retaining reactivity, you can do so with the [toRefs()](./reactivity-utilities#torefs) and [toRef()](/api/reactivity-utilities#toref) utility APIs:\n\n```js\nimport { toRefs, toRef } from 'vue'\n\nexport default {\n  setup(props) {\n    // turn `props` into an object of refs, then destructure\n    const { title } = toRefs(props)\n    // `title` is a ref that tracks `props.title`\n    console.log(title.value)\n\n    // OR, turn a single property on `props` into a ref\n    const title = toRef(props, 'title')\n  }\n}\n```\n\n## Setup Context {#setup-context}\n\nThe second argument passed to the `setup` function is a **Setup Context** object. The context object exposes other values that may be useful inside `setup`:\n\n```js\nexport default {\n  setup(props, context) {\n    // Attributes (Non-reactive object, equivalent to $attrs)\n    console.log(context.attrs)\n\n    // Slots (Non-reactive object, equivalent to $slots)\n    console.log(context.slots)\n\n    // Emit events (Function, equivalent to $emit)\n    console.log(context.emit)\n\n    // Expose public properties (Function)\n    console.log(context.expose)\n  }\n}\n```\n\nThe context object is not reactive and can be safely destructured:\n\n```js\nexport default {\n  setup(props, { attrs, slots, emit, expose }) {\n    ...\n  }\n}\n```\n\n`attrs` and `slots` are stateful objects that are always updated when the component itself is updated. This means you should avoid destructuring them and always reference properties as `attrs.x` or `slots.x`. Also note that, unlike `props`, the properties of `attrs` and `slots` are **not** reactive. If you intend to apply side effects based on changes to `attrs` or `slots`, you should do so inside an `onBeforeUpdate` lifecycle hook.\n\n### Exposing Public Properties {#exposing-public-properties}\n\n`expose` is a function that can be used to explicitly limit the properties exposed when the component instance is accessed by a parent component via [template refs](/guide/essentials/template-refs#ref-on-component):\n\n```js{5,10}\nexport default {\n  setup(props, { expose }) {\n    // make the instance \"closed\" -\n    // i.e. do not expose anything to the parent\n    expose()\n\n    const publicCount = ref(0)\n    const privateCount = ref(0)\n    // selectively expose local state\n    expose({ count: publicCount })\n  }\n}\n```\n\n## Usage with Render Functions {#usage-with-render-functions}\n\n`setup` can also return a [render function](/guide/extras/render-function) which can directly make use of the reactive state declared in the same scope:\n\n```js{6}\nimport { h, ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    return () => h('div', count.value)\n  }\n}\n```\n\nReturning a render function prevents us from returning anything else. Internally that shouldn't be a problem, but it can be problematic if we want to expose methods of this component to the parent component via template refs.\n\nWe can solve this problem by calling [`expose()`](#exposing-public-properties):\n\n```js{8-10}\nimport { h, ref } from 'vue'\n\nexport default {\n  setup(props, { expose }) {\n    const count = ref(0)\n    const increment = () => ++count.value\n\n    expose({\n      increment\n    })\n\n    return () => h('div', count.value)\n  }\n}\n```\n\nThe `increment` method would then be available in the parent component via a template ref.",
          "questions": [
            "What is the purpose of the `setup()` hook in the Composition API?",
            "In what cases is the `setup()` hook used as the entry point for Composition API usage in components?",
            "What is the recommended way to use Composition API with Single-File Components?",
            "How do we declare reactive state using the Composition API and expose it to the template?",
            "Are `ref`s returned from `setup()` automatically shallow unwrapped when accessed in the template?",
            "Does `setup()` have access to the component instance?",
            "Can Composition-API-exposed values be accessed from Options API?",
            "What is the first argument in the `setup` function and how is it used?",
            "What is the second argument passed to the `setup` function and what values does it expose?",
            "How can we explicitly limit the properties exposed when the component instance is accessed by a parent component via template refs?"
          ]
        }
      ]
    },
    {
      "file_name": "reactivity-core.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# Reactivity API: Core {#reactivity-api-core}\n\n:::info See also\nTo better understand the Reactivity APIs, it is recommended to read the following chapters in the guide:\n\n- [Reactivity Fundamentals](/guide/essentials/reactivity-fundamentals) (with the API preference set to Composition API)\n- [Reactivity in Depth](/guide/extras/reactivity-in-depth)\n  :::\n\n## ref() {#ref}\n\nTakes an inner value and returns a reactive and mutable ref object, which has a single property `.value` that points to the inner value.\n\n- **Type**\n\n  ```ts\n  function ref<T>(value: T): Ref<UnwrapRef<T>>\n\n  interface Ref<T> {\n    value: T\n  }\n  ```\n\n- **Details**\n\n  The ref object is mutable - i.e. you can assign new values to `.value`. It is also reactive - i.e. any read operations to `.value` are tracked, and write operations will trigger associated effects.\n\n  If an object is assigned as a ref's value, the object is made deeply reactive with [reactive()](#reactive). This also means if the object contains nested refs, they will be deeply unwrapped.\n\n  To avoid the deep conversion, use [`shallowRef()`](./reactivity-advanced#shallowref) instead.\n\n- **Example**\n\n  ```js\n  const count = ref(0)\n  console.log(count.value) // 0\n\n  count.value++\n  console.log(count.value) // 1\n  ```\n\n- **See also**\n  - [Guide - Reactivity Fundamentals with `ref()`](/guide/essentials/reactivity-fundamentals#ref)\n  - [Guide - Typing `ref()`](/guide/typescript/composition-api#typing-ref) <sup class=\"vt-badge ts\" />\n\n## computed() {#computed}\n\nTakes a getter function and returns a readonly reactive [ref](#ref) object for the returned value from the getter. It can also take an object with `get` and `set` functions to create a writable ref object.\n\n- **Type**\n\n  ```ts\n  // read-only\n  function computed<T>(\n    getter: () => T,\n    // see \"Computed Debugging\" link below\n    debuggerOptions?: DebuggerOptions\n  ): Readonly<Ref<Readonly<T>>>\n\n  // writable\n  function computed<T>(\n    options: {\n      get: () => T\n      set: (value: T) => void\n    },\n    debuggerOptions?: DebuggerOptions\n  ): Ref<T>\n  ```\n\n- **Example**\n\n  Creating a readonly computed ref:\n\n  ```js\n  const count = ref(1)\n  const plusOne = computed(() => count.value + 1)\n\n  console.log(plusOne.value) // 2\n\n  plusOne.value++ // error\n  ```\n\n  Creating a writable computed ref:\n\n  ```js\n  const count = ref(1)\n  const plusOne = computed({\n    get: () => count.value + 1,\n    set: (val) => {\n      count.value = val - 1\n    }\n  })\n\n  plusOne.value = 1\n  console.log(count.value) // 0\n  ```\n\n  Debugging:\n\n  ```js\n  const plusOne = computed(() => count.value + 1, {\n    onTrack(e) {\n      debugger\n    },\n    onTrigger(e) {\n      debugger\n    }\n  })\n  ```\n\n- **See also**\n  - [Guide - Computed Properties](/guide/essentials/computed)\n  - [Guide - Computed Debugging](/guide/extras/reactivity-in-depth#computed-debugging)\n  - [Guide - Typing `computed()`](/guide/typescript/composition-api#typing-computed) <sup class=\"vt-badge ts\" />\n\n## reactive() {#reactive}\n\nReturns a reactive proxy of the object.\n\n- **Type**\n\n  ```ts\n  function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\n  ```\n\n- **Details**\n\n  The reactive conversion is \"deep\": it affects all nested properties. A reactive object also deeply unwraps any properties that are [refs](#ref) while maintaining reactivity.\n\n  It should also be noted that there is no ref unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like `Map`.\n\n  To avoid the deep conversion and only retain reactivity at the root level, use [shallowReactive()](./reactivity-advanced#shallowreactive) instead.\n\n  The returned object and its nested objects are wrapped with [ES Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) and **not** equal to the original objects. It is recommended to work exclusively with the reactive proxy and avoid relying on the original object.\n\n- **Example**\n\n  Creating a reactive object:\n\n  ```js\n  const obj = reactive({ count: 0 })\n  obj.count++\n  ```\n\n  Ref unwrapping:\n\n  ```ts\n  const count = ref(1)\n  const obj = reactive({ count })\n\n  // ref will be unwrapped\n  console.log(obj.count === count.value) // true\n\n  // it will update `obj.count`\n  count.value++\n  console.log(count.value) // 2\n  console.log(obj.count) // 2\n\n  // it will also update `count` ref\n  obj.count++\n  console.log(obj.count) // 3\n  console.log(count.value) // 3\n  ```\n\n  Note that refs are **not** unwrapped when accessed as array or collection elements:\n\n  ```js\n  const books = reactive([ref('Vue 3 Guide')])\n  // need .value here\n  console.log(books[0].value)\n\n  const map = reactive(new Map([['count', ref(0)]]))\n  // need .value here\n  console.log(map.get('count').value)\n  ```\n\n  When assigning a [ref](#ref) to a `reactive` property, that ref will also be automatically unwrapped:\n\n  ```ts\n  const count = ref(1)\n  const obj = reactive({})\n\n  obj.count = count\n\n  console.log(obj.count) // 1\n  console.log(obj.count === count.value) // true\n  ```\n\n- **See also**\n  - [Guide - Reactivity Fundamentals](/guide/essentials/reactivity-fundamentals)\n  - [Guide - Typing `reactive()`](/guide/typescript/composition-api#typing-reactive) <sup class=\"vt-badge ts\" />\n\n## readonly() {#readonly}\n\nTakes an object (reactive or plain) or a [ref](#ref) and returns a readonly proxy to the original.\n\n- **Type**\n\n  ```ts\n  function readonly<T extends object>(\n    target: T\n  ): DeepReadonly<UnwrapNestedRefs<T>>\n  ```\n\n- **Details**\n\n  A readonly proxy is deep: any nested property accessed will be readonly as well. It also has the same ref-unwrapping behavior as `reactive()`, except the unwrapped values will also be made readonly.\n\n  To avoid the deep conversion, use [shallowReadonly()](./reactivity-advanced#shallowreadonly) instead.\n\n- **Example**\n\n  ```js\n  const original = reactive({ count: 0 })\n\n  const copy = readonly(original)\n\n  watchEffect(() => {\n    // works for reactivity tracking\n    console.log(copy.count)\n  })\n\n  // mutating original will trigger watchers relying on the copy\n  original.count++\n\n  // mutating the copy will fail and result in a warning\n  copy.count++ // warning!\n  ```\n\n## watchEffect() {#watcheffect}\n\nRuns a function immediately while reactively tracking its dependencies and re-runs it whenever the dependencies are changed.\n\n- **Type**\n\n  ```ts\n  function watchEffect(\n    effect: (onCleanup: OnCleanup) => void,\n    options?: WatchEffectOptions\n  ): StopHandle\n\n  type OnCleanup = (cleanupFn: () => void) => void\n\n  interface WatchEffectOptions {\n    flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n    onTrack?: (event: DebuggerEvent) => void\n    onTrigger?: (event: DebuggerEvent) => void\n  }\n\n  type StopHandle = () => void\n  ```\n\n- **Details**\n\n  The first argument is the effect function to be run. The effect function receives a function that can be used to register a cleanup callback. The cleanup callback will be called right before the next time the effect is re-run, and can be used to clean up invalidated side effects, e.g. a pending async request (see example below).\n\n  The second argument is an optional options object that can be used to adjust the effect's flush timing or to debug the effect's dependencies.\n\n  By default, watchers will run just prior to component rendering. Setting `flush: 'post'` will defer the watcher until after component rendering. See [Callback Flush Timing](/guide/essentials/watchers#callback-flush-timing) for more information. In rare cases, it might be necessary to trigger a watcher immediately when a reactive dependency changes, e.g. to invalidate a cache. This can be achieved using `flush: 'sync'`. However, this setting should be used with caution, as it can lead to problems with performance and data consistency if multiple properties are being updated at the same time.\n\n  The return value is a handle function that can be called to stop the effect from running again.\n\n- **Example**\n\n  ```js\n  const count = ref(0)\n\n  watchEffect(() => console.log(count.value))\n  // -> logs 0\n\n  count.value++\n  // -> logs 1\n  ```\n\n  Side effect cleanup:\n\n  ```js\n  watchEffect(async (onCleanup) => {\n    const { response, cancel } = doAsyncWork(id.value)\n    // `cancel` will be called if `id` changes\n    // so that previous pending request will be cancelled\n    // if not yet completed\n    onCleanup(cancel)\n    data.value = await response\n  })\n  ```\n\n  Stopping the watcher:\n\n  ```js\n  const stop = watchEffect(() => {})\n\n  // when the watcher is no longer needed:\n  stop()\n  ```\n\n  Options:\n\n  ```js\n  watchEffect(() => {}, {\n    flush: 'post',\n    onTrack(e) {\n      debugger\n    },\n    onTrigger(e) {\n      debugger\n    }\n  })\n  ```\n\n- **See also**\n  - [Guide - Watchers](/guide/essentials/watchers#watcheffect)\n  - [Guide - Watcher Debugging](/guide/extras/reactivity-in-depth#watcher-debugging)\n\n## watchPostEffect() {#watchposteffect}\n\nAlias of [`watchEffect()`](#watcheffect) with `flush: 'post'` option.\n\n## watchSyncEffect() {#watchsynceffect}\n\nAlias of [`watchEffect()`](#watcheffect) with `flush: 'sync'` option.",
          "questions": [
            "What is the purpose of the `ref()` function in the Reactivity API?",
            "How does the `ref()` function make an object reactive?",
            "Can you assign new values to a ref object's `.value` property?",
            "What is the difference between a read-only and writable computed ref object?",
            "How do you create a computed ref object with both `get` and `set` functions?",
            "What is the purpose of the `reactive()` function in the Reactivity API?",
            "How does the `reactive()` function make an object reactive?",
            "What is the difference between a reactive and readonly proxy object?",
            "What is the purpose of the `watchEffect()` function in the Reactivity API?",
            "How can you stop a watcher created with `watchEffect()` from running again?"
          ]
        },
        {
          "content": "## watch() {#watch}\n\nWatches one or more reactive data sources and invokes a callback function when the sources change.\n\n- **Type**\n\n  ```ts\n  // watching single source\n  function watch<T>(\n    source: WatchSource<T>,\n    callback: WatchCallback<T>,\n    options?: WatchOptions\n  ): StopHandle\n\n  // watching multiple sources\n  function watch<T>(\n    sources: WatchSource<T>[],\n    callback: WatchCallback<T[]>,\n    options?: WatchOptions\n  ): StopHandle\n\n  type WatchCallback<T> = (\n    value: T,\n    oldValue: T,\n    onCleanup: (cleanupFn: () => void) => void\n  ) => void\n\n  type WatchSource<T> =\n    | Ref<T> // ref\n    | (() => T) // getter\n    | T extends object\n    ? T\n    : never // reactive object\n\n  interface WatchOptions extends WatchEffectOptions {\n    immediate?: boolean // default: false\n    deep?: boolean // default: false\n    flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n    onTrack?: (event: DebuggerEvent) => void\n    onTrigger?: (event: DebuggerEvent) => void\n  }\n  ```\n\n  > Types are simplified for readability.\n\n- **Details**\n\n  `watch()` is lazy by default - i.e. the callback is only called when the watched source has changed.\n\n  The first argument is the watcher's **source**. The source can be one of the following:\n\n  - A getter function that returns a value\n  - A ref\n  - A reactive object\n  - ...or an array of the above.\n\n  The second argument is the callback that will be called when the source changes. The callback receives three arguments: the new value, the old value, and a function for registering a side effect cleanup callback. The cleanup callback will be called right before the next time the effect is re-run, and can be used to clean up invalidated side effects, e.g. a pending async request.\n\n  When watching multiple sources, the callback receives two arrays containing new / old values corresponding to the source array.\n\n  The third optional argument is an options object that supports the following options:\n\n  - **`immediate`**: trigger the callback immediately on watcher creation. Old value will be `undefined` on the first call.\n  - **`deep`**: force deep traversal of the source if it is an object, so that the callback fires on deep mutations. See [Deep Watchers](/guide/essentials/watchers#deep-watchers).\n  - **`flush`**: adjust the callback's flush timing. See [Callback Flush Timing](/guide/essentials/watchers#callback-flush-timing) and [`watchEffect()`](/api/reactivity-core#watcheffect).\n  - **`onTrack / onTrigger`**: debug the watcher's dependencies. See [Watcher Debugging](/guide/extras/reactivity-in-depth#watcher-debugging).\n\n  Compared to [`watchEffect()`](#watcheffect), `watch()` allows us to:\n\n  - Perform the side effect lazily;\n  - Be more specific about what state should trigger the watcher to re-run;\n  - Access both the previous and current value of the watched state.\n\n- **Example**\n\n  Watching a getter:\n\n  ```js\n  const state = reactive({ count: 0 })\n  watch(\n    () => state.count,\n    (count, prevCount) => {\n      /* ... */\n    }\n  )\n  ```\n\n  Watching a ref:\n\n  ```js\n  const count = ref(0)\n  watch(count, (count, prevCount) => {\n    /* ... */\n  })\n  ```\n\n  When watching multiple sources, the callback receives arrays containing new / old values corresponding to the source array:\n\n  ```js\n  watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {\n    /* ... */\n  })\n  ```\n\n  When using a getter source, the watcher only fires if the getter's return value has changed. If you want the callback to fire even on deep mutations, you need to explicitly force the watcher into deep mode with `{ deep: true }`. Note in deep mode, the new value and the old will be the same object if the callback was triggered by a deep mutation:\n\n  ```js\n  const state = reactive({ count: 0 })\n  watch(\n    () => state,\n    (newValue, oldValue) => {\n      // newValue === oldValue\n    },\n    { deep: true }\n  )\n  ```\n\n  When directly watching a reactive object, the watcher is automatically in deep mode:\n\n  ```js\n  const state = reactive({ count: 0 })\n  watch(state, () => {\n    /* triggers on deep mutation to state */\n  })\n  ```\n\n  `watch()` shares the same flush timing and debugging options with [`watchEffect()`](#watcheffect):\n\n  ```js\n  watch(source, callback, {\n    flush: 'post',\n    onTrack(e) {\n      debugger\n    },\n    onTrigger(e) {\n      debugger\n    }\n  })\n  ```\n\n  Stopping the watcher:\n\n  ```js\n  const stop = watch(source, callback)\n\n  // when the watcher is no longer needed:\n  stop()\n  ```\n\n  Side effect cleanup:\n\n  ```js\n  watch(id, async (newId, oldId, onCleanup) => {\n    const { response, cancel } = doAsyncWork(newId)\n    // `cancel` will be called if `id` changes, cancelling\n    // the previous request if it hasn't completed yet\n    onCleanup(cancel)\n    data.value = await response\n  })\n  ```\n\n- **See also**\n\n  - [Guide - Watchers](/guide/essentials/watchers)\n  - [Guide - Watcher Debugging](/guide/extras/reactivity-in-depth#watcher-debugging)",
          "questions": [
            "What is the purpose of the `watch()` function in `reactivity-core`?",
            "What are the possible types of the `WatchSource` parameter in the `watch()` function?",
            "What is the type of the `WatchCallback` parameter in the `watch()` function?",
            "What are the three arguments passed to the `WatchCallback` function in the `watch()` function?",
            "What is the purpose of the `onCleanup` function in the `WatchCallback` function?",
            "What is the purpose of the `WatchOptions` parameter in the `watch()` function?",
            "What is the default value of the `immediate` option in the `WatchOptions` parameter?",
            "What is the purpose of the `deep` option in the `WatchOptions` parameter?",
            "What is the purpose of the `flush` option in the `WatchOptions` parameter?",
            "How can you stop a watcher created with the `watch()` function?"
          ]
        }
      ]
    },
    {
      "file_name": "composition-api-dependency-injection.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Composition API: <br>Dependency Injection {#composition-api-dependency-injection}\n\n## provide() {#provide}\n\nProvides a value that can be injected by descendant components.\n\n- **Type**\n\n  ```ts\n  function provide<T>(key: InjectionKey<T> | string, value: T): void\n  ```\n\n- **Details**\n\n  `provide()` takes two arguments: the key, which can be a string or a symbol, and the value to be injected.\n\n  When using TypeScript, the key can be a symbol casted as `InjectionKey` - a Vue provided utility type that extends `Symbol`, which can be used to sync the value type between `provide()` and `inject()`.\n\n  Similar to lifecycle hook registration APIs, `provide()` must be called synchronously during a component's `setup()` phase.\n\n- **Example**\n\n  ```vue\n  <script setup>\n  import { ref, provide } from 'vue'\n  import { fooSymbol } from './injectionSymbols'\n\n  // provide static value\n  provide('foo', 'bar')\n\n  // provide reactive value\n  const count = ref(0)\n  provide('count', count)\n\n  // provide with Symbol keys\n  provide(fooSymbol, count)\n  </script>\n  ```\n\n- **See also**\n  - [Guide - Provide / Inject](/guide/components/provide-inject)\n  - [Guide - Typing Provide / Inject](/guide/typescript/composition-api#typing-provide-inject) <sup class=\"vt-badge ts\" />\n\n## inject() {#inject}\n\nInjects a value provided by an ancestor component or the application (via `app.provide()`).\n\n- **Type**\n\n  ```ts\n  // without default value\n  function inject<T>(key: InjectionKey<T> | string): T | undefined\n\n  // with default value\n  function inject<T>(key: InjectionKey<T> | string, defaultValue: T): T\n\n  // with factory\n  function inject<T>(\n    key: InjectionKey<T> | string,\n    defaultValue: () => T,\n    treatDefaultAsFactory: true\n  ): T\n  ```\n\n- **Details**\n\n  The first argument is the injection key. Vue will walk up the parent chain to locate a provided value with a matching key. If multiple components in the parent chain provides the same key, the one closest to the injecting component will \"shadow\" those higher up the chain. If no value with matching key was found, `inject()` returns `undefined` unless a default value is provided.\n\n  The second argument is optional and is the default value to be used when no matching value was found.\n\n  The second argument can also be a factory function that returns values that are expensive to create. In this case, `true` must be passed as the third argument to indicate that the function should be used as a factory instead of the value itself.\n\n  Similar to lifecycle hook registration APIs, `inject()` must be called synchronously during a component's `setup()` phase.\n\n  When using TypeScript, the key can be of type of `InjectionKey` - a Vue-provided utility type that extends `Symbol`, which can be used to sync the value type between `provide()` and `inject()`.\n\n- **Example**\n\n  Assuming a parent component has provided values as shown in the previous `provide()` example:\n\n  ```vue\n  <script setup>\n  import { inject } from 'vue'\n  import { fooSymbol } from './injectionSymbols'\n\n  // inject static value without default\n  const foo = inject('foo')\n\n  // inject reactive value\n  const count = inject('count')\n\n  // inject with Symbol keys\n  const foo2 = inject(fooSymbol)\n\n  // inject with default value\n  const bar = inject('foo', 'default value')\n\n  // inject with function default value\n  const fn = inject('function', () => {})\n\n  // inject with default value factory\n  const baz = inject('factory', () => new ExpensiveObject(), true)\n  </script>\n  ```\n\n- **See also**\n  - [Guide - Provide / Inject](/guide/components/provide-inject)\n  - [Guide - Typing Provide / Inject](/guide/typescript/composition-api#typing-provide-inject) <sup class=\"vt-badge ts\" />",
          "questions": [
            "What is the purpose of the `provide()` function in the Composition API?",
            "What are the arguments that the `provide()` function takes?",
            "Can the key argument in the `provide()` function be a symbol?",
            "When should the `provide()` function be called?",
            "What is the purpose of the `inject()` function in the Composition API?",
            "What are the arguments that the `inject()` function takes?",
            "What happens if no matching value is found when using the `inject()` function?",
            "Can the key argument in the `inject()` function be a symbol?",
            "When should the `inject()` function be called?",
            "How can a factory function be used with the `inject()` function?"
          ]
        }
      ]
    },
    {
      "file_name": "general.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Global API: General {#global-api-general}\n\n## version {#version}\n\nExposes the current version of Vue.\n\n- **Type:** `string`\n\n- **Example**\n\n  ```js\n  import { version } from 'vue'\n\n  console.log(version)\n  ```\n\n## nextTick() {#nexttick}\n\nA utility for waiting for the next DOM update flush.\n\n- **Type**\n\n  ```ts\n  function nextTick(callback?: () => void): Promise<void>\n  ```\n\n- **Details**\n\n  When you mutate reactive state in Vue, the resulting DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" to ensure that each component updates only once no matter how many state changes you have made.\n\n  `nextTick()` can be used immediately after a state change to wait for the DOM updates to complete. You can either pass a callback as an argument, or await the returned Promise.\n\n- **Example**\n\n  <div class=\"composition-api\">\n\n  ```vue\n  <script setup>\n  import { ref, nextTick } from 'vue'\n\n  const count = ref(0)\n\n  async function increment() {\n    count.value++\n\n    // DOM not yet updated\n    console.log(document.getElementById('counter').textContent) // 0\n\n    await nextTick()\n    // DOM is now updated\n    console.log(document.getElementById('counter').textContent) // 1\n  }\n  </script>\n\n  <template>\n    <button id=\"counter\" @click=\"increment\">{{ count }}</button>\n  </template>\n  ```\n\n  </div>\n  <div class=\"options-api\">\n\n  ```vue\n  <script>\n  import { nextTick } from 'vue'\n\n  export default {\n    data() {\n      return {\n        count: 0\n      }\n    },\n    methods: {\n      async increment() {\n        this.count++\n\n        // DOM not yet updated\n        console.log(document.getElementById('counter').textContent) // 0\n\n        await nextTick()\n        // DOM is now updated\n        console.log(document.getElementById('counter').textContent) // 1\n      }\n    }\n  }\n  </script>\n\n  <template>\n    <button id=\"counter\" @click=\"increment\">{{ count }}</button>\n  </template>\n  ```\n\n  </div>\n\n- **See also** [`this.$nextTick()`](/api/component-instance#nexttick)\n\n## defineComponent() {#definecomponent}\n\nA type helper for defining a Vue component with type inference.\n\n- **Type**\n\n  ```ts\n  // options syntax\n  function defineComponent(\n    component: ComponentOptions\n  ): ComponentConstructor\n\n  // function syntax (requires 3.3+)\n  function defineComponent(\n    setup: ComponentOptions['setup'],\n    extraOptions?: ComponentOptions\n  ): () => any\n  ```\n\n  > Type is simplified for readability.\n\n- **Details**\n\n  The first argument expects a component options object. The return value will be the same options object, since the function is essentially a runtime no-op for type inference purposes only.\n\n  Note that the return type is a bit special: it will be a constructor type whose instance type is the inferred component instance type based on the options. This is used for type inference when the returned type is used as a tag in TSX.\n\n  You can extract the instance type of a component (equivalent to the type of `this` in its options) from the return type of `defineComponent()` like this:\n\n  ```ts\n  const Foo = defineComponent(/* ... */)\n\n  type FooInstance = InstanceType<typeof Foo>\n  ```\n\n  ### Function Signature <sup class=\"vt-badge\" data-text=\"3.3+\" /> {#function-signature}\n\n  `defineComponent()` also has an alternative signature that is meant to be used with Composition API and [render functions or JSX](/guide/extras/render-function.html).\n\n  Instead of passing in an options object, a function is expected instead. This function works the same as the Composition API [`setup()`](/api/composition-api-setup.html#composition-api-setup) function: it receives the props and the setup context. The return value should be a render function - both `h()` and JSX are supported:\n\n  ```js\n  import { ref, h } from 'vue'\n\n  const Comp = defineComponent(\n    (props) => {\n      // use Composition API here like in <script setup>\n      const count = ref(0)\n\n      return () => {\n        // render function or JSX\n        return h('div', count.value)\n      }\n    },\n    // extra options, e.g. declare props and emits\n    {\n      props: {\n        /* ... */\n      }\n    }\n  )\n  ```\n\n  The main use case for this signature is with TypeScript (and in particular with TSX), as it supports generics:\n\n  ```tsx\n  const Comp = defineComponent(\n    <T extends string | number>(props: { msg: T; list: T[] }) => {\n      // use Composition API here like in <script setup>\n      const count = ref(0)\n\n      return () => {\n        // render function or JSX\n        return <div>{count.value}</div>\n      }\n    },\n    // manual runtime props declaration is currently still needed.\n    {\n      props: ['msg', 'list']\n    }\n  )\n  ```\n\n  In the future, we plan to provide a Babel plugin that automatically infers and injects the runtime props (like for `defineProps` in SFCs) so that the runtime props declaration can be omitted.\n\n  ### Note on webpack Treeshaking {#note-on-webpack-treeshaking}\n\n  Because `defineComponent()` is a function call, it could look like that it would produce side-effects to some build tools, e.g. webpack. This will prevent the component from being tree-shaken even when the component is never used.\n\n  To tell webpack that this function call is safe to be tree-shaken, you can add a `/*#__PURE__*/` comment notation before the function call:\n\n  ```js\n  export default /*#__PURE__*/ defineComponent(/* ... */)\n  ```\n\n  Note this is not necessary if you are using Vite, because Rollup (the underlying production bundler used by Vite) is smart enough to determine that `defineComponent()` is in fact side-effect-free without the need for manual annotations.\n\n- **See also** [Guide - Using Vue with TypeScript](/guide/typescript/overview#general-usage-notes)\n\n## defineAsyncComponent() {#defineasynccomponent}\n\nDefine an async component which is lazy loaded only when it is rendered. The argument can either be a loader function, or an options object for more advanced control of the loading behavior.\n\n- **Type**\n\n  ```ts\n  function defineAsyncComponent(\n    source: AsyncComponentLoader | AsyncComponentOptions\n  ): Component\n\n  type AsyncComponentLoader = () => Promise<Component>\n\n  interface AsyncComponentOptions {\n    loader: AsyncComponentLoader\n    loadingComponent?: Component\n    errorComponent?: Component\n    delay?: number\n    timeout?: number\n    suspensible?: boolean\n    onError?: (\n      error: Error,\n      retry: () => void,\n      fail: () => void,\n      attempts: number\n    ) => any\n  }\n  ```\n\n- **See also** [Guide - Async Components](/guide/components/async)\n\n## defineCustomElement() {#definecustomelement}\n\nThis method accepts the same argument as [`defineComponent`](#definecomponent), but instead returns a native [Custom Element](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements) class constructor.\n\n- **Type**\n\n  ```ts\n  function defineCustomElement(\n    component:\n      | (ComponentOptions & { styles?: string[] })\n      | ComponentOptions['setup']\n  ): {\n    new (props?: object): HTMLElement\n  }\n  ```\n\n  > Type is simplified for readability.\n\n- **Details**\n\n  In addition to normal component options, `defineCustomElement()` also supports a special option `styles`, which should be an array of inlined CSS strings, for providing CSS that should be injected into the element's shadow root.\n\n  The return value is a custom element constructor that can be registered using [`customElements.define()`](https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define).\n\n- **Example**\n\n  ```js\n  import { defineCustomElement } from 'vue'\n\n  const MyVueElement = defineCustomElement({\n    /* component options */\n  })\n\n  // Register the custom element.\n  customElements.define('my-vue-element', MyVueElement)\n  ```\n\n- **See also**\n\n  - [Guide - Building Custom Elements with Vue](/guide/extras/web-components#building-custom-elements-with-vue)\n\n  - Also note that `defineCustomElement()` requires [special config](/guide/extras/web-components#sfc-as-custom-element) when used with Single-File Components.",
          "questions": [
            "What is the purpose of the `version` property in the Global API?",
            "What is the type of the `version` property in the Global API?",
            "How can you access the `version` property in your code?",
            "What is the purpose of the `nextTick()` function in Vue?",
            "How does `nextTick()` ensure that each component updates only once?",
            "What is the return type of the `nextTick()` function?",
            "What are the two ways to use `nextTick()`?",
            "What is the purpose of the `defineComponent()` function in Vue?",
            "What is the difference between the two signatures of `defineComponent()`?",
            "What is the purpose of the `defineCustomElement()` function in Vue?"
          ]
        }
      ]
    },
    {
      "file_name": "built-in-directives.md",
      "question_count": 20,
      "documents": [
        {
          "content": "# Built-in Directives {#built-in-directives}\n\n## v-text {#v-text}\n\nUpdate the element's text content.\n\n- **Expects:** `string`\n\n- **Details**\n\n  `v-text` works by setting the element's [textContent](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent) property, so it will overwrite any existing content inside the element. If you need to update the part of `textContent`, you should use [mustache interpolations](/guide/essentials/template-syntax#text-interpolation) instead.\n\n- **Example**\n\n  ```vue-html\n  <span v-text=\"msg\"></span>\n  <!-- same as -->\n  <span>{{msg}}</span>\n  ```\n\n- **See also** [Template Syntax - Text Interpolation](/guide/essentials/template-syntax#text-interpolation)\n\n## v-html {#v-html}\n\nUpdate the element's [innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML).\n\n- **Expects:** `string`\n\n- **Details**\n\n  Contents of `v-html` are inserted as plain HTML - Vue template syntax will not be processed. If you find yourself trying to compose templates using `v-html`, try to rethink the solution by using components instead.\n\n  ::: warning Security Note\n  Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to [XSS attacks](https://en.wikipedia.org/wiki/Cross-site_scripting). Only use `v-html` on trusted content and **never** on user-provided content.\n  :::\n\n  In [Single-File Components](/guide/scaling-up/sfc), `scoped` styles will not apply to content inside `v-html`, because that HTML is not processed by Vue's template compiler. If you want to target `v-html` content with scoped CSS, you can instead use [CSS modules](./sfc-css-features#css-modules) or an additional, global `<style>` element with a manual scoping strategy such as BEM.\n\n- **Example**\n\n  ```vue-html\n  <div v-html=\"html\"></div>\n  ```\n\n- **See also** [Template Syntax - Raw HTML](/guide/essentials/template-syntax#raw-html)\n\n## v-show {#v-show}\n\nToggle the element's visibility based on the truthy-ness of the expression value.\n\n- **Expects:** `any`\n\n- **Details**\n\n  `v-show` works by setting the `display` CSS property via inline styles, and will try to respect the initial `display` value when the element is visible. It also triggers transitions when its condition changes.\n\n- **See also** [Conditional Rendering - v-show](/guide/essentials/conditional#v-show)\n\n## v-if {#v-if}\n\nConditionally render an element or a template fragment based on the truthy-ness of the expression value.\n\n- **Expects:** `any`\n\n- **Details**\n\n  When a `v-if` element is toggled, the element and its contained directives / components are destroyed and re-constructed. If the initial condition is falsy, then the inner content won't be rendered at all.\n\n  Can be used on `<template>` to denote a conditional block containing only text or multiple elements.\n\n  This directive triggers transitions when its condition changes.\n\n  When used together, `v-if` has a higher priority than `v-for`. We don't recommend using these two directives together on one element \u2014 see the [list rendering guide](/guide/essentials/list#v-for-with-v-if) for details.\n\n- **See also** [Conditional Rendering - v-if](/guide/essentials/conditional#v-if)\n\n## v-else {#v-else}\n\nDenote the \"else block\" for `v-if` or a `v-if` / `v-else-if` chain.\n\n- **Does not expect expression**\n\n- **Details**\n\n  - Restriction: previous sibling element must have `v-if` or `v-else-if`.\n\n  - Can be used on `<template>` to denote a conditional block containing only text or multiple elements.\n\n- **Example**\n\n  ```vue-html\n  <div v-if=\"Math.random() > 0.5\">\n    Now you see me\n  </div>\n  <div v-else>\n    Now you don't\n  </div>\n  ```\n\n- **See also** [Conditional Rendering - v-else](/guide/essentials/conditional#v-else)\n\n## v-else-if {#v-else-if}\n\nDenote the \"else if block\" for `v-if`. Can be chained.\n\n- **Expects:** `any`\n\n- **Details**\n\n  - Restriction: previous sibling element must have `v-if` or `v-else-if`.\n\n  - Can be used on `<template>` to denote a conditional block containing only text or multiple elements.\n\n- **Example**\n\n  ```vue-html\n  <div v-if=\"type === 'A'\">\n    A\n  </div>\n  <div v-else-if=\"type === 'B'\">\n    B\n  </div>\n  <div v-else-if=\"type === 'C'\">\n    C\n  </div>\n  <div v-else>\n    Not A/B/C\n  </div>\n  ```\n\n- **See also** [Conditional Rendering - v-else-if](/guide/essentials/conditional#v-else-if)\n\n## v-for {#v-for}\n\nRender the element or template block multiple times based on the source data.\n\n- **Expects:** `Array | Object | number | string | Iterable`\n\n- **Details**\n\n  The directive's value must use the special syntax `alias in expression` to provide an alias for the current element being iterated on:\n\n  ```vue-html\n  <div v-for=\"item in items\">\n    {{ item.text }}\n  </div>\n  ```\n\n  Alternatively, you can also specify an alias for the index (or the key if used on an Object):\n\n  ```vue-html\n  <div v-for=\"(item, index) in items\"></div>\n  <div v-for=\"(value, key) in object\"></div>\n  <div v-for=\"(value, name, index) in object\"></div>\n  ```\n\n  The default behavior of `v-for` will try to patch the elements in-place without moving them. To force it to reorder elements, you should provide an ordering hint with the `key` special attribute:\n\n  ```vue-html\n  <div v-for=\"item in items\" :key=\"item.id\">\n    {{ item.text }}\n  </div>\n  ```\n\n  `v-for` can also work on values that implement the [Iterable Protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol), including native `Map` and `Set`.\n\n- **See also**\n  - [List Rendering](/guide/essentials/list)\n\n## v-on {#v-on}\n\nAttach an event listener to the element.\n\n- **Shorthand:** `@`\n\n- **Expects:** `Function | Inline Statement | Object (without argument)`\n\n- **Argument:** `event` (optional if using Object syntax)\n\n- **Modifiers**\n\n  - `.stop` - call `event.stopPropagation()`.\n  - `.prevent` - call `event.preventDefault()`.\n  - `.capture` - add event listener in capture mode.\n  - `.self` - only trigger handler if event was dispatched from this element.\n  - `.{keyAlias}` - only trigger handler on certain keys.\n  - `.once` - trigger handler at most once.\n  - `.left` - only trigger handler for left button mouse events.\n  - `.right` - only trigger handler for right button mouse events.\n  - `.middle` - only trigger handler for middle button mouse events.\n  - `.passive` - attaches a DOM event with `{ passive: true }`.\n\n- **Details**\n\n  The event type is denoted by the argument. The expression can be a method name, an inline statement, or omitted if there are modifiers present.\n\n  When used on a normal element, it listens to [**native DOM events**](https://developer.mozilla.org/en-US/docs/Web/Events) only. When used on a custom element component, it listens to **custom events** emitted on that child component.\n\n  When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special `$event` property: `v-on:click=\"handle('ok', $event)\"`.\n\n  `v-on` also supports binding to an object of event / listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.\n\n- **Example**\n\n  ```vue-html\n  <!-- method handler -->\n  <button v-on:click=\"doThis\"></button>\n\n  <!-- dynamic event -->\n  <button v-on:[event]=\"doThis\"></button>\n\n  <!-- inline statement -->\n  <button v-on:click=\"doThat('hello', $event)\"></button>\n\n  <!-- shorthand -->\n  <button @click=\"doThis\"></button>\n\n  <!-- shorthand dynamic event -->\n  <button @[event]=\"doThis\"></button>\n\n  <!-- stop propagation -->\n  <button @click.stop=\"doThis\"></button>\n\n  <!-- prevent default -->\n  <button @click.prevent=\"doThis\"></button>\n\n  <!-- prevent default without expression -->\n  <form @submit.prevent></form>\n\n  <!-- chain modifiers -->\n  <button @click.stop.prevent=\"doThis\"></button>\n\n  <!-- key modifier using keyAlias -->\n  <input @keyup.enter=\"onEnter\" />\n\n  <!-- the click event will be triggered at most once -->\n  <button v-on:click.once=\"doThis\"></button>\n\n  <!-- object syntax -->\n  <button v-on=\"{ mousedown: doThis, mouseup: doThat }\"></button>\n  ```\n\n  Listening to custom events on a child component (the handler is called when \"my-event\" is emitted on the child):\n\n  ```vue-html\n  <MyComponent @my-event=\"handleThis\" />\n\n  <!-- inline statement -->\n  <MyComponent @my-event=\"handleThis(123, $event)\" />\n  ```\n\n- **See also**\n  - [Event Handling](/guide/essentials/event-handling)\n  - [Components - Custom Events](/guide/essentials/component-basics#listening-to-events)",
          "questions": [
            "What is the purpose of the `v-text` directive?",
            "How does the `v-html` directive work?",
            "What is the security risk associated with using the `v-html` directive?",
            "How does the `v-show` directive toggle element visibility?",
            "What happens when a `v-if` element is toggled?",
            "Can `v-if` and `v-for` be used together on one element?",
            "What is the syntax for using `v-for` to iterate over an object?",
            "What is the shorthand for the `v-on` directive?",
            "What is the argument for the `v-on` directive?",
            "Can modifiers be used with the object syntax for the `v-on` directive?"
          ]
        },
        {
          "content": "## v-bind {#v-bind}\n\nDynamically bind one or more attributes, or a component prop to an expression.\n\n- **Shorthand:** `:` or `.` (when using `.prop` modifier)\n\n- **Expects:** `any (with argument) | Object (without argument)`\n\n- **Argument:** `attrOrProp (optional)`\n\n- **Modifiers**\n\n  - `.camel` - transform the kebab-case attribute name into camelCase.\n  - `.prop` - force a binding to be set as a DOM property. <sup class=\"vt-badge\">3.2+</sup>\n  - `.attr` - force a binding to be set as a DOM attribute. <sup class=\"vt-badge\">3.2+</sup>\n\n- **Usage**\n\n  When used to bind the `class` or `style` attribute, `v-bind` supports additional value types such as Array or Objects. See linked guide section below for more details.\n\n  When setting a binding on an element, Vue by default checks whether the element has the key defined as a property using an `in` operator check. If the property is defined, Vue will set the value as a DOM property instead of an attribute. This should work in most cases, but you can override this behavior by explicitly using `.prop` or `.attr` modifiers. This is sometimes necessary, especially when [working with custom elements](/guide/extras/web-components#passing-dom-properties).\n\n  When used for component prop binding, the prop must be properly declared in the child component.\n\n  When used without an argument, can be used to bind an object containing attribute name-value pairs.\n\n- **Example**\n\n  ```vue-html\n  <!-- bind an attribute -->\n  <img v-bind:src=\"imageSrc\" />\n\n  <!-- dynamic attribute name -->\n  <button v-bind:[key]=\"value\"></button>\n\n  <!-- shorthand -->\n  <img :src=\"imageSrc\" />\n\n  <!-- shorthand dynamic attribute name -->\n  <button :[key]=\"value\"></button>\n\n  <!-- with inline string concatenation -->\n  <img :src=\"'/path/to/images/' + fileName\" />\n\n  <!-- class binding -->\n  <div :class=\"{ red: isRed }\"></div>\n  <div :class=\"[classA, classB]\"></div>\n  <div :class=\"[classA, { classB: isB, classC: isC }]\"></div>\n\n  <!-- style binding -->\n  <div :style=\"{ fontSize: size + 'px' }\"></div>\n  <div :style=\"[styleObjectA, styleObjectB]\"></div>\n\n  <!-- binding an object of attributes -->\n  <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n\n  <!-- prop binding. \"prop\" must be declared in the child component. -->\n  <MyComponent :prop=\"someThing\" />\n\n  <!-- pass down parent props in common with a child component -->\n  <MyComponent v-bind=\"$props\" />\n\n  <!-- XLink -->\n  <svg><a :xlink:special=\"foo\"></a></svg>\n  ```\n\n  The `.prop` modifier also has a dedicated shorthand, `.`:\n\n  ```vue-html\n  <div :someProperty.prop=\"someObject\"></div>\n\n  <!-- equivalent to -->\n  <div .someProperty=\"someObject\"></div>\n  ```\n\n  The `.camel` modifier allows camelizing a `v-bind` attribute name when using in-DOM templates, e.g. the SVG `viewBox` attribute:\n\n  ```vue-html\n  <svg :view-box.camel=\"viewBox\"></svg>\n  ```\n\n  `.camel` is not needed if you are using string templates, or pre-compiling the template with a build step.\n\n- **See also**\n  - [Class and Style Bindings](/guide/essentials/class-and-style)\n  - [Components - Prop Passing Details](/guide/components/props#prop-passing-details)\n\n## v-model {#v-model}\n\nCreate a two-way binding on a form input element or a component.\n\n- **Expects:** varies based on value of form inputs element or output of components\n\n- **Limited to:**\n\n  - `<input>`\n  - `<select>`\n  - `<textarea>`\n  - components\n\n- **Modifiers**\n\n  - [`.lazy`](/guide/essentials/forms#lazy) - listen to `change` events instead of `input`\n  - [`.number`](/guide/essentials/forms#number) - cast valid input string to numbers\n  - [`.trim`](/guide/essentials/forms#trim) - trim input\n\n- **See also**\n\n  - [Form Input Bindings](/guide/essentials/forms)\n  - [Component Events - Usage with `v-model`](/guide/components/v-model)\n\n## v-slot {#v-slot}\n\nDenote named slots or scoped slots that expect to receive props.\n\n- **Shorthand:** `#`\n\n- **Expects:** JavaScript expression that is valid in a function argument position, including support for destructuring. Optional - only needed if expecting props to be passed to the slot.\n\n- **Argument:** slot name (optional, defaults to `default`)\n\n- **Limited to:**\n\n  - `<template>`\n  - [components](/guide/components/slots#scoped-slots) (for a lone default slot with props)\n\n- **Example**\n\n  ```vue-html\n  <!-- Named slots -->\n  <BaseLayout>\n    <template v-slot:header>\n      Header content\n    </template>\n\n    <template v-slot:default>\n      Default slot content\n    </template>\n\n    <template v-slot:footer>\n      Footer content\n    </template>\n  </BaseLayout>\n\n  <!-- Named slot that receives props -->\n  <InfiniteScroll>\n    <template v-slot:item=\"slotProps\">\n      <div class=\"item\">\n        {{ slotProps.item.text }}\n      </div>\n    </template>\n  </InfiniteScroll>\n\n  <!-- Default slot that receive props, with destructuring -->\n  <Mouse v-slot=\"{ x, y }\">\n    Mouse position: {{ x }}, {{ y }}\n  </Mouse>\n  ```\n\n- **See also**\n  - [Components - Slots](/guide/components/slots)\n\n## v-pre {#v-pre}\n\nSkip compilation for this element and all its children.\n\n- **Does not expect expression**\n\n- **Details**\n\n  Inside the element with `v-pre`, all Vue template syntax will be preserved and rendered as-is. The most common use case of this is displaying raw mustache tags.\n\n- **Example**\n\n  ```vue-html\n  <span v-pre>{{ this will not be compiled }}</span>\n  ```\n\n## v-once {#v-once}\n\nRender the element and component once only, and skip future updates.\n\n- **Does not expect expression**\n\n- **Details**\n\n  On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.\n\n  ```vue-html\n  <!-- single element -->\n  <span v-once>This will never change: {{msg}}</span>\n  <!-- the element have children -->\n  <div v-once>\n    <h1>comment</h1>\n    <p>{{msg}}</p>\n  </div>\n  <!-- component -->\n  <MyComponent v-once :comment=\"msg\"></MyComponent>\n  <!-- `v-for` directive -->\n  <ul>\n    <li v-for=\"i in list\" v-once>{{i}}</li>\n  </ul>\n  ```\n\n  Since 3.2, you can also memoize part of the template with invalidation conditions using [`v-memo`](#v-memo).\n\n- **See also**\n  - [Data Binding Syntax - interpolations](/guide/essentials/template-syntax#text-interpolation)\n  - [v-memo](#v-memo)\n\n## v-memo <sup class=\"vt-badge\" data-text=\"3.2+\" /> {#v-memo}\n\n- **Expects:** `any[]`\n\n- **Details**\n\n  Memoize a sub-tree of the template. Can be used on both elements and components. The directive expects a fixed-length array of dependency values to compare for the memoization. If every value in the array was the same as last render, then updates for the entire sub-tree will be skipped. For example:\n\n  ```vue-html\n  <div v-memo=\"[valueA, valueB]\">\n    ...\n  </div>\n  ```\n\n  When the component re-renders, if both `valueA` and `valueB` remain the same, all updates for this `<div>` and its children will be skipped. In fact, even the Virtual DOM VNode creation will also be skipped since the memoized copy of the sub-tree can be reused.\n\n  It is important to specify the memoization array correctly, otherwise we may skip updates that should indeed be applied. `v-memo` with an empty dependency array (`v-memo=\"[]\"`) would be functionally equivalent to `v-once`.\n\n  **Usage with `v-for`**\n\n  `v-memo` is provided solely for micro optimizations in performance-critical scenarios and should be rarely needed. The most common case where this may prove helpful is when rendering large `v-for` lists (where `length > 1000`):\n\n  ```vue-html\n  <div v-for=\"item in list\" :key=\"item.id\" v-memo=\"[item.id === selected]\">\n    <p>ID: {{ item.id }} - selected: {{ item.id === selected }}</p>\n    <p>...more child nodes</p>\n  </div>\n  ```\n\n  When the component's `selected` state changes, a large amount of VNodes will be created even though most of the items remained exactly the same. The `v-memo` usage here is essentially saying \"only update this item if it went from non-selected to selected, or the other way around\". This allows every unaffected item to reuse its previous VNode and skip diffing entirely. Note we don't need to include `item.id` in the memo dependency array here since Vue automatically infers it from the item's `:key`.\n\n  :::warning\n  When using `v-memo` with `v-for`, make sure they are used on the same element. **`v-memo` does not work inside `v-for`.**\n  :::\n\n  `v-memo` can also be used on components to manually prevent unwanted updates in certain edge cases where the child component update check has been de-optimized. But again, it is the developer's responsibility to specify correct dependency arrays to avoid skipping necessary updates.\n\n- **See also**\n  - [v-once](#v-once)\n\n## v-cloak {#v-cloak}\n\nUsed to hide un-compiled template until it is ready.\n\n- **Does not expect expression**\n\n- **Details**\n\n  **This directive is only needed in no-build-step setups.**\n\n  When using in-DOM templates, there can be a \"flash of un-compiled templates\": the user may see raw mustache tags until the mounted component replaces them with rendered content.\n\n  `v-cloak` will remain on the element until the associated component instance is mounted. Combined with CSS rules such as `[v-cloak] { display: none }`, it can be used to hide the raw templates until the component is ready.\n\n- **Example**\n\n  ```css\n  [v-cloak] {\n    display: none;\n  }\n  ```\n\n  ```vue-html\n  <div v-cloak>\n    {{ message }}\n  </div>\n  ```\n\n  The `<div>` will not be visible until the compilation is done.",
          "questions": [
            "What is the purpose of the `v-bind` directive?",
            "What are the shorthand notations for `v-bind`?",
            "What types of values can be bound using `v-bind`?",
            "What is the purpose of the `.prop` modifier in `v-bind`?",
            "When is it necessary to use the `.attr` modifier in `v-bind`?",
            "How can `v-bind` be used to bind the `class` or `style` attribute?",
            "What is the purpose of the `v-model` directive?",
            "What types of form input elements and components can `v-model` be used on?",
            "What are the modifiers available for `v-model`?",
            "What is the purpose of the `v-slot` directive?"
          ]
        }
      ]
    },
    {
      "file_name": "custom-renderer.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Custom Renderer API {#custom-renderer-api}\n\n## createRenderer() {#createrenderer}\n\nCreates a custom renderer. By providing platform-specific node creation and manipulation APIs, you can leverage Vue's core runtime to target non-DOM environments.\n\n- **Type**\n\n  ```ts\n  function createRenderer<HostNode, HostElement>(\n    options: RendererOptions<HostNode, HostElement>\n  ): Renderer<HostElement>\n\n  interface Renderer<HostElement> {\n    render: RootRenderFunction<HostElement>\n    createApp: CreateAppFunction<HostElement>\n  }\n\n  interface RendererOptions<HostNode, HostElement> {\n    patchProp(\n      el: HostElement,\n      key: string,\n      prevValue: any,\n      nextValue: any,\n      // the rest is unused for most custom renderers\n      isSVG?: boolean,\n      prevChildren?: VNode<HostNode, HostElement>[],\n      parentComponent?: ComponentInternalInstance | null,\n      parentSuspense?: SuspenseBoundary | null,\n      unmountChildren?: UnmountChildrenFn\n    ): void\n    insert(\n      el: HostNode,\n      parent: HostElement,\n      anchor?: HostNode | null\n    ): void\n    remove(el: HostNode): void\n    createElement(\n      type: string,\n      isSVG?: boolean,\n      isCustomizedBuiltIn?: string,\n      vnodeProps?: (VNodeProps & { [key: string]: any }) | null\n    ): HostElement\n    createText(text: string): HostNode\n    createComment(text: string): HostNode\n    setText(node: HostNode, text: string): void\n    setElementText(node: HostElement, text: string): void\n    parentNode(node: HostNode): HostElement | null\n    nextSibling(node: HostNode): HostNode | null\n\n    // optional, DOM-specific\n    querySelector?(selector: string): HostElement | null\n    setScopeId?(el: HostElement, id: string): void\n    cloneNode?(node: HostNode): HostNode\n    insertStaticContent?(\n      content: string,\n      parent: HostElement,\n      anchor: HostNode | null,\n      isSVG: boolean\n    ): [HostNode, HostNode]\n  }\n  ```\n\n- **Example**\n\n  ```js\n  import { createRenderer } from '@vue/runtime-core'\n\n  const { render, createApp } = createRenderer({\n    patchProp,\n    insert,\n    remove,\n    createElement\n    // ...\n  })\n\n  // `render` is the low-level API\n  // `createApp` returns an app instance\n  export { render, createApp }\n\n  // re-export Vue core APIs\n  export * from '@vue/runtime-core'\n  ```\n\n  Vue's own `@vue/runtime-dom` is [implemented using the same API](https://github.com/vuejs/core/blob/main/packages/runtime-dom/src/index.ts). For a simpler implementation, check out [`@vue/runtime-test`](https://github.com/vuejs/core/blob/main/packages/runtime-test/src/index.ts) which is a private package for Vue's own unit testing.",
          "questions": [
            "What is the purpose of the `createRenderer()` function in Vue?",
            "What is the return type of the `createRenderer()` function?",
            "What are the parameters of the `createRenderer()` function?",
            "What is the purpose of the `RendererOptions` interface?",
            "What is the purpose of the `Renderer` interface?",
            "What is the `render` property of the `Renderer` interface used for?",
            "What is the `createApp` property of the `Renderer` interface used for?",
            "What is the purpose of the `patchProp()` method in the `RendererOptions` interface?",
            "What is the purpose of the `insert()` method in the `RendererOptions` interface?",
            "What is the purpose of the `createElement()` method in the `RendererOptions` interface?"
          ]
        }
      ]
    },
    {
      "file_name": "ssr.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Server-Side Rendering API {#server-side-rendering-api}\n\n## renderToString() {#rendertostring}\n\n- **Exported from `vue/server-renderer`**\n\n- **Type**\n\n  ```ts\n  function renderToString(\n    input: App | VNode,\n    context?: SSRContext\n  ): Promise<string>\n  ```\n\n- **Example**\n\n  ```js\n  import { createSSRApp } from 'vue'\n  import { renderToString } from 'vue/server-renderer'\n\n  const app = createSSRApp({\n    data: () => ({ msg: 'hello' }),\n    template: `<div>{{ msg }}</div>`\n  })\n\n  ;(async () => {\n    const html = await renderToString(app)\n    console.log(html)\n  })()\n  ```\n\n  ### SSR Context {#ssr-context}\n\n  You can pass an optional context object, which can be used to record additional data during the render, for example [accessing content of Teleports](/guide/scaling-up/ssr#teleports):\n\n  ```js\n  const ctx = {}\n  const html = await renderToString(app, ctx)\n\n  console.log(ctx.teleports) // { '#teleported': 'teleported content' }\n  ```\n\n  Most other SSR APIs on this page also optionally accept a context object. The context object can be accessed in component code via the [useSSRContext](#usessrcontext) helper.\n\n- **See also** [Guide - Server-Side Rendering](/guide/scaling-up/ssr)\n\n## renderToNodeStream() {#rendertonodestream}\n\nRenders input as a [Node.js Readable stream](https://nodejs.org/api/stream.html#stream_class_stream_readable).\n\n- **Exported from `vue/server-renderer`**\n\n- **Type**\n\n  ```ts\n  function renderToNodeStream(\n    input: App | VNode,\n    context?: SSRContext\n  ): Readable\n  ```\n\n- **Example**\n\n  ```js\n  // inside a Node.js http handler\n  renderToNodeStream(app).pipe(res)\n  ```\n\n  :::tip Note\n  This method is not supported in the ESM build of `vue/server-renderer`, which is decoupled from Node.js environments. Use [`pipeToNodeWritable`](#pipetonodewritable) instead.\n  :::\n\n## pipeToNodeWritable() {#pipetonodewritable}\n\nRender and pipe to an existing [Node.js Writable stream](https://nodejs.org/api/stream.html#stream_writable_streams) instance.\n\n- **Exported from `vue/server-renderer`**\n\n- **Type**\n\n  ```ts\n  function pipeToNodeWritable(\n    input: App | VNode,\n    context: SSRContext = {},\n    writable: Writable\n  ): void\n  ```\n\n- **Example**\n\n  ```js\n  // inside a Node.js http handler\n  pipeToNodeWritable(app, {}, res)\n  ```\n\n## renderToWebStream() {#rendertowebstream}\n\nRenders input as a [Web ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API).\n\n- **Exported from `vue/server-renderer`**\n\n- **Type**\n\n  ```ts\n  function renderToWebStream(\n    input: App | VNode,\n    context?: SSRContext\n  ): ReadableStream\n  ```\n\n- **Example**\n\n  ```js\n  // inside an environment with ReadableStream support\n  return new Response(renderToWebStream(app))\n  ```\n\n  :::tip Note\n  In environments that do not expose `ReadableStream` constructor in the global scope, [`pipeToWebWritable()`](#pipetowebwritable) should be used instead.\n  :::\n\n## pipeToWebWritable() {#pipetowebwritable}\n\nRender and pipe to an existing [Web WritableStream](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream) instance.\n\n- **Exported from `vue/server-renderer`**\n\n- **Type**\n\n  ```ts\n  function pipeToWebWritable(\n    input: App | VNode,\n    context: SSRContext = {},\n    writable: WritableStream\n  ): void\n  ```\n\n- **Example**\n\n  This is typically used in combination with [`TransformStream`](https://developer.mozilla.org/en-US/docs/Web/API/TransformStream):\n\n  ```js\n  // TransformStream is available in environments such as CloudFlare workers.\n  // in Node.js, TransformStream needs to be explicitly imported from 'stream/web'\n  const { readable, writable } = new TransformStream()\n  pipeToWebWritable(app, {}, writable)\n\n  return new Response(readable)\n  ```\n\n## renderToSimpleStream() {#rendertosimplestream}\n\nRenders input in streaming mode using a simple readable interface.\n\n- **Exported from `vue/server-renderer`**\n\n- **Type**\n\n  ```ts\n  function renderToSimpleStream(\n    input: App | VNode,\n    context: SSRContext,\n    options: SimpleReadable\n  ): SimpleReadable\n\n  interface SimpleReadable {\n    push(content: string | null): void\n    destroy(err: any): void\n  }\n  ```\n\n- **Example**\n\n  ```js\n  let res = ''\n\n  renderToSimpleStream(\n    app,\n    {},\n    {\n      push(chunk) {\n        if (chunk === null) {\n          // done\n          console(`render complete: ${res}`)\n        } else {\n          res += chunk\n        }\n      },\n      destroy(err) {\n        // error encountered\n      }\n    }\n  )\n  ```\n\n## useSSRContext() {#usessrcontext}\n\nA runtime API used to retrieve the context object passed to `renderToString()` or other server render APIs.\n\n- **Type**\n\n  ```ts\n  function useSSRContext<T = Record<string, any>>(): T | undefined\n  ```\n\n- **Example**\n\n  The retrieved context can be used to attach information that is needed for rendering the final HTML (e.g. head metadata).\n\n  ```vue\n  <script setup>\n  import { useSSRContext } from 'vue'\n\n  // make sure to only call it during SSR\n  // https://vitejs.dev/guide/ssr.html#conditional-logic\n  if (import.meta.env.SSR) {\n    const ctx = useSSRContext()\n    // ...attach properties to the context\n  }\n  </script>\n  ```",
          "questions": [
            "What is the purpose of the `renderToString()` function in the Server-Side Rendering API?",
            "What is the type of the `renderToString()` function?",
            "What is an example of using the `renderToString()` function?",
            "What is the SSR Context in the Server-Side Rendering API?",
            "How can you pass an optional context object to the `renderToString()` function?",
            "What is the purpose of the `renderToNodeStream()` function in the Server-Side Rendering API?",
            "What is the type of the `renderToNodeStream()` function?",
            "What is an example of using the `renderToNodeStream()` function?",
            "What is the purpose of the `useSSRContext()` function in the Server-Side Rendering API?",
            "How can you retrieve the context object passed to `renderToString()` or other server render APIs using the `useSSRContext()` function?"
          ]
        }
      ]
    },
    {
      "file_name": "built-in-special-elements.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Built-in Special Elements {#built-in-special-elements}\n\n:::info Not Components\n`<component>`, `<slot>` and `<template>` are component-like features and part of the template syntax. They are not true components and are compiled away during template compilation. As such, they are conventionally written with lowercase in templates.\n:::\n\n## `<component>` {#component}\n\nA \"meta component\" for rendering dynamic components or elements.\n\n- **Props**\n\n  ```ts\n  interface DynamicComponentProps {\n    is: string | Component\n  }\n  ```\n\n- **Details**\n\n  The actual component to render is determined by the `is` prop.\n\n  - When `is` is a string, it could be either an HTML tag name or a component's registered name.\n\n  - Alternatively, `is` can also be directly bound to the definition of a component.\n\n- **Example**\n\n  Rendering components by registered name (Options API):\n\n  ```vue\n  <script>\n  import Foo from './Foo.vue'\n  import Bar from './Bar.vue'\n\n  export default {\n    components: { Foo, Bar },\n    data() {\n      return {\n        view: 'Foo'\n      }\n    }\n  }\n  </script>\n\n  <template>\n    <component :is=\"view\" />\n  </template>\n  ```\n\n  Rendering components by definition (Composition API with `<script setup>`):\n\n  ```vue\n  <script setup>\n  import Foo from './Foo.vue'\n  import Bar from './Bar.vue'\n  </script>\n\n  <template>\n    <component :is=\"Math.random() > 0.5 ? Foo : Bar\" />\n  </template>\n  ```\n\n  Rendering HTML elements:\n\n  ```vue-html\n  <component :is=\"href ? 'a' : 'span'\"></component>\n  ```\n\n  The [built-in components](./built-in-components) can all be passed to `is`, but you must register them if you want to pass them by name. For example:\n\n  ```vue\n  <script>\n  import { Transition, TransitionGroup } from 'vue'\n\n  export default {\n    components: {\n      Transition,\n      TransitionGroup\n    }\n  }\n  </script>\n\n  <template>\n    <component :is=\"isGroup ? 'TransitionGroup' : 'Transition'\">\n      ...\n    </component>\n  </template>\n  ```\n\n  Registration is not required if you pass the component itself to `is` rather than its name, e.g. in `<script setup>`.\n\n  If `v-model` is used on a `<component>` tag, the template compiler will expand it to a `modelValue` prop and `update:modelValue` event listener, much like it would for any other component. However, this won't be compatible with native HTML elements, such as `<input>` or `<select>`. As a result, using `v-model` with a dynamically created native element won't work:\n\n  ```vue\n  <script setup>\n  import { ref } from 'vue'\n\n  const tag = ref('input')\n  const username = ref('')\n  </script>\n\n  <template>\n    <!-- This won't work as 'input' is a native HTML element -->\n    <component :is=\"tag\" v-model=\"username\" />\n  </template>\n  ```\n\n  In practice, this edge case isn't common as native form fields are typically wrapped in components in real applications. If you do need to use a native element directly then you can split the `v-model` into an attribute and event manually.\n\n- **See also** [Dynamic Components](/guide/essentials/component-basics#dynamic-components)\n\n## `<slot>` {#slot}\n\nDenotes slot content outlets in templates.\n\n- **Props**\n\n  ```ts\n  interface SlotProps {\n    /**\n     * Any props passed to <slot> to passed as arguments\n     * for scoped slots\n     */\n    [key: string]: any\n    /**\n     * Reserved for specifying slot name.\n     */\n    name?: string\n  }\n  ```\n\n- **Details**\n\n  The `<slot>` element can use the `name` attribute to specify a slot name. When no `name` is specified, it will render the default slot. Additional attributes passed to the slot element will be passed as slot props to the scoped slot defined in the parent.\n\n  The element itself will be replaced by its matched slot content.\n\n  `<slot>` elements in Vue templates are compiled into JavaScript, so they are not to be confused with [native `<slot>` elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot).\n\n- **See also** [Component - Slots](/guide/components/slots)\n\n## `<template>` {#template}\n\nThe `<template>` tag is used as a placeholder when we want to use a built-in directive without rendering an element in the DOM.\n\n- **Details**\n\n  The special handling for `<template>` is only triggered if it is used with one of these directives:\n\n  - `v-if`, `v-else-if`, or `v-else`\n  - `v-for`\n  - `v-slot`\n\n  If none of those directives are present then it will be rendered as a [native `<template>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template) instead.\n\n  A `<template>` with a `v-for` can also have a [`key` attribute](/api/built-in-special-attributes#key). All other attributes and directives will be discarded, as they aren't meaningful without a corresponding element.\n\n  Single-file components use a [top-level `<template>` tag](/api/sfc-spec#language-blocks) to wrap the entire template. That usage is separate from the use of `<template>` described above. That top-level tag is not part of the template itself and doesn't support template syntax, such as directives.\n\n- **See also**\n  - [Guide - `v-if` on `<template>`](/guide/essentials/conditional#v-if-on-template)\n  - [Guide - `v-for` on `<template>`](/guide/essentials/list#v-for-on-template)\n  - [Guide - Named slots](/guide/components/slots#named-slots)",
          "questions": [
            "What is the purpose of `<component>` in Vue templates?",
            "How is the actual component to render determined in `<component>`?",
            "Can `<component>` render HTML elements? If so, how?",
            "Do you need to register built-in components before passing them to `is` in `<component>`?",
            "What happens when `v-model` is used on a `<component>` tag?",
            "What is the purpose of `<slot>` in Vue templates?",
            "How can you specify a slot name in `<slot>`?",
            "What happens to additional attributes passed to `<slot>`?",
            "What is the special handling for `<template>` in Vue templates?",
            "Can a `<template>` with a `v-for` have a `key` attribute?"
          ]
        }
      ]
    },
    {
      "file_name": "built-in-special-attributes.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Built-in Special Attributes {#built-in-special-attributes}\n\n## key {#key}\n\nThe `key` special attribute is primarily used as a hint for Vue's virtual DOM algorithm to identify vnodes when diffing the new list of nodes against the old list.\n\n- **Expects:** `number | string | symbol`\n\n- **Details**\n\n  Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed / destroyed.\n\n  Children of the same common parent must have **unique keys**. Duplicate keys will cause render errors.\n\n  The most common use case is combined with `v-for`:\n\n  ```vue-html\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">...</li>\n  </ul>\n  ```\n\n  It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:\n\n  - Properly trigger lifecycle hooks of a component\n  - Trigger transitions\n\n  For example:\n\n  ```vue-html\n  <transition>\n    <span :key=\"text\">{{ text }}</span>\n  </transition>\n  ```\n\n  When `text` changes, the `<span>` will always be replaced instead of patched, so a transition will be triggered.\n\n- **See also** [Guide - List Rendering - Maintaining State with `key`](/guide/essentials/list#maintaining-state-with-key)\n\n## ref {#ref}\n\nDenotes a [template ref](/guide/essentials/template-refs).\n\n- **Expects:** `string | Function`\n\n- **Details**\n\n  `ref` is used to register a reference to an element or a child component.\n\n  In Options API, the reference will be registered under the component's `this.$refs` object:\n\n  ```vue-html\n  <!-- stored as this.$refs.p -->\n  <p ref=\"p\">hello</p>\n  ```\n\n  In Composition API, the reference will be stored in a ref with matching name:\n\n  ```vue\n  <script setup>\n  import { ref } from 'vue'\n\n  const p = ref()\n  </script>\n\n  <template>\n    <p ref=\"p\">hello</p>\n  </template>\n  ```\n\n  If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be the child component instance.\n\n  Alternatively `ref` can accept a function value which provides full control over where to store the reference:\n\n  ```vue-html\n  <ChildComponent :ref=\"(el) => child = el\" />\n  ```\n\n  An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you must wait until the component is mounted before accessing them.\n\n  `this.$refs` is also non-reactive, therefore you should not attempt to use it in templates for data-binding.\n\n- **See also**\n  - [Guide - Template Refs](/guide/essentials/template-refs)\n  - [Guide - Typing Template Refs](/guide/typescript/composition-api#typing-template-refs) <sup class=\"vt-badge ts\" />\n  - [Guide - Typing Component Template Refs](/guide/typescript/composition-api#typing-component-template-refs) <sup class=\"vt-badge ts\" />\n\n## is {#is}\n\nUsed for binding [dynamic components](/guide/essentials/component-basics#dynamic-components).\n\n- **Expects:** `string | Component`\n\n- **Usage on native elements** <sup class=\"vt-badge\">3.1+</sup>\n\n  When the `is` attribute is used on a native HTML element, it will be interpreted as a [Customized built-in element](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example), which is a native web platform feature.\n\n  There is, however, a use case where you may need Vue to replace a native element with a Vue component, as explained in [in-DOM Template Parsing Caveats](/guide/essentials/component-basics#in-dom-template-parsing-caveats). You can prefix the value of the `is` attribute with `vue:` so that Vue will render the element as a Vue component instead:\n\n  ```vue-html\n  <table>\n    <tr is=\"vue:my-row-component\"></tr>\n  </table>\n  ```\n\n- **See also**\n\n  - [Built-in Special Element - `<component>`](/api/built-in-special-elements#component)\n  - [Dynamic Components](/guide/essentials/component-basics#dynamic-components)",
          "questions": [
            "What is the primary use of the `key` special attribute in Vue?",
            "What are the expected values for the `key` special attribute?",
            "How does Vue's algorithm handle elements without keys?",
            "What happens to elements with keys that are no longer present?",
            "Can children of the same common parent have duplicate keys? Why or why not?",
            "What is the most common use case for the `key` special attribute?",
            "How can the `key` special attribute be used to force replacement of an element/component?",
            "What is the purpose of the `ref` special attribute in Vue?",
            "What are the expected values for the `ref` special attribute?",
            "When can you access the `this.$refs` object in Vue?"
          ]
        }
      ]
    },
    {
      "file_name": "built-in-components.md",
      "question_count": 10,
      "documents": [
        {
          "content": "---\npageClass: api\n---\n\n# Built-in Components {#built-in-components}\n\n:::info Registration and Usage\nBuilt-in components can be used directly in templates without needing to be registered. They are also tree-shakeable: they are only included in the build when they are used.\n\nWhen using them in [render functions](/guide/extras/render-function), they need to be imported explicitly. For example:\n\n```js\nimport { h, Transition } from 'vue'\n\nh(Transition, {\n  /* props */\n})\n```\n\n:::\n\n## `<Transition>` {#transition}\n\nProvides animated transition effects to a **single** element or component.\n\n- **Props**\n\n  ```ts\n  interface TransitionProps {\n    /**\n     * Used to automatically generate transition CSS class names.\n     * e.g. `name: 'fade'` will auto expand to `.fade-enter`,\n     * `.fade-enter-active`, etc.\n     */\n    name?: string\n    /**\n     * Whether to apply CSS transition classes.\n     * Default: true\n     */\n    css?: boolean\n    /**\n     * Specifies the type of transition events to wait for to\n     * determine transition end timing.\n     * Default behavior is auto detecting the type that has\n     * longer duration.\n     */\n    type?: 'transition' | 'animation'\n    /**\n     * Specifies explicit durations of the transition.\n     * Default behavior is wait for the first `transitionend`\n     * or `animationend` event on the root transition element.\n     */\n    duration?: number | { enter: number; leave: number }\n    /**\n     * Controls the timing sequence of leaving/entering transitions.\n     * Default behavior is simultaneous.\n     */\n    mode?: 'in-out' | 'out-in' | 'default'\n    /**\n     * Whether to apply transition on initial render.\n     * Default: false\n     */\n    appear?: boolean\n\n    /**\n     * Props for customizing transition classes.\n     * Use kebab-case in templates, e.g. enter-from-class=\"xxx\"\n     */\n    enterFromClass?: string\n    enterActiveClass?: string\n    enterToClass?: string\n    appearFromClass?: string\n    appearActiveClass?: string\n    appearToClass?: string\n    leaveFromClass?: string\n    leaveActiveClass?: string\n    leaveToClass?: string\n  }\n  ```\n\n- **Events**\n\n  - `@before-enter`\n  - `@before-leave`\n  - `@enter`\n  - `@leave`\n  - `@appear`\n  - `@after-enter`\n  - `@after-leave`\n  - `@after-appear`\n  - `@enter-cancelled`\n  - `@leave-cancelled` (`v-show` only)\n  - `@appear-cancelled`\n\n- **Example**\n\n  Simple element:\n\n  ```vue-html\n  <Transition>\n    <div v-if=\"ok\">toggled content</div>\n  </Transition>\n  ```\n\n  Forcing a transition by changing the `key` attribute:\n\n  ```vue-html\n  <Transition>\n    <div :key=\"text\">{{ text }}</div>\n  </Transition>\n  ```\n\n  Dynamic component, with transition mode + animate on appear:\n\n  ```vue-html\n  <Transition name=\"fade\" mode=\"out-in\" appear>\n    <component :is=\"view\"></component>\n  </Transition>\n  ```\n\n  Listening to transition events:\n\n  ```vue-html\n  <Transition @after-enter=\"onTransitionComplete\">\n    <div v-show=\"ok\">toggled content</div>\n  </Transition>\n  ```\n\n- **See also** [`<Transition>` Guide](/guide/built-ins/transition)\n\n## `<TransitionGroup>` {#transitiongroup}\n\nProvides transition effects for **multiple** elements or components in a list.\n\n- **Props**\n\n  `<TransitionGroup>` accepts the same props as `<Transition>` except `mode`, plus two additional props:\n\n  ```ts\n  interface TransitionGroupProps extends Omit<TransitionProps, 'mode'> {\n    /**\n     * If not defined, renders as a fragment.\n     */\n    tag?: string\n    /**\n     * For customizing the CSS class applied during move transitions.\n     * Use kebab-case in templates, e.g. move-class=\"xxx\"\n     */\n    moveClass?: string\n  }\n  ```\n\n- **Events**\n\n  `<TransitionGroup>` emits the same events as `<Transition>`.\n\n- **Details**\n\n  By default, `<TransitionGroup>` doesn't render a wrapper DOM element, but one can be defined via the `tag` prop.\n\n  Note that every child in a `<transition-group>` must be [**uniquely keyed**](/guide/essentials/list#maintaining-state-with-key) for the animations to work properly.\n\n  `<TransitionGroup>` supports moving transitions via CSS transform. When a child's position on screen has changed after an update, it will get applied a moving CSS class (auto generated from the `name` attribute or configured with the `move-class` prop). If the CSS `transform` property is \"transition-able\" when the moving class is applied, the element will be smoothly animated to its destination using the [FLIP technique](https://aerotwist.com/blog/flip-your-animations/).\n\n- **Example**\n\n  ```vue-html\n  <TransitionGroup tag=\"ul\" name=\"slide\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </TransitionGroup>\n  ```\n\n- **See also** [Guide - TransitionGroup](/guide/built-ins/transition-group)\n\n## `<KeepAlive>` {#keepalive}\n\nCaches dynamically toggled components wrapped inside.\n\n- **Props**\n\n  ```ts\n  interface KeepAliveProps {\n    /**\n     * If specified, only components with names matched by\n     * `include` will be cached.\n     */\n    include?: MatchPattern\n    /**\n     * Any component with a name matched by `exclude` will\n     * not be cached.\n     */\n    exclude?: MatchPattern\n    /**\n     * The maximum number of component instances to cache.\n     */\n    max?: number | string\n  }\n\n  type MatchPattern = string | RegExp | (string | RegExp)[]\n  ```\n\n- **Details**\n\n  When wrapped around a dynamic component, `<KeepAlive>` caches the inactive component instances without destroying them.\n\n  There can only be one active component instance as the direct child of `<KeepAlive>` at any time.\n\n  When a component is toggled inside `<KeepAlive>`, its `activated` and `deactivated` lifecycle hooks will be invoked accordingly, providing an alternative to `mounted` and `unmounted`, which are not called. This applies to the direct child of `<KeepAlive>` as well as to all of its descendants.\n\n- **Example**\n\n  Basic usage:\n\n  ```vue-html\n  <KeepAlive>\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n\n  When used with `v-if` / `v-else` branches, there must be only one component rendered at a time:\n\n  ```vue-html\n  <KeepAlive>\n    <comp-a v-if=\"a > 1\"></comp-a>\n    <comp-b v-else></comp-b>\n  </KeepAlive>\n  ```\n\n  Used together with `<Transition>`:\n\n  ```vue-html\n  <Transition>\n    <KeepAlive>\n      <component :is=\"view\"></component>\n    </KeepAlive>\n  </Transition>\n  ```\n\n  Using `include` / `exclude`:\n\n  ```vue-html\n  <!-- comma-delimited string -->\n  <KeepAlive include=\"a,b\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n\n  <!-- regex (use `v-bind`) -->\n  <KeepAlive :include=\"/a|b/\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n\n  <!-- Array (use `v-bind`) -->\n  <KeepAlive :include=\"['a', 'b']\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n\n  Usage with `max`:\n\n  ```vue-html\n  <KeepAlive :max=\"10\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n\n- **See also** [Guide - KeepAlive](/guide/built-ins/keep-alive)\n\n## `<Teleport>` {#teleport}\n\nRenders its slot content to another part of the DOM.\n\n- **Props**\n\n  ```ts\n  interface TeleportProps {\n    /**\n     * Required. Specify target container.\n     * Can either be a selector or an actual element.\n     */\n    to: string | HTMLElement\n    /**\n     * When `true`, the content will remain in its original\n     * location instead of moved into the target container.\n     * Can be changed dynamically.\n     */\n    disabled?: boolean\n  }\n  ```\n\n- **Example**\n\n  Specifying target container:\n\n  ```vue-html\n  <Teleport to=\"#some-id\" />\n  <Teleport to=\".some-class\" />\n  <Teleport to=\"[data-teleport]\" />\n  ```\n\n  Conditionally disabling:\n\n  ```vue-html\n  <Teleport to=\"#popup\" :disabled=\"displayVideoInline\">\n    <video src=\"./my-movie.mp4\">\n  </Teleport>\n  ```\n\n- **See also** [Guide - Teleport](/guide/built-ins/teleport)\n\n## `<Suspense>` <sup class=\"vt-badge experimental\" /> {#suspense}\n\nUsed for orchestrating nested async dependencies in a component tree.\n\n- **Props**\n\n  ```ts\n  interface SuspenseProps {\n    timeout?: string | number\n  }\n  ```\n\n- **Events**\n\n  - `@resolve`\n  - `@pending`\n  - `@fallback`\n\n- **Details**\n\n  `<Suspense>` accepts two slots: the `#default` slot and the `#fallback` slot. It will display the content of the fallback slot while rendering the default slot in memory.\n\n  If it encounters async dependencies ([Async Components](/guide/components/async) and components with [`async setup()`](/guide/built-ins/suspense#async-setup)) while rendering the default slot, it will wait until all of them are resolved before displaying the default slot.\n\n- **See also** [Guide - Suspense](/guide/built-ins/suspense)",
          "questions": [
            "What is the purpose of built-in components in Vue?",
            "How can built-in components be used in templates?",
            "Are built-in components tree-shakeable? If so, how?",
            "When using built-in components in render functions, what must be done?",
            "What is the purpose of the `<Transition>` component?",
            "What props does the `<Transition>` component accept?",
            "What events does the `<Transition>` component emit?",
            "What is the purpose of the `<TransitionGroup>` component?",
            "What props does the `<TransitionGroup>` component accept?",
            "What is the purpose of the `<KeepAlive>` component?"
          ]
        }
      ]
    },
    {
      "file_name": "render-function.md",
      "question_count": 10,
      "documents": [
        {
          "content": "# Render Function APIs {#render-function-apis}\n\n## h() {#h}\n\nCreates virtual DOM nodes (vnodes).\n\n- **Type**\n\n  ```ts\n  // full signature\n  function h(\n    type: string | Component,\n    props?: object | null,\n    children?: Children | Slot | Slots\n  ): VNode\n\n  // omitting props\n  function h(type: string | Component, children?: Children | Slot): VNode\n\n  type Children = string | number | boolean | VNode | null | Children[]\n\n  type Slot = () => Children\n\n  type Slots = { [name: string]: Slot }\n  ```\n\n  > Types are simplified for readability.\n\n- **Details**\n\n  The first argument can either be a string (for native elements) or a Vue component definition. The second argument is the props to be passed, and the third argument is the children.\n\n  When creating a component vnode, the children must be passed as slot functions. A single slot function can be passed if the component expects only the default slot. Otherwise, the slots must be passed as an object of slot functions.\n\n  For convenience, the props argument can be omitted when the children is not a slots object.\n\n- **Example**\n\n  Creating native elements:\n\n  ```js\n  import { h } from 'vue'\n\n  // all arguments except the type are optional\n  h('div')\n  h('div', { id: 'foo' })\n\n  // both attributes and properties can be used in props\n  // Vue automatically picks the right way to assign it\n  h('div', { class: 'bar', innerHTML: 'hello' })\n\n  // class and style have the same object / array\n  // value support like in templates\n  h('div', { class: [foo, { bar }], style: { color: 'red' } })\n\n  // event listeners should be passed as onXxx\n  h('div', { onClick: () => {} })\n\n  // children can be a string\n  h('div', { id: 'foo' }, 'hello')\n\n  // props can be omitted when there are no props\n  h('div', 'hello')\n  h('div', [h('span', 'hello')])\n\n  // children array can contain mixed vnodes and strings\n  h('div', ['hello', h('span', 'hello')])\n  ```\n\n  Creating components:\n\n  ```js\n  import Foo from './Foo.vue'\n\n  // passing props\n  h(Foo, {\n    // equivalent of some-prop=\"hello\"\n    someProp: 'hello',\n    // equivalent of @update=\"() => {}\"\n    onUpdate: () => {}\n  })\n\n  // passing single default slot\n  h(Foo, () => 'default slot')\n\n  // passing named slots\n  // notice the `null` is required to avoid\n  // slots object being treated as props\n  h(MyComponent, null, {\n    default: () => 'default slot',\n    foo: () => h('div', 'foo'),\n    bar: () => [h('span', 'one'), h('span', 'two')]\n  })\n  ```\n\n- **See also** [Guide - Render Functions - Creating VNodes](/guide/extras/render-function#creating-vnodes)\n\n## mergeProps() {#mergeprops}\n\nMerge multiple props objects with special handling for certain props.\n\n- **Type**\n\n  ```ts\n  function mergeProps(...args: object[]): object\n  ```\n\n- **Details**\n\n  `mergeProps()` supports merging multiple props objects with special handling for the following props:\n\n  - `class`\n  - `style`\n  - `onXxx` event listeners - multiple listeners with the same name will be merged into an array.\n\n  If you do not need the merge behavior and want simple overwrites, native object spread can be used instead.\n\n- **Example**\n\n  ```js\n  import { mergeProps } from 'vue'\n\n  const one = {\n    class: 'foo',\n    onClick: handlerA\n  }\n\n  const two = {\n    class: { bar: true },\n    onClick: handlerB\n  }\n\n  const merged = mergeProps(one, two)\n  /**\n   {\n     class: 'foo bar',\n     onClick: [handlerA, handlerB]\n   }\n   */\n  ```\n\n## cloneVNode() {#clonevnode}\n\nClones a vnode.\n\n- **Type**\n\n  ```ts\n  function cloneVNode(vnode: VNode, extraProps?: object): VNode\n  ```\n\n- **Details**\n\n  Returns a cloned vnode, optionally with extra props to merge with the original.\n\n  Vnodes should be considered immutable once created, and you should not mutate the props of an existing vnode. Instead, clone it with different / extra props.\n\n  Vnodes have special internal properties, so cloning them is not as simple as an object spread. `cloneVNode()` handles most of the internal logic.\n\n- **Example**\n\n  ```js\n  import { h, cloneVNode } from 'vue'\n\n  const original = h('div')\n  const cloned = cloneVNode(original, { id: 'foo' })\n  ```\n\n## isVNode() {#isvnode}\n\nChecks if a value is a vnode.\n\n- **Type**\n\n  ```ts\n  function isVNode(value: unknown): boolean\n  ```\n\n## resolveComponent() {#resolvecomponent}\n\nFor manually resolving a registered component by name.\n\n- **Type**\n\n  ```ts\n  function resolveComponent(name: string): Component | string\n  ```\n\n- **Details**\n\n  **Note: you do not need this if you can import the component directly.**\n\n  `resolveComponent()` must be called inside<span class=\"composition-api\"> either `setup()` or</span> the render function in order to resolve from the correct component context.\n\n  If the component is not found, a runtime warning will be emitted, and the name string is returned.\n\n- **Example**\n\n  <div class=\"composition-api\">\n\n  ```js\n  import { h, resolveComponent } from 'vue'\n\n  export default {\n    setup() {\n      const ButtonCounter = resolveComponent('ButtonCounter')\n\n      return () => {\n        return h(ButtonCounter)\n      }\n    }\n  }\n  ```\n\n  </div>\n  <div class=\"options-api\">\n\n  ```js\n  import { h, resolveComponent } from 'vue'\n\n  export default {\n    render() {\n      const ButtonCounter = resolveComponent('ButtonCounter')\n      return h(ButtonCounter)\n    }\n  }\n  ```\n\n  </div>\n\n- **See also** [Guide - Render Functions - Components](/guide/extras/render-function#components)\n\n## resolveDirective() {#resolvedirective}\n\nFor manually resolving a registered directive by name.\n\n- **Type**\n\n  ```ts\n  function resolveDirective(name: string): Directive | undefined\n  ```\n\n- **Details**\n\n  **Note: you do not need this if you can import the directive directly.**\n\n  `resolveDirective()` must be called inside<span class=\"composition-api\"> either `setup()` or</span> the render function in order to resolve from the correct component context.\n\n  If the directive is not found, a runtime warning will be emitted, and the function returns `undefined`.\n\n- **See also** [Guide - Render Functions - Custom Directives](/guide/extras/render-function#custom-directives)\n\n## withDirectives() {#withdirectives}\n\nFor adding custom directives to vnodes.\n\n- **Type**\n\n  ```ts\n  function withDirectives(\n    vnode: VNode,\n    directives: DirectiveArguments\n  ): VNode\n\n  // [Directive, value, argument, modifiers]\n  type DirectiveArguments = Array<\n    | [Directive]\n    | [Directive, any]\n    | [Directive, any, string]\n    | [Directive, any, string, DirectiveModifiers]\n  >\n  ```\n\n- **Details**\n\n  Wraps an existing vnode with custom directives. The second argument is an array of custom directives. Each custom directive is also represented as an array in the form of `[Directive, value, argument, modifiers]`. Tailing elements of the array can be omitted if not needed.\n\n- **Example**\n\n  ```js\n  import { h, withDirectives } from 'vue'\n\n  // a custom directive\n  const pin = {\n    mounted() {\n      /* ... */\n    },\n    updated() {\n      /* ... */\n    }\n  }\n\n  // <div v-pin:top.animate=\"200\"></div>\n  const vnode = withDirectives(h('div'), [\n    [pin, 200, 'top', { animate: true }]\n  ])\n  ```\n\n- **See also** [Guide - Render Functions - Custom Directives](/guide/extras/render-function#custom-directives)\n\n## withModifiers() {#withmodifiers}\n\nFor adding built-in [`v-on` modifiers](/guide/essentials/event-handling#event-modifiers) to an event handler function.\n\n- **Type**\n\n  ```ts\n  function withModifiers(fn: Function, modifiers: string[]): Function\n  ```\n\n- **Example**\n\n  ```js\n  import { h, withModifiers } from 'vue'\n\n  const vnode = h('button', {\n    // equivalent of v-on:click.stop.prevent\n    onClick: withModifiers(() => {\n      // ...\n    }, ['stop', 'prevent'])\n  })\n  ```\n\n- **See also** [Guide - Render Functions - Event Modifiers](/guide/extras/render-function#event-modifiers)",
          "questions": [
            "What is the purpose of the `h()` function in Vue?",
            "What are the arguments of the `h()` function?",
            "How are children passed to a component vnode?",
            "What is the difference between passing a single slot function and multiple slot functions to a component vnode?",
            "What is the purpose of the `mergeProps()` function in Vue?",
            "What props does `mergeProps()` handle with special behavior?",
            "How should vnodes be treated once created?",
            "What is the purpose of the `resolveComponent()` function in Vue?",
            "What is the purpose of the `resolveDirective()` function in Vue?",
            "What is the purpose of the `withModifiers()` function in Vue?"
          ]
        }
      ]
    }
  ]
}
